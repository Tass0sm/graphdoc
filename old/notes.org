* Package Managers
** The "Distribution" Package Manager

 Examples: Zypper, Apt

*** They Manage Dependencies
*** They Install Software
** The "Language" Package Manager

 Examples: PPM, NPM, Emacs package.el...

*** They Download Dependencies
*** They Build and Install Software
* Is This Useful?
** What can Pandoc do?

Here are all the document formats supported by Pandoc (either converting from or to):

1. Lightweight markup formats
 ↔ Markdown (including CommonMark and GitHub-flavored Markdown)
 ↔ reStructuredText
 → AsciiDoc
 ↔ Emacs Org-Mode
 ↔ Emacs Muse
 ↔ Textile
 ← txt2tags
2. HTML
 ↔ (X)HTML 4
 ↔ HTML5
3. Ebooks
 ↔ EPUB version 2 or 3
 ↔ FictionBook2
4. Documentation formats
 → GNU TexInfo
 ↔ Haddock markup
5. Roff formats
 ↔ roff man
 → roff ms
6. TeX formats
 ↔ LaTeX
 → ConTeXt
7. XML formats
 ↔ DocBook version 4 or 5
 ↔ JATS
 → TEI Simple
8. Outline formats
 ↔ OPML
9. Data formats
 ← CSV tables
10. Word processor formats
 ↔ Microsoft Word docx
 ↔ OpenOffice/LibreOffice ODT
 → OpenDocument XML
 → Microsoft PowerPoint
11. Interactive notebook formats
 ↔ Jupyter notebook (ipynb)
12. Page layout formats
 → InDesign ICML
13. Wiki markup formats
 ↔ MediaWiki markup
 ↔ DokuWiki markup
 ← TikiWiki markup
 ← TWiki markup
 ← Vimwiki markup
 → XWiki markup
 → ZimWiki markup
 ↔ Jira wiki markup
14. Slide show formats
 → LaTeX Beamer
 → Slidy
 → reveal.js
 → Slideous
 → S5
 → DZSlides
15. Custom formats
 → custom writers can be written in lua.
16. PDF
 → via pdflatex, lualatex, xelatex, latexmk, tectonic, wkhtmltopdf,
   weasyprint, prince, context, or pdfroff

This is like a graph, which can be represented with a matrix. I'll leave a few
off to make this compact.

|----------+----------+----------+-------+---------|
| From\To  | Markdown | Org-Mode | HTML5 | TexInfo |
|----------+----------+----------+-------+---------|
| Markdown |        1 |        1 |     1 |       1 |
| Org-Mode |        1 |        1 |     1 |       1 |
| HTML5    |        1 |        1 |     1 |       1 |
| Texinfo  |        0 |        0 |     0 |       1 |
|----------+----------+----------+-------+---------|

Since there is no reader for Texinfo, we can go from Texinfo to the other
formats. Treedoc aims to somewhat fix this. Lets make a similar matrix for the
use-case of Treedoc, looking only at conversion between entire documentation
trees (as opposed to just singular documents).

** What can we do with documentation trees?

We have a few major tools that convert documentation tree sources to other
formats.

*** Sphinx

First major one is sphinx. Here's what Sphinx can do:

|---------------+---------+------------+--------+------+----------+--------+---------+------+-------+----------+------+-----|
| from\to       | dirhtml | singlehtml | pickle | json | htmlhelp | qthelp | devhelp | epub | latex | latexpdf | text | man |
|---------------+---------+------------+--------+------+----------+--------+---------+------+-------+----------+------+-----|
| RST + Sphinx  |       1 |          1 |      1 |    1 |        1 |      1 |       1 |    1 |     1 |        1 |    1 |   1 |
|---------------+---------+------------+--------+------+----------+--------+---------+------+-------+----------+------+-----|
| Anything else |       0 |          0 |      0 |    0 |        0 |      0 |       0 |    0 |     0 |        0 |    0 |   0 |
|---------------+---------+------------+--------+------+----------+--------+---------+------+-------+----------+------+-----|

Sphinx only takes one input format. But it can output a good variety of
things. Problem is that its only one way. If someone can only access one of the
output formats (without the source), they're stuck.

Its also important to note that a lot of the time that HTML output you find
online won't be necessarily generated by Sphinx. So we want Treedoc to work with
generic HTML. Treedoc will be needed to dissect HTML a good deal (removing
ceremony stuff (header, footer, other...)) for the content to be converted
reliably. We'll look how possible this is later.

*** Doxygen

Second major one is Doxygen. Here's what Doxygen can do:

|------------------+------+-------+-----+-----+-----+---------|
| from\to          | HTML | LaTeX | Man | RTF | XML | DocBook |
|------------------+------+-------+-----+-----+-----+---------|
| Doxygen Comments |    1 |     1 |   1 |   1 |   1 |       1 |
|------------------+------+-------+-----+-----+-----+---------|
| Anything Else    |    0 |     0 |   0 |   0 |   0 |       0 |
|------------------+------+-------+-----+-----+-----+---------|

*** More will come later.

** TODO What should Treedoc strive to do?

Well, we find most projects' documentation accessible as HTML. For example, I
can only find Chicken Scheme documentation in HTML. None of the tools here work
to convert HTML trees to anything, so we'll first try to read/parse a website
made up of multiple HTML pages. Lets now look at the Treedoc program layout,
using the Chicken Scheme documentation for an example.

* Program Layout
** Reading

Pandoc works by reading a file's text into its intermediate representation.

Treedoc works by reading a directories files into an organized tree, for which
the text is then converted to Pandoc's IR.

A Tree is made with an unfolding function:

#+BEGIN_SRC haskell
unfoldTree :: (b -> (a, [b]) -> b -> Tree a
#+END_SRC

Since unfoldTree requires a function that maps from a seed type to a tuple of
the corresponding node's contents and a list of more seeds, there needs to be a
way to get the ordered list of children files for a given file. Getting the text
from the file is trivial.

#+BEGIN_SRC haskell
get____Children :: FilePath -> [FilePath]
#+END_SRC

This clearly can be achieved differently under different ordering methods and
markup types. Lets pick an example to work with that hasn't been done before: A
Multi-Page HTML Document.

Some projects have generic HTML Docs with no source easily provided (like
PicoLisp). If one could just manually copy the entire documentation into another
format, surely a program can do it too.

*** Chicken Scheme Multi-Page HTML5 Documentation

The reference website:
[[https://wiki.call-cc.org/man/5/The%20User%27s%20Manual#the-chicken-users-manual][https://wiki.call-cc.org/man/5/The%20User%27s%20Manual#the-chicken-users-manual]]

We can use this for a root, but it would be either impractical or impossible for
Treedoc to figure that out automatically. We'll make that an input for the
program.

We now have a root. How do we get children? One way is to follow every link in
the body of the page. Here's the body:

#+BEGIN_SRC html
<body>
  <div id="menu">
    <ul>
      <li><a href="/" class="internal">Wiki</a></li>
      <li><a href="//code.call-cc.org/" class="internal">Download</a></li>
      <li><a href="/manual/index" class="internal">Manual</a></li>
      <li><a href="//eggs.call-cc.org" class="internal">Eggs</a></li>
      <li><a href="//api.call-cc.org/5/doc/" class="internal">API</a></li>
      <li><a href="//tests.call-cc.org/" class="internal">Tests</a></li>
      <li><a href="//bugs.call-cc.org/" class="internal">Bugs</a></li>
    </ul>
  </div>
  <div id="search">
    <form action="/search">
      <div>
        <label>free text<input type="text" name="text" /></label>
        <label>identifier<input type="text" name="ident" /></label>
        <input type="submit" value="search" /><a href="/search-help">search help</a>
      </div>
    </form>
  </div>

  <ul id="page-specific-links">
    <li><a href="?action=show">show</a></li>
    <li><a href="?action=edit" rel="nofollow">edit</a></li>
    <li><a href="?action=history">history</a></li></ul>
  <div id="content">
    <ul class="tags">
      <li>manual</li></ul><a href="#the-chicken-users-manual">
      <h2 id="the-chicken-users-manual">The CHICKEN User's Manual</h2></a><img id="big-logo" style="float:right; margin-left:1em;" src="http://wiki.call-cc.org/chicken-small.png" alt="Stylized picture of a chicken" />
    <p>This is the manual for CHICKEN Scheme, version 5.2.0</p>
    <ul>
      <li><a href="Getting started" class="internal">Getting started</a> : What is CHICKEN and how do I use it?</li>
      <li><a href="Using the interpreter" class="internal">Using the interpreter</a> : How to use the interactive interpreter, <tt>csi</tt></li>
      <li><a href="Using the compiler" class="internal">Using the compiler</a>  : How to use the batch compiler</li>
      <li><a href="Deviations from the standard" class="internal">Deviations from the standard</a> : Where CHICKEN deviates from R5RS</li>
      <li><a href="Extensions to the standard" class="internal">Extensions to the standard</a> : Extensions to R5RS that CHICKEN provides</li>
      <li><a href="Debugging" class="internal">Debugging</a> : Using the &quot;feathers&quot; debugger to inspect running CHICKEN programs.</li>
      <li><a href="Included modules" class="internal">Included modules</a> : A reference to CHICKEN's core module library</li>
      <li><a href="Interface to external functions and variables" class="internal">Interface to external functions and variables</a> : Accessing C/C++ code and data</li>
      <li><a href="Modules" class="internal">Modules</a> : How CHICKEN manages namespaces</li>
      <li><a href="Types" class="internal">Types</a> : Optionally typed Scheme code</li>
      <li><a href="Declarations" class="internal">Declarations</a> : Compiler declarations</li>
      <li><a href="Extensions" class="internal">Extensions</a> : Packaging and installing extension libraries</li>
      <li><a href="Extension tools" class="internal">Extension tools</a> : <tt>chicken-[un]install</tt> and <tt>chicken-status</tt></li>
      <li><a href="Egg specification format" class="internal">Egg specification format</a> : Format of egg description files</li>
      <li><a href="Units and linking model" class="internal">Units and linking model</a> : How Scheme compilation units are mapped to C</li>
      <li><a href="Deployment" class="internal">Deployment</a> : How to distribute and ship CHICKEN programs and libraries</li>
      <li><a href="Cross development" class="internal">Cross development</a> : Using CHICKEN to cross-compile for other architectures</li>
      <li><a href="Bugs and limitations" class="internal">Bugs and limitations</a> : Things that do not work yet.</li>
      <li><a href="Acknowledgements" class="internal">Acknowledgements</a> : A list of some of the people that have contributed to make CHICKEN what it is</li>
      <li><a href="Bibliography" class="internal">Bibliography</a> : Links to documents that may be of interest</li>
    </ul>
  </div>
</body>
#+END_SRC

It looks like just getting every link in the body will give us some undesired
things, like the top banner or search bar links. We also can't explicitly filter
out "non-body" content using any of the ids or classes in the example. Those
can't be expected to stay the same across websites. But a new step might be
following only /relative/ links. All the other links start at the root directory
for the website, but the one's we're interested in ("Getting started", "Using
the interpreter", etc.) are all relative links. Nice.

So the get children function looks something like:

#+BEGIN_SRC haskell
getGenericHTMLChildren :: FilePath -> [FilePath]
#+END_SRC

*** ReStructuredText under Sphinx

Let's look at ReStructuredText too. Since sphinx outputs to several formats
already, this is kind of a low priority reader to write. Might make a writer
before the reader.

Since there's already a reference program (sphinx) that somehow obtains the
structure of the sources files, we can look at that program's [[https://www.sphinx-doc.org/en/master/usage/quickstart.html][documentation]] to
figure out how that's done.

"The root directory of a Sphinx collection of plain-text document sources is
called the source directory. This directory also contains the Sphinx
configuration file conf.py, where you can configure all aspects of how Sphinx
reads your sources and builds your documentation."

We'll ignore the conf.py part for now, but it might be useful if we need Treedoc
to also change how it reads things based on that file. Maybe we can replicate
the possible options there as options to our program's logic.

Reading on...

"...a master document, index.rst. The main function of the master document is to
serve as a welcome page, and to contain the root of the “table of contents tree”
(or toctree). This is one of the main things that Sphinx adds to
reStructuredText, a way to connect multiple files to a single hierarchy of
documents."

That's very important. Sphinx connects RST files via a tree put in text in the
master document (usually called 'index.rst'). So we just need to read this tree
and the children of some file can be identified.

Lets make a sample file to demonstrate this.

[[file:examples/rst-sphinx/source/index.rst][The sphinx quickstart master file.]]

It has an index, which corresponds to a root in the documentation tree. That
root has one child, represented in the file "level_one.rst" in the source
directory. The name of that file is "Some RST Structure" apparently and it has a
paragraph in it.

That structure should be replicated when we use Treedoc to read the source and
output it to a new format.

How is the "toc_tree" directive parsed and understood by sphinx? Lets look:  html



