\input texinfo
@documentencoding UTF-8

@ifnottex
@paragraphindent 0
@end ifnottex
@titlepage
@title Render Functions & JSX
@end titlepage

@node Top
@top Render Functions & JSX

@node Basics
@section Basics
@anchor{#basics}
Vue recommends using templates to build your HTML in the vast majority
of cases. There are situations however, where you really need the full
programmatic power of JavaScript. That's where you can use the
@strong{render function}, a closer-to-the-compiler alternative to
templates.

Let's dive into a simple example where a @code{render} function would be
practical. Say you want to generate anchored headings:

@verbatim
<h1>
  <a name="hello-world" href="#hello-world">
    Hello world!
  </a>
</h1>
@end verbatim

For the HTML above, you decide you want this component interface:

@verbatim
<anchored-heading :level="1">Hello world!</anchored-heading>
@end verbatim

When you get started with a component that only generates a heading
based on the @code{level} prop, you quickly arrive at this:

@verbatim
<script type="text/x-template" id="anchored-heading-template">
  <h1 v-if="level === 1">
    <slot></slot>
  </h1>
  <h2 v-else-if="level === 2">
    <slot></slot>
  </h2>
  <h3 v-else-if="level === 3">
    <slot></slot>
  </h3>
  <h4 v-else-if="level === 4">
    <slot></slot>
  </h4>
  <h5 v-else-if="level === 5">
    <slot></slot>
  </h5>
  <h6 v-else-if="level === 6">
    <slot></slot>
  </h6>
</script>
@end verbatim

@verbatim
Vue.component('anchored-heading', {
  template: '#anchored-heading-template',
  props: {
    level: {
      type: Number,
      required: true
    }
  }
})
@end verbatim

That template doesn't feel great. It's not only verbose, but we're
duplicating @code{<slot></slot>} for every heading level and will have
to do the same when we add the anchor element.

While templates work great for most components, it's clear that this
isn't one of them. So let's try rewriting it with a @code{render}
function:

@verbatim
Vue.component('anchored-heading', {
  render: function (createElement) {
    return createElement(
      'h' + this.level,   // tag name
      this.$slots.default // array of children
    )
  },
  props: {
    level: {
      type: Number,
      required: true
    }
  }
})
@end verbatim

Much simpler! Sort of. The code is shorter, but also requires greater
familiarity with Vue instance properties. In this case, you have to know
that when you pass children without a @code{v-slot} directive into a
component, like the @code{Hello world!} inside of
@code{anchored-heading}, those children are stored on the component
instance at @code{$slots.default}. If you haven't already, @strong{it's
recommended to read through the
@uref{../api/#Instance-Properties,instance properties API} before diving
into render functions.}

@node Nodes Trees and the Virtual DOM
@section Nodes, Trees, and the Virtual DOM
@anchor{#nodes-trees-and-the-virtual-dom}
Before we dive into render functions, it's important to know a little
about how browsers work. Take this HTML for example:

@verbatim
<div>
  <h1>My title</h1>
  Some text content
  <!-- TODO: Add tagline  -->
</div>
@end verbatim

When a browser reads this code, it builds a
@uref{https://javascript.info/dom-nodes,tree of ``DOM nodes''} to help
it keep track of everything, just as you might build a family tree to
keep track of your extended family.

The tree of DOM nodes for the HTML above looks like this:

@float
@image{/images/dom-tree,,,DOM Tree Visualization,png}
@caption{DOM Tree Visualization}
@end float

Every element is a node. Every piece of text is a node. Even comments
are nodes! A node is just a piece of the page. And as in a family tree,
each node can have children (i.e.@ each piece can contain other pieces).

Updating all these nodes efficiently can be difficult, but thankfully,
you never have to do it manually. Instead, you tell Vue what HTML you
want on the page, in a template:

@verbatim
<h1>{{ blogTitle }}</h1>
@end verbatim

Or a render function:

@verbatim
render: function (createElement) {
  return createElement('h1', this.blogTitle)
}
@end verbatim

And in both cases, Vue automatically keeps the page updated, even when
@code{blogTitle} changes.

@menu
* The Virtual DOM::
@end menu

@node The Virtual DOM
@subsection The Virtual DOM
@anchor{#the-virtual-dom}
Vue accomplishes this by building a @strong{virtual DOM} to keep track
of the changes it needs to make to the real DOM. Taking a closer look at
this line:

@verbatim
return createElement('h1', this.blogTitle)
@end verbatim

What is @code{createElement} actually returning? It's not @emph{exactly}
a real DOM element. It could perhaps more accurately be named
@code{createNodeDescription}, as it contains information describing to
Vue what kind of node it should render on the page, including
descriptions of any child nodes. We call this node description a
``virtual node'', usually abbreviated to @strong{VNode}. ``Virtual DOM''
is what we call the entire tree of VNodes, built by a tree of Vue
components.

@node createElement Arguments
@section @code{createElement} Arguments
@anchor{#createelement-arguments}
The next thing you'll have to become familiar with is how to use
template features in the @code{createElement} function. Here are the
arguments that @code{createElement} accepts:

@verbatim
// @returns {VNode}
createElement(
  // {String | Object | Function}
  // An HTML tag name, component options, or async
  // function resolving to one of these. Required.
  'div',

  // {Object}
  // A data object corresponding to the attributes
  // you would use in a template. Optional.
  {
    // (see details in the next section below)
  },

  // {String | Array}
  // Children VNodes, built using `createElement()`,
  // or using strings to get 'text VNodes'. Optional.
  [
    'Some text comes first.',
    createElement('h1', 'A headline'),
    createElement(MyComponent, {
      props: {
        someProp: 'foobar'
      }
    })
  ]
)
@end verbatim

@menu
* The Data Object In-Depth::
* Complete Example::
* Constraints::
@end menu

@node The Data Object In-Depth
@subsection The Data Object In-Depth
@anchor{#the-data-object-in-depth}
One thing to note: similar to how @code{v-bind:class} and
@code{v-bind:style} have special treatment in templates, they have their
own top-level fields in VNode data objects. This object also allows you
to bind normal HTML attributes as well as DOM properties such as
@code{innerHTML} (this would replace the @code{v-html} directive):

@verbatim
{
  // Same API as `v-bind:class`, accepting either
  // a string, object, or array of strings and objects.
  class: {
    foo: true,
    bar: false
  },
  // Same API as `v-bind:style`, accepting either
  // a string, object, or array of objects.
  style: {
    color: 'red',
    fontSize: '14px'
  },
  // Normal HTML attributes
  attrs: {
    id: 'foo'
  },
  // Component props
  props: {
    myProp: 'bar'
  },
  // DOM properties
  domProps: {
    innerHTML: 'baz'
  },
  // Event handlers are nested under `on`, though
  // modifiers such as in `v-on:keyup.enter` are not
  // supported. You'll have to manually check the
  // keyCode in the handler instead.
  on: {
    click: this.clickHandler
  },
  // For components only. Allows you to listen to
  // native events, rather than events emitted from
  // the component using `vm.$emit`.
  nativeOn: {
    click: this.nativeClickHandler
  },
  // Custom directives. Note that the `binding`'s
  // `oldValue` cannot be set, as Vue keeps track
  // of it for you.
  directives: [
    {
      name: 'my-custom-directive',
      value: '2',
      expression: '1 + 1',
      arg: 'foo',
      modifiers: {
        bar: true
      }
    }
  ],
  // Scoped slots in the form of
  // { name: props => VNode | Array<VNode> }
  scopedSlots: {
    default: props => createElement('span', props.text)
  },
  // The name of the slot, if this component is the
  // child of another component
  slot: 'name-of-slot',
  // Other special top-level properties
  key: 'myKey',
  ref: 'myRef',
  // If you are applying the same ref name to multiple
  // elements in the render function. This will make `$refs.myRef` become an
  // array
  refInFor: true
}
@end verbatim

@node Complete Example
@subsection Complete Example
@anchor{#complete-example}
With this knowledge, we can now finish the component we started:

@verbatim
var getChildrenTextContent = function (children) {
  return children.map(function (node) {
    return node.children
      ? getChildrenTextContent(node.children)
      : node.text
  }).join('')
}

Vue.component('anchored-heading', {
  render: function (createElement) {
    // create kebab-case id
    var headingId = getChildrenTextContent(this.$slots.default)
      .toLowerCase()
      .replace(/\W+/g, '-')
      .replace(/(^-|-$)/g, '')

    return createElement(
      'h' + this.level,
      [
        createElement('a', {
          attrs: {
            name: headingId,
            href: '#' + headingId
          }
        }, this.$slots.default)
      ]
    )
  },
  props: {
    level: {
      type: Number,
      required: true
    }
  }
})
@end verbatim

@node Constraints
@subsection Constraints
@anchor{#constraints}

@menu
* VNodes Must Be Unique::
@end menu

@node VNodes Must Be Unique
@subsubsection VNodes Must Be Unique
@anchor{#vnodes-must-be-unique}
All VNodes in the component tree must be unique. That means the
following render function is invalid:

@verbatim
render: function (createElement) {
  var myParagraphVNode = createElement('p', 'hi')
  return createElement('div', [
    // Yikes - duplicate VNodes!
    myParagraphVNode, myParagraphVNode
  ])
}
@end verbatim

If you really want to duplicate the same element/component many times,
you can do so with a factory function. For example, the following render
function is a perfectly valid way of rendering 20 identical paragraphs:

@verbatim
render: function (createElement) {
  return createElement('div',
    Array.apply(null, { length: 20 }).map(function () {
      return createElement('p', 'hi')
    })
  )
}
@end verbatim

@node Replacing Template Features with Plain JavaScript
@section Replacing Template Features with Plain JavaScript
@anchor{#replacing-template-features-with-plain-javascript}

@menu
* v-if and v-for::
* v-model::
* Event & Key Modifiers::
* Slots::
@end menu

@node v-if and v-for
@subsection @code{v-if} and @code{v-for}
@anchor{#v-if-and-v-for}
Wherever something can be easily accomplished in plain JavaScript, Vue
render functions do not provide a proprietary alternative. For example,
in a template using @code{v-if} and @code{v-for}:

@verbatim
<ul v-if="items.length">
  <li v-for="item in items">{{ item.name }}</li>
</ul>
<p v-else>No items found.</p>
@end verbatim

This could be rewritten with JavaScript's @code{if}/@code{else} and
@code{map} in a render function:

@verbatim
props: ['items'],
render: function (createElement) {
  if (this.items.length) {
    return createElement('ul', this.items.map(function (item) {
      return createElement('li', item.name)
    }))
  } else {
    return createElement('p', 'No items found.')
  }
}
@end verbatim

@node v-model
@subsection @code{v-model}
@anchor{#v-model}
There is no direct @code{v-model} counterpart in render functions - you
will have to implement the logic yourself:

@verbatim
props: ['value'],
render: function (createElement) {
  var self = this
  return createElement('input', {
    domProps: {
      value: self.value
    },
    on: {
      input: function (event) {
        self.$emit('input', event.target.value)
      }
    }
  })
}
@end verbatim

This is the cost of going lower-level, but it also gives you much more
control over the interaction details compared to @code{v-model}.

@node Event & Key Modifiers
@subsection Event & Key Modifiers
@anchor{#event-key-modifiers}
For the @code{.passive}, @code{.capture} and @code{.once} event
modifiers, Vue offers prefixes that can be used with @code{on}:

@multitable {@code{.capture.once} or@code{.once.capture}} {@code{~!}} 
@headitem 
Modifier(s)
 @tab Prefix
@item 
@code{.passive}
 @tab @code{&}
@item 
@code{.capture}
 @tab @code{!}
@item 
@code{.once}
 @tab @code{~}
@item 
@code{.capture.once} or@code{.once.capture}
 @tab @code{~!}
@end multitable

For example:

@verbatim
on: {
  '!click': this.doThisInCapturingMode,
  '~keyup': this.doThisOnce,
  '~!mouseover': this.doThisOnceInCapturingMode
}
@end verbatim

For all other event and key modifiers, no proprietary prefix is
necessary, because you can use event methods in the handler:

@multitable @columnfractions 0.50 0.50 
@headitem 
Modifier(s)
 @tab Equivalent in Handler
@item 
@code{.stop}
 @tab @code{event.stopPropagation()}
@item 
@code{.prevent}
 @tab @code{event.preventDefault()}
@item 
@code{.self}
 @tab @code{if (event.target !== event.currentTarget) return}
@item 
Keys:@code{.enter}, @code{.13}
 @tab @code{if (event.keyCode !== 13) return} (change @code{13} to
@uref{http://keycode.info/,another key code} for other key modifiers)
@item 
Modifiers Keys:@code{.ctrl}, @code{.alt}, @code{.shift}, @code{.meta}
 @tab @code{if (!event.ctrlKey) return} (change @code{ctrlKey} to
@code{altKey}, @code{shiftKey}, or @code{metaKey}, respectively)
@end multitable

Here's an example with all of these modifiers used together:

@verbatim
on: {
  keyup: function (event) {
    // Abort if the element emitting the event is not
    // the element the event is bound to
    if (event.target !== event.currentTarget) return
    // Abort if the key that went up is not the enter
    // key (13) and the shift key was not held down
    // at the same time
    if (!event.shiftKey || event.keyCode !== 13) return
    // Stop event propagation
    event.stopPropagation()
    // Prevent the default keyup handler for this element
    event.preventDefault()
    // ...
  }
}
@end verbatim

@node Slots
@subsection Slots
@anchor{#slots}
You can access static slot contents as Arrays of VNodes from
@uref{../api/#vm-slots,@code{this.$slots}}:

@verbatim
render: function (createElement) {
  // `<div><slot></slot></div>`
  return createElement('div', this.$slots.default)
}
@end verbatim

And access scoped slots as functions that return VNodes from
@uref{../api/#vm-scopedSlots,@code{this.$scopedSlots}}:

@verbatim
props: ['message'],
render: function (createElement) {
  // `<div><slot :text="message"></slot></div>`
  return createElement('div', [
    this.$scopedSlots.default({
      text: this.message
    })
  ])
}
@end verbatim

To pass scoped slots to a child component using render functions, use
the @code{scopedSlots} field in VNode data:

@verbatim
render: function (createElement) {
  // `<div><child v-slot="props"><span>{{ props.text }}</span></child></div>`
  return createElement('div', [
    createElement('child', {
      // pass `scopedSlots` in the data object
      // in the form of { name: props => VNode | Array<VNode> }
      scopedSlots: {
        default: function (props) {
          return createElement('span', props.text)
        }
      }
    })
  ])
}
@end verbatim

@node JSX
@section JSX
@anchor{#jsx}
If you're writing a lot of @code{render} functions, it might feel
painful to write something like this:

@verbatim
createElement(
  'anchored-heading', {
    props: {
      level: 1
    }
  }, [
    createElement('span', 'Hello'),
    ' world!'
  ]
)
@end verbatim

Especially when the template version is so simple in comparison:

@verbatim
<anchored-heading :level="1">
  <span>Hello</span> world!
</anchored-heading>
@end verbatim

That's why there's a @uref{https://github.com/vuejs/jsx,Babel plugin} to
use JSX with Vue, getting us back to a syntax that's closer to
templates:

@verbatim
import AnchoredHeading from './AnchoredHeading.vue'

new Vue({
  el: '#demo',
  render: function (h) {
    return (
      <AnchoredHeading level={1}>
        <span>Hello</span> world!
      </AnchoredHeading>
    )
  }
})
@end verbatim

Aliasing @code{createElement} to @code{h} is a common convention you'll
see in the Vue ecosystem and is actually required for JSX. Starting with
@uref{https://github.com/vuejs/babel-plugin-transform-vue-jsx#h-auto-injection,version
3.4.0} of the Babel plugin for Vue, we automatically inject
@code{const h = this.$createElement} in any method and getter (not
functions or arrow functions), declared in ES2015 syntax that has JSX,
so you can drop the @code{(h)} parameter. With prior versions of the
plugin, your app would throw an error if @code{h} was not available in
the scope.
For more on how JSX maps to JavaScript, see the
@uref{https://github.com/vuejs/jsx#installation,usage docs}.

@node Functional Components
@section Functional Components
@anchor{#functional-components}
The anchored heading component we created earlier is relatively simple.
It doesn't manage any state, watch any state passed to it, and it has no
lifecycle methods. Really, it's only a function with some props.

In cases like this, we can mark components as @code{functional}, which
means that they're stateless (no @uref{../api/#Options-Data,reactive
data}) and instanceless (no @code{this} context). A @strong{functional
component} looks like this:

@verbatim
Vue.component('my-component', {
  functional: true,
  // Props are optional
  props: {
    // ...
  },
  // To compensate for the lack of an instance,
  // we are now provided a 2nd context argument.
  render: function (createElement, context) {
    // ...
  }
})
@end verbatim

@quotation
Note: in versions before 2.3.0, the @code{props} option is required if
you wish to accept props in a functional component. In 2.3.0+ you can
omit the @code{props} option and all attributes found on the component
node will be implicitly extracted as props.

The reference will be HTMLElement when used with functional components
because they're stateless and instanceless.
@end quotation
In 2.5.0+, if you are using
@uref{single-file-components.html,single-file components},
template-based functional components can be declared with:

@verbatim
<template functional>
</template>
@end verbatim

Everything the component needs is passed through @code{context}, which
is an object containing:

@itemize
@item
@code{props}: An object of the provided props
@item
@code{children}: An array of the VNode children
@item
@code{slots}: A function returning a slots object
@item
@code{scopedSlots}: (2.6.0+) An object that exposes passed-in scoped
slots. Also exposes normal slots as functions.
@item
@code{data}: The entire @ref{#The-Data-Object-In-Depth,data object},
passed to the component as the 2nd argument of @code{createElement}
@item
@code{parent}: A reference to the parent component
@item
@code{listeners}: (2.3.0+) An object containing parent-registered event
listeners. This is an alias to @code{data.on}
@item
@code{injections}: (2.3.0+) if using the
@uref{../api/#provide-inject,@code{inject}} option, this will contain
resolved injections.
@end itemize

After adding @code{functional: true}, updating the render function of
our anchored heading component would require adding the @code{context}
argument, updating @code{this.$slots.default} to
@code{context.children}, then updating @code{this.level} to
@code{context.props.level}.

Since functional components are just functions, they're much cheaper to
render.

They're also very useful as wrapper components. For example, when you
need to:

@itemize
@item
Programmatically choose one of several other components to delegate to
@item
Manipulate children, props, or data before passing them on to a child
component
@end itemize

Here's an example of a @code{smart-list} component that delegates to
more specific components, depending on the props passed to it:

@verbatim
var EmptyList = { /* ... */ }
var TableList = { /* ... */ }
var OrderedList = { /* ... */ }
var UnorderedList = { /* ... */ }

Vue.component('smart-list', {
  functional: true,
  props: {
    items: {
      type: Array,
      required: true
    },
    isOrdered: Boolean
  },
  render: function (createElement, context) {
    function appropriateListComponent () {
      var items = context.props.items

      if (items.length === 0)           return EmptyList
      if (typeof items[0] === 'object') return TableList
      if (context.props.isOrdered)      return OrderedList

      return UnorderedList
    }

    return createElement(
      appropriateListComponent(),
      context.data,
      context.children
    )
  }
})
@end verbatim

@menu
* Passing Attributes and Events to Child Elements/Components::
* slots vs children::
@end menu

@node Passing Attributes and Events to Child Elements/Components
@subsection Passing Attributes and Events to Child Elements/Components
@anchor{#passing-attributes-and-events-to-child-elementscomponents}
On normal components, attributes not defined as props are automatically
added to the root element of the component, replacing or
@uref{class-and-style.html,intelligently merging with} any existing
attributes of the same name.

Functional components, however, require you to explicitly define this
behavior:

@verbatim
Vue.component('my-functional-button', {
  functional: true,
  render: function (createElement, context) {
    // Transparently pass any attributes, event listeners, children, etc.
    return createElement('button', context.data, context.children)
  }
})
@end verbatim

By passing @code{context.data} as the second argument to
@code{createElement}, we are passing down any attributes or event
listeners used on @code{my-functional-button}. It's so transparent, in
fact, that events don't even require the @code{.native} modifier.

If you are using template-based functional components, you will also
have to manually add attributes and listeners. Since we have access to
the individual context contents, we can use @code{data.attrs} to pass
along any HTML attributes and @code{listeners} @emph{(the alias for
@code{data.on})} to pass along any event listeners.

@verbatim
<template functional>
  <button
    class="btn btn-primary"
    v-bind="data.attrs"
    v-on="listeners"
  >
    <slot/>
  </button>
</template>
@end verbatim

@node slots vs children
@subsection @code{slots()} vs @code{children}
@anchor{#slots-vs-children}
You may wonder why we need both @code{slots()} and @code{children}.
Wouldn't @code{slots().default} be the same as @code{children}? In some
cases, yes - but what if you have a functional component with the
following children?

@verbatim
<my-functional-component>
  <p v-slot:foo>
    first
  </p>
  <p>second</p>
</my-functional-component>
@end verbatim

For this component, @code{children} will give you both paragraphs,
@code{slots().default} will give you only the second, and
@code{slots().foo} will give you only the first. Having both
@code{children} and @code{slots()} therefore allows you to choose
whether this component knows about a slot system or perhaps delegates
that responsibility to another component by passing along
@code{children}.

@node Template Compilation
@section Template Compilation
@anchor{#template-compilation}
You may be interested to know that Vue's templates actually compile to
render functions. This is an implementation detail you usually don't
need to know about, but if you'd like to see how specific template
features are compiled, you may find it interesting. Below is a little
demo using @code{Vue.compile} to live-compile a template string:

@bye
