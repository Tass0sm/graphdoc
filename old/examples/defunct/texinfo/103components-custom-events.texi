\input texinfo
@documentencoding UTF-8

@ifnottex
@paragraphindent 0
@end ifnottex
@titlepage
@title Custom Events
@end titlepage

@node Top
@top Custom Events

@quotation
This page assumes you've already read the
@uref{components.html,Components Basics}. Read that first if you are new
to components.
@end quotation
Learn how to work with custom events in a free Vue School lesson

@node Event Names
@section Event Names
@anchor{#event-names}
Unlike components and props, event names don't provide any automatic
case transformation. Instead, the name of an emitted event must exactly
match the name used to listen to that event. For example, if emitting a
camelCased event name:

@verbatim
this.$emit('myEvent')
@end verbatim

Listening to the kebab-cased version will have no effect:

@verbatim
<!-- Won't work -->
<my-component v-on:my-event="doSomething"></my-component>
@end verbatim

Unlike components and props, event names will never be used as variable
or property names in JavaScript, so there's no reason to use camelCase
or PascalCase. Additionally, @code{v-on} event listeners inside DOM
templates will be automatically transformed to lowercase (due to HTML's
case-insensitivity), so @code{v-on:myEvent} would become
@code{v-on:myevent} -- making @code{myEvent} impossible to listen to.

For these reasons, we recommend you @strong{always use kebab-case for
event names}.

@node Customizing Component v-model
@section Customizing Component @code{v-model}
@anchor{#customizing-component-v-model}
@quotation
New in 2.2.0+
@end quotation
By default, @code{v-model} on a component uses @code{value} as the prop
and @code{input} as the event, but some input types such as checkboxes
and radio buttons may want to use the @code{value} attribute for a
@uref{https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox#Value,different
purpose}. Using the @code{model} option can avoid a conflict in such
cases:

@verbatim
Vue.component('base-checkbox', {
  model: {
    prop: 'checked',
    event: 'change'
  },
  props: {
    checked: Boolean
  },
  template: `
    <input
      type="checkbox"
      v-bind:checked="checked"
      v-on:change="$emit('change', $event.target.checked)"
    >
  `
})
@end verbatim

Now when using @code{v-model} on this component:

@verbatim
<base-checkbox v-model="lovingVue"></base-checkbox>
@end verbatim

the value of @code{lovingVue} will be passed to the @code{checked} prop.
The @code{lovingVue} property will then be updated when
@code{<base-checkbox>} emits a @code{change} event with a new value.

Note that you still have to declare the checked prop in the component's
props option.

@node Binding Native Events to Components
@section Binding Native Events to Components
@anchor{#binding-native-events-to-components}
There may be times when you want to listen directly to a native event on
the root element of a component. In these cases, you can use the
@code{.native} modifier for @code{v-on}:

@verbatim
<base-input v-on:focus.native="onFocus"></base-input>
@end verbatim

This can be useful sometimes, but it's not a good idea when you're
trying to listen on a very specific element, like an @code{<input>}. For
example, the @code{<base-input>} component above might refactor so that
the root element is actually a @code{<label>} element:

@verbatim
<label>
  {{ label }}
  <input
    v-bind="$attrs"
    v-bind:value="value"
    v-on:input="$emit('input', $event.target.value)"
  >
</label>
@end verbatim

In that case, the @code{.native} listener in the parent would silently
break. There would be no errors, but the @code{onFocus} handler wouldn't
be called when we expected it to.

To solve this problem, Vue provides a @code{$listeners} property
containing an object of listeners being used on the component. For
example:

@verbatim
{
  focus: function (event) { /* ... */ }
  input: function (value) { /* ... */ },
}
@end verbatim

Using the @code{$listeners} property, you can forward all event
listeners on the component to a specific child element with
@code{v-on="$listeners"}. For elements like @code{<input>}, that you
also want to work with @code{v-model}, it's often useful to create a new
computed property for listeners, like @code{inputListeners} below:

@verbatim
Vue.component('base-input', {
  inheritAttrs: false,
  props: ['label', 'value'],
  computed: {
    inputListeners: function () {
      var vm = this
      // `Object.assign` merges objects together to form a new object
      return Object.assign({},
        // We add all the listeners from the parent
        this.$listeners,
        // Then we can add custom listeners or override the
        // behavior of some listeners.
        {
          // This ensures that the component works with v-model
          input: function (event) {
            vm.$emit('input', event.target.value)
          }
        }
      )
    }
  },
  template: `
    <label>
      {{ label }}
      <input
        v-bind="$attrs"
        v-bind:value="value"
        v-on="inputListeners"
      >
    </label>
  `
})
@end verbatim

Now the @code{<base-input>} component is a @strong{fully transparent
wrapper}, meaning it can be used exactly like a normal @code{<input>}
element: all the same attributes and listeners will work, without the
@code{.native} modifier.

@node sync Modifier
@section @code{.sync} Modifier
@anchor{#sync-modifier}
@quotation
New in 2.3.0+
@end quotation
In some cases, we may need ``two-way binding'' for a prop.
Unfortunately, true two-way binding can create maintenance issues,
because child components can mutate the parent without the source of
that mutation being obvious in both the parent and the child.

That's why instead, we recommend emitting events in the pattern of
@code{update:myPropName}. For example, in a hypothetical component with
a @code{title} prop, we could communicate the intent of assigning a new
value with:

@verbatim
this.$emit('update:title', newTitle)
@end verbatim

Then the parent can listen to that event and update a local data
property, if it wants to. For example:

@verbatim
<text-document
  v-bind:title="doc.title"
  v-on:update:title="doc.title = $event"
></text-document>
@end verbatim

For convenience, we offer a shorthand for this pattern with the
@code{.sync} modifier:

@verbatim
<text-document v-bind:title.sync="doc.title"></text-document>
@end verbatim

Note that v-bind with the .sync modifier does not work with expressions
(e.g.@ v-bind:title.sync=``doc.title + `!''' is invalid). Instead, you
must only provide the name of the property you want to bind, similar to
v-model.
The @code{.sync} modifier can also be used with @code{v-bind} when using
an object to set multiple props at once:

@verbatim
<text-document v-bind.sync="doc"></text-document>
@end verbatim

This passes each property in the @code{doc} object (e.g.@ @code{title})
as an individual prop, then adds @code{v-on} update listeners for each
one.

Using v-bind.sync with a literal object, such as in v-bind.sync=``@{
title: doc.title @}'', will not work, because there are too many edge
cases to consider in parsing a complex expression like this.

@bye
