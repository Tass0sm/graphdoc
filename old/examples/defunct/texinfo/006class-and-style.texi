\input texinfo
@documentencoding UTF-8

@ifnottex
@paragraphindent 0
@end ifnottex
@titlepage
@title Class and Style Bindings
@end titlepage

@node Top
@top Class and Style Bindings

A common need for data binding is manipulating an element's class list
and its inline styles. Since they are both attributes, we can use
@code{v-bind} to handle them: we only need to calculate a final string
with our expressions. However, meddling with string concatenation is
annoying and error-prone. For this reason, Vue provides special
enhancements when @code{v-bind} is used with @code{class} and
@code{style}. In addition to strings, the expressions can also evaluate
to objects or arrays.

@node Binding HTML Classes
@section Binding HTML Classes
@anchor{#binding-html-classes}
Watch a free video lesson on Vue School

@menu
* Object Syntax::
* Array Syntax::
* With Components::
@end menu

@node Object Syntax
@subsection Object Syntax
@anchor{#object-syntax}
We can pass an object to @code{v-bind:class} to dynamically toggle
classes:

@verbatim
<div v-bind:class="{ active: isActive }"></div>
@end verbatim

The above syntax means the presence of the @code{active} class will be
determined by the
@uref{https://developer.mozilla.org/en-US/docs/Glossary/Truthy,truthiness}
of the data property @code{isActive}.

You can have multiple classes toggled by having more fields in the
object. In addition, the @code{v-bind:class} directive can also co-exist
with the plain @code{class} attribute. So given the following template:

@verbatim
<div
  class="static"
  v-bind:class="{ active: isActive, 'text-danger': hasError }"
></div>
@end verbatim

And the following data:

@verbatim
data: {
  isActive: true,
  hasError: false
}
@end verbatim

It will render:

@verbatim
<div class="static active"></div>
@end verbatim

When @code{isActive} or @code{hasError} changes, the class list will be
updated accordingly. For example, if @code{hasError} becomes
@code{true}, the class list will become
@code{"static active text-danger"}.

The bound object doesn't have to be inline:

@verbatim
<div v-bind:class="classObject"></div>
@end verbatim

@verbatim
data: {
  classObject: {
    active: true,
    'text-danger': false
  }
}
@end verbatim

This will render the same result. We can also bind to a
@uref{computed.html,computed property} that returns an object. This is a
common and powerful pattern:

@verbatim
<div v-bind:class="classObject"></div>
@end verbatim

@verbatim
data: {
  isActive: true,
  error: null
},
computed: {
  classObject: function () {
    return {
      active: this.isActive && !this.error,
      'text-danger': this.error && this.error.type === 'fatal'
    }
  }
}
@end verbatim

@node Array Syntax
@subsection Array Syntax
@anchor{#array-syntax}
We can pass an array to @code{v-bind:class} to apply a list of classes:

@verbatim
<div v-bind:class="[activeClass, errorClass]"></div>
@end verbatim

@verbatim
data: {
  activeClass: 'active',
  errorClass: 'text-danger'
}
@end verbatim

Which will render:

@verbatim
<div class="active text-danger"></div>
@end verbatim

If you would like to also toggle a class in the list conditionally, you
can do it with a ternary expression:

@verbatim
<div v-bind:class="[isActive ? activeClass : '', errorClass]"></div>
@end verbatim

This will always apply @code{errorClass}, but will only apply
@code{activeClass} when @code{isActive} is truthy.

However, this can be a bit verbose if you have multiple conditional
classes. That's why it's also possible to use the object syntax inside
array syntax:

@verbatim
<div v-bind:class="[{ active: isActive }, errorClass]"></div>
@end verbatim

@node With Components
@subsection With Components
@anchor{#with-components}
@quotation
This section assumes knowledge of @uref{components.html,Vue Components}.
Feel free to skip it and come back later.
@end quotation
When you use the @code{class} attribute on a custom component, those
classes will be added to the component's root element. Existing classes
on this element will not be overwritten.

For example, if you declare this component:

@verbatim
Vue.component('my-component', {
  template: '<p class="foo bar">Hi</p>'
})
@end verbatim

Then add some classes when using it:

@verbatim
<my-component class="baz boo"></my-component>
@end verbatim

The rendered HTML will be:

@verbatim
<p class="foo bar baz boo">Hi</p>
@end verbatim

The same is true for class bindings:

@verbatim
<my-component v-bind:class="{ active: isActive }"></my-component>
@end verbatim

When @code{isActive} is truthy, the rendered HTML will be:

@verbatim
<p class="foo bar active">Hi</p>
@end verbatim

@node Binding Inline Styles
@section Binding Inline Styles
@anchor{#binding-inline-styles}

@menu
* Object Syntax::
* Array Syntax::
* Auto-prefixing::
* Multiple Values::
@end menu

@node Object Syntax
@subsection Object Syntax
@anchor{#object-syntax-1}
The object syntax for @code{v-bind:style} is pretty straightforward - it
looks almost like CSS, except it's a JavaScript object. You can use
either camelCase or kebab-case (use quotes with kebab-case) for the CSS
property names:

@verbatim
<div v-bind:style="{ color: activeColor, fontSize: fontSize + 'px' }"></div>
@end verbatim

@verbatim
data: {
  activeColor: 'red',
  fontSize: 30
}
@end verbatim

It is often a good idea to bind to a style object directly so that the
template is cleaner:

@verbatim
<div v-bind:style="styleObject"></div>
@end verbatim

@verbatim
data: {
  styleObject: {
    color: 'red',
    fontSize: '13px'
  }
}
@end verbatim

Again, the object syntax is often used in conjunction with computed
properties that return objects.

@node Array Syntax
@subsection Array Syntax
@anchor{#array-syntax-1}
The array syntax for @code{v-bind:style} allows you to apply multiple
style objects to the same element:

@verbatim
<div v-bind:style="[baseStyles, overridingStyles]"></div>
@end verbatim

@node Auto-prefixing
@subsection Auto-prefixing
@anchor{#auto-prefixing}
When you use a CSS property that requires
@uref{https://developer.mozilla.org/en-US/docs/Glossary/Vendor_Prefix,vendor
prefixes} in @code{v-bind:style}, for example @code{transform}, Vue will
automatically detect and add appropriate prefixes to the applied styles.

@node Multiple Values
@subsection Multiple Values
@anchor{#multiple-values}
@quotation
2.3.0+
@end quotation
Starting in 2.3.0+ you can provide an array of multiple (prefixed)
values to a style property, for example:

@verbatim
<div v-bind:style="{ display: ['-webkit-box', '-ms-flexbox', 'flex'] }"></div>
@end verbatim

This will only render the last value in the array which the browser
supports. In this example, it will render @code{display: flex} for
browsers that support the unprefixed version of flexbox.

@bye
