\input texinfo
@documentencoding UTF-8

@ifnottex
@paragraphindent 0
@end ifnottex
@titlepage
@title Migration from Vue Router 0.7.x
@end titlepage

@node Top
@top Migration from Vue Router 0.7.x

@quotation
Only Vue Router 2 is compatible with Vue 2, so if you're updating Vue,
you'll have to update Vue Router as well. That's why we've included
details on the migration path here in the main docs. For a complete
guide on using the new Vue Router, see the
@uref{https://router.vuejs.org/en/,Vue Router docs}.
@end quotation

@node Router Initialization
@section Router Initialization
@anchor{#router-initialization}

@menu
* routerstart replaced::
@end menu

@node routerstart replaced
@subsection @code{router.start} replaced
@anchor{#router.start-replaced}
There is no longer a special API to initialize an app with Vue Router.
That means instead of:

@verbatim
router.start({
  template: '<router-view></router-view>'
}, '#app')
@end verbatim

You pass a router property to a Vue instance:

@verbatim
new Vue({
  el: '#app',
  router: router,
  template: '<router-view></router-view>'
})
@end verbatim

Or, if you're using the runtime-only build of Vue:

@verbatim
new Vue({
  el: '#app',
  router: router,
  render: h => h('router-view')
})
@end verbatim

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find examples of
router.start being called.
@{% endraw %@}

@node Route Definitions
@section Route Definitions
@anchor{#route-definitions}

@menu
* routermap replaced::
* routeron removed::
* routerbeforeEach changed::
* subRoutes renamed::
* routerredirect replaced::
* routeralias replaced::
* Arbitrary Route Properties replaced::
* [] Syntax for Arrays in Queries removed::
@end menu

@node routermap replaced
@subsection @code{router.map} replaced
@anchor{#router.map-replaced}
Routes are now defined as an array on a
@uref{https://router.vuejs.org/en/essentials/getting-started.html#javascript,@code{routes}
option} at router instantiation. So these routes for example:

@verbatim
router.map({
  '/foo': {
    component: Foo
  },
  '/bar': {
    component: Bar
  }
})
@end verbatim

Will instead be defined with:

@verbatim
var router = new VueRouter({
  routes: [
    { path: '/foo', component: Foo },
    { path: '/bar', component: Bar }
  ]
})
@end verbatim

The array syntax allows more predictable route matching, since iterating
over an object is not guaranteed to use the same property order across
browsers.

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find examples of router.map
being called.
@{% endraw %@}

@node routeron removed
@subsection @code{router.on} removed
@anchor{#router.on-removed}
If you need to programmatically generate routes when starting up your
app, you can do so by dynamically pushing definitions to a routes array.
For example:

@verbatim
// Normal base routes
var routes = [
  // ...
]

// Dynamically generated routes
marketingPages.forEach(function (page) {
  routes.push({
    path: '/marketing/' + page.slug
    component: {
      extends: MarketingComponent
      data: function () {
        return { page: page }
      }
    }
  })
})

var router = new Router({
  routes: routes
})
@end verbatim

If you need to add new routes after the router has been instantiated,
you can replace the router's matcher with a new one that includes the
route you'd like to add:

@verbatim
router.match = createMatcher(
  [{
    path: '/my/new/path',
    component: MyComponent
  }].concat(router.options.routes)
)
@end verbatim

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find examples of router.on
being called.
@{% endraw %@}

@node routerbeforeEach changed
@subsection @code{router.beforeEach} changed
@anchor{#router.beforeeach-changed}
@code{router.beforeEach} now works asynchronously and takes a
@code{next} function as its third argument.

@verbatim
router.beforeEach(function (transition) {
  if (transition.to.path === '/forbidden') {
    transition.abort()
  } else {
    transition.next()
  }
})
@end verbatim

@verbatim
router.beforeEach(function (to, from, next) {
  if (to.path === '/forbidden') {
    next(false)
  } else {
    next()
  }
})
@end verbatim

@node subRoutes renamed
@subsection @code{subRoutes} renamed
@anchor{#subroutes-renamed}
@uref{https://router.vuejs.org/en/essentials/nested-routes.html,Renamed
to @code{children}} for consistency within Vue and with other routing
libraries.

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find examples of the
subRoutes option.
@{% endraw %@}

@node routerredirect replaced
@subsection @code{router.redirect} replaced
@anchor{#router.redirect-replaced}
This is now an
@uref{https://router.vuejs.org/en/essentials/redirect-and-alias.html,option
on route definitions}. So for example, you will update:

@verbatim
router.redirect({
  '/tos': '/terms-of-service'
})
@end verbatim

to a definition like below in your @code{routes} configuration:

@verbatim
{
  path: '/tos',
  redirect: '/terms-of-service'
}
@end verbatim

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find examples of
router.redirect being called.
@{% endraw %@}

@node routeralias replaced
@subsection @code{router.alias} replaced
@anchor{#router.alias-replaced}
This is now an
@uref{https://router.vuejs.org/en/essentials/redirect-and-alias.html,option
on the definition for the route} you'd like to alias to. So for example,
you will update:

@verbatim
router.alias({
  '/manage': '/admin'
})
@end verbatim

to a definition like below in your @code{routes} configuration:

@verbatim
{
  path: '/admin',
  component: AdminPanel,
  alias: '/manage'
}
@end verbatim

If you need multiple aliases, you can also use an array syntax:

@{% codeblock lang:js %@} alias: [`/manage', `/administer',
`/administrate'] @{% endcodeblock %@}

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find examples of
router.alias being called.
@{% endraw %@}

@node Arbitrary Route Properties replaced
@subsection Arbitrary Route Properties replaced
@anchor{#arbitrary-route-properties-replaced}
Arbitrary route properties must now be scoped under the new meta
property, to avoid conflicts with future features. So for example, if
you had defined:

@verbatim
'/admin': {
  component: AdminPanel,
  requiresAuth: true
}
@end verbatim

Then you would now update it to:

@verbatim
{
  path: '/admin',
  component: AdminPanel,
  meta: {
    requiresAuth: true
  }
}
@end verbatim

Then when later accessing this property on a route, you will still go
through meta. For example:

@verbatim
if (route.meta.requiresAuth) {
  // ...
}
@end verbatim

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find examples of arbitrary
route properties not scoped under meta.
@{% endraw %@}

@node [] Syntax for Arrays in Queries removed
@subsection [] Syntax for Arrays in Queries removed
@anchor{#syntax-for-arrays-in-queries-removed}
When passing arrays to query parameters the QueryString syntax is no
longer @code{/foo?users[]=Tom&users[]=Jerry}, instead, the new syntax is
@code{/foo?users=Tom&users=Jerry}. Internally, @code{$route.query.users}
will still be an Array, but if there's only one parameter in the query:
@code{/foo?users=Tom}, when directly accessing this route, there's no
way for the router to know if we were expecting @code{users} to be an
Array. Because of this, consider adding a computed property and
replacing every reference of @code{$route.query.users} with it:

@verbatim
export default {
  // ...
  computed: {
    // users will always be an array
    users () {
      const users = this.$route.query.users
      return Array.isArray(users) ? users : [users]
    }
  }
}
@end verbatim

@node Route Matching
@section Route Matching
@anchor{#route-matching}
Route matching now uses
@uref{https://github.com/pillarjs/path-to-regexp,path-to-regexp} under
the hood, making it much more flexible than previously.

@menu
* One or More Named Parameters changed::
@end menu

@node One or More Named Parameters changed
@subsection One or More Named Parameters changed
@anchor{#one-or-more-named-parameters-changed}
The syntax has changed slightly, so @code{/category/*tags} for example,
should be updated to @code{/category/:tags+}.

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find examples of the
obsolete route syntax.
@{% endraw %@}

@node Links
@section Links
@anchor{#links}

@menu
* v-link replaced::
* v-link-active replaced::
@end menu

@node v-link replaced
@subsection @code{v-link} replaced
@anchor{#v-link-replaced}
The @code{v-link} directive has been replaced with a new
@uref{https://router.vuejs.org/en/api/router-link.html,@code{<router-link>}
component}, as this sort of job is now solely the responsibility of
components in Vue 2. That means whenever wherever you have a link like
this:

@verbatim
<a v-link="'/about'">About</a>
@end verbatim

You'll need to update it like this:

@verbatim
<router-link to="/about">About</router-link>
@end verbatim

Note that @code{target="_blank"} is not supported on
@code{<router-link>}, so if you need to open a link in a new tab, you
have to use @code{<a>} instead.

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find examples of the v-link
directive.
@{% endraw %@}

@node v-link-active replaced
@subsection @code{v-link-active} replaced
@anchor{#v-link-active-replaced}
The @code{v-link-active} directive has also been replaced by the
@code{tag} attribute on
@uref{https://router.vuejs.org/en/api/router-link.html,the
@code{<router-link>} component}. So for example, you'll update this:

@verbatim
<li v-link-active>
  <a v-link="'/about'">About</a>
</li>
@end verbatim

to this:

@verbatim
<router-link tag="li" to="/about">
  <a>About</a>
</router-link>
@end verbatim

The @code{<a>} will be the actual link (and will get the correct href),
but the active class will be applied to the outer @code{<li>}.

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find examples of the
v-link-active directive.
@{% endraw %@}

@node Programmatic Navigation
@section Programmatic Navigation
@anchor{#programmatic-navigation}

@menu
* routergo changed::
@end menu

@node routergo changed
@subsection @code{router.go} changed
@anchor{#router.go-changed}
For consistency with the
@uref{https://developer.mozilla.org/en-US/docs/Web/API/History_API,HTML5
History API}, @code{router.go} is now only used for
@uref{https://router.vuejs.org/en/essentials/navigation.html#routergon,back/forward
navigation}, while
@uref{https://router.vuejs.org/en/essentials/navigation.html#routerpushlocation,@code{router.push}}
is used to navigate to a specific page.

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find examples of router.go
being used where router.push should be used instead.
@{% endraw %@}

@node Router Options Modes
@section Router Options: Modes
@anchor{#router-options-modes}

@menu
* hashbang false removed::
* history true replaced::
* abstract true replaced::
@end menu

@node hashbang false removed
@subsection @code{hashbang: false} removed
@anchor{#hashbang-false-removed}
Hashbangs are no longer required for Google to crawl a URL, so they are
no longer the default (or even an option) for the hash strategy.

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find examples of the
hashbang: false option.
@{% endraw %@}

@node history true replaced
@subsection @code{history: true} replaced
@anchor{#history-true-replaced}
All routing mode options have been condensed into a single
@uref{https://router.vuejs.org/en/api/options.html#mode,@code{mode}
option}. Update:

@verbatim
var router = new VueRouter({
  history: 'true'
})
@end verbatim

to:

@verbatim
var router = new VueRouter({
  mode: 'history'
})
@end verbatim

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find examples of the
history: true option.
@{% endraw %@}

@node abstract true replaced
@subsection @code{abstract: true} replaced
@anchor{#abstract-true-replaced}
All routing mode options have been condensed into a single
@uref{https://router.vuejs.org/en/api/options.html#mode,@code{mode}
option}. Update:

@verbatim
var router = new VueRouter({
  abstract: 'true'
})
@end verbatim

to:

@verbatim
var router = new VueRouter({
  mode: 'abstract'
})
@end verbatim

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find examples of the
abstract: true option.
@{% endraw %@}

@node Route Options Misc
@section Route Options: Misc
@anchor{#route-options-misc}

@menu
* saveScrollPosition replaced::
* root renamed::
* transitionOnLoad removed::
* suppressTransitionError removed::
@end menu

@node saveScrollPosition replaced
@subsection @code{saveScrollPosition} replaced
@anchor{#savescrollposition-replaced}
This has been replaced with a
@uref{https://router.vuejs.org/en/advanced/scroll-behavior.html,@code{scrollBehavior}
option} that accepts a function, so that the scroll behavior is
completely customizable - even per route. This opens many new
possibilities, but to replicate the old behavior of:

@verbatim
saveScrollPosition: true
@end verbatim

You can replace it with:

@verbatim
scrollBehavior: function (to, from, savedPosition) {
  return savedPosition || { x: 0, y: 0 }
}
@end verbatim

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find examples of the
saveScrollPosition: true option.
@{% endraw %@}

@node root renamed
@subsection @code{root} renamed
@anchor{#root-renamed}
Renamed to @code{base} for consistency with
@uref{https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base,the
HTML @code{<base>} element}.

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find examples of the root
option.
@{% endraw %@}

@node transitionOnLoad removed
@subsection @code{transitionOnLoad} removed
@anchor{#transitiononload-removed}
This option is no longer necessary now that Vue's transition system has
explicit
@uref{transitions.html#Transitions-on-Initial-Render,@code{appear}
transition control}.

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find examples of the
transitionOnLoad: true option.
@{% endraw %@}

@node suppressTransitionError removed
@subsection @code{suppressTransitionError} removed
@anchor{#suppresstransitionerror-removed}
Removed due to hooks simplification. If you really must suppress
transition errors, you can use
@uref{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/try...catch,@code{try}@dots{}@code{catch}}
instead.

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find examples of the
suppressTransitionError: true option.
@{% endraw %@}

@node Route Hooks
@section Route Hooks
@anchor{#route-hooks}

@menu
* activate replaced::
* canActivate replaced::
* deactivate removed::
* canDeactivate replaced::
* canReuse false removed::
* data replaced::
* $loadingRouteData removed::
@end menu

@node activate replaced
@subsection @code{activate} replaced
@anchor{#activate-replaced}
Use
@uref{https://router.vuejs.org/en/advanced/navigation-guards.html#incomponent-guards,@code{beforeRouteEnter}}
in the component instead.

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find examples of the
activate hook.
@{% endraw %@}

@node canActivate replaced
@subsection @code{canActivate} replaced
@anchor{#canactivate-replaced}
Use
@uref{https://router.vuejs.org/en/advanced/navigation-guards.html#perroute-guard,@code{beforeEnter}}
in the route instead.

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find examples of the
canActivate hook.
@{% endraw %@}

@node deactivate removed
@subsection @code{deactivate} removed
@anchor{#deactivate-removed}
Use the component's @uref{../api/#beforeDestroy,@code{beforeDestroy}} or
@uref{../api/#destroyed,@code{destroyed}} hooks instead.

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find examples of the
deactivate hook.
@{% endraw %@}

@node canDeactivate replaced
@subsection @code{canDeactivate} replaced
@anchor{#candeactivate-replaced}
Use
@uref{https://router.vuejs.org/en/advanced/navigation-guards.html#incomponent-guards,@code{beforeRouteLeave}}
in the component instead.

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find examples of the
canDeactivate hook.
@{% endraw %@}

@node canReuse false removed
@subsection @code{canReuse: false} removed
@anchor{#canreuse-false-removed}
There's no longer a use case for this in the new Vue Router.

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find examples of the
canReuse: false option.
@{% endraw %@}

@node data replaced
@subsection @code{data} replaced
@anchor{#data-replaced}
The @code{$route} property is now reactive, so you can use a watcher to
react to route changes, like this:

@verbatim
watch: {
  '$route': 'fetchData'
},
methods: {
  fetchData: function () {
    // ...
  }
}
@end verbatim

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find examples of the data
hook.
@{% endraw %@}

@node $loadingRouteData removed
@subsection @code{$loadingRouteData} removed
@anchor{#loadingroutedata-removed}
Define your own property (e.g.@ @code{isLoading}), then update the
loading state in a watcher on the route. For example, if fetching data
with @uref{https://github.com/mzabriskie/axios,axios}:

@verbatim
data: function () {
  return {
    posts: [],
    isLoading: false,
    fetchError: null
  }
},
watch: {
  '$route': function () {
    var self = this
    self.isLoading = true
    self.fetchData().then(function () {
      self.isLoading = false
    })
  }
},
methods: {
  fetchData: function () {
    var self = this
    return axios.get('/api/posts')
      .then(function (response) {
        self.posts = response.data.posts
      })
      .catch(function (error) {
        self.fetchError = error
      })
  }
}
@end verbatim

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find examples of the
$loadingRouteData meta property.
@{% endraw %@}

@bye
