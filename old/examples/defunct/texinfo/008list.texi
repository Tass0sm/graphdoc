\input texinfo
@documentencoding UTF-8

@ifnottex
@paragraphindent 0
@end ifnottex
@titlepage
@title List Rendering
@end titlepage

@node Top
@top List Rendering

Learn how to render list with a free Vue School lesson

@node Mapping an Array to Elements with v-for
@section Mapping an Array to Elements with @code{v-for}
@anchor{#mapping-an-array-to-elements-with-v-for}
We can use the @code{v-for} directive to render a list of items based on
an array. The @code{v-for} directive requires a special syntax in the
form of @code{item in items}, where @code{items} is the source data
array and @code{item} is an @strong{alias} for the array element being
iterated on:

@verbatim
<ul id="example-1">
  <li v-for="item in items" :key="item.message">
    {{ item.message }}
  </li>
</ul>
@end verbatim

@verbatim
var example1 = new Vue({
  el: '#example-1',
  data: {
    items: [
      { message: 'Foo' },
      { message: 'Bar' }
    ]
  }
})
@end verbatim

Result:

@{% raw %@}
@{% endraw %@}

Inside @code{v-for} blocks we have full access to parent scope
properties. @code{v-for} also supports an optional second argument for
the index of the current item.

@verbatim
<ul id="example-2">
  <li v-for="(item, index) in items">
    {{ parentMessage }} - {{ index }} - {{ item.message }}
  </li>
</ul>
@end verbatim

@verbatim
var example2 = new Vue({
  el: '#example-2',
  data: {
    parentMessage: 'Parent',
    items: [
      { message: 'Foo' },
      { message: 'Bar' }
    ]
  }
})
@end verbatim

Result:

@{% raw%@}
@{@{ parentMessage @}@} - @{@{ index @}@} - @{@{ item.message @}@}
@{% endraw %@}

You can also use @code{of} as the delimiter instead of @code{in}, so
that it is closer to JavaScript's syntax for iterators:

@verbatim
<div v-for="item of items"></div>
@end verbatim

@node v-for with an Object
@section @code{v-for} with an Object
@anchor{#v-for-with-an-object}
You can also use @code{v-for} to iterate through the properties of an
object.

@verbatim
<ul id="v-for-object" class="demo">
  <li v-for="value in object">
    {{ value }}
  </li>
</ul>
@end verbatim

@verbatim
new Vue({
  el: '#v-for-object',
  data: {
    object: {
      title: 'How to do lists in Vue',
      author: 'Jane Doe',
      publishedAt: '2016-04-10'
    }
  }
})
@end verbatim

Result:

@{% raw %@}
@{@{ value @}@}
@{% endraw %@}

You can also provide a second argument for the property's name (a.k.a.
key):

@verbatim
<div v-for="(value, name) in object">
  {{ name }}: {{ value }}
</div>
@end verbatim

@{% raw %@}

@verbatim
{{ name }}: {{ value }}
@end verbatim

@{% endraw %@}

And another for the index:

@verbatim
<div v-for="(value, name, index) in object">
  {{ index }}. {{ name }}: {{ value }}
</div>
@end verbatim

@{% raw %@}

@verbatim
{{ index }}. {{ name }}: {{ value }}
@end verbatim

@{% endraw %@}

When iterating over an object, the order is based on the enumeration
order of @code{Object.keys()}, which is @strong{not} guaranteed to be
consistent across JavaScript engine implementations.

@node Maintaining State
@section Maintaining State
@anchor{#maintaining-state}
When Vue is updating a list of elements rendered with @code{v-for}, by
default it uses an ``in-place patch'' strategy. If the order of the data
items has changed, instead of moving the DOM elements to match the order
of the items, Vue will patch each element in-place and make sure it
reflects what should be rendered at that particular index. This is
similar to the behavior of @code{track-by="$index"} in Vue 1.x.

This default mode is efficient, but @strong{only suitable when your list
render output does not rely on child component state or temporary DOM
state (e.g.@ form input values)}.

To give Vue a hint so that it can track each node's identity, and thus
reuse and reorder existing elements, you need to provide a unique
@code{key} attribute for each item:

@verbatim
<div v-for="item in items" v-bind:key="item.id">
  <!-- content -->
</div>
@end verbatim

It is recommended to provide a @code{key} attribute with @code{v-for}
whenever possible, unless the iterated DOM content is simple, or you are
intentionally relying on the default behavior for performance gains.

Since it's a generic mechanism for Vue to identify nodes, the @code{key}
also has other uses that are not specifically tied to @code{v-for}, as
we will see later in the guide.

Don't use non-primitive values like objects and arrays as @code{v-for}
keys. Use string or numeric values instead.
For detailed usage of the @code{key} attribute, please see the
@uref{https://vuejs.org/v2/api/#key,@code{key} API documentation}.

@node Array Change Detection
@section Array Change Detection
@anchor{#array-change-detection}

@menu
* Mutation Methods::
* Replacing an Array::
* Caveats::
@end menu

@node Mutation Methods
@subsection Mutation Methods
@anchor{#mutation-methods}
Vue wraps an observed array's mutation methods so they will also trigger
view updates. The wrapped methods are:

@itemize
@item
@code{push()}
@item
@code{pop()}
@item
@code{shift()}
@item
@code{unshift()}
@item
@code{splice()}
@item
@code{sort()}
@item
@code{reverse()}
@end itemize

You can open the console and play with the previous examples'
@code{items} array by calling their mutation methods. For example:
@code{example1.items.push(@{ message: 'Baz' @})}.

@node Replacing an Array
@subsection Replacing an Array
@anchor{#replacing-an-array}
Mutation methods, as the name suggests, mutate the original array they
are called on. In comparison, there are also non-mutating methods,
e.g.@ @code{filter()}, @code{concat()} and @code{slice()}, which do not
mutate the original array but @strong{always return a new array}. When
working with non-mutating methods, you can replace the old array with
the new one:

@verbatim
example1.items = example1.items.filter(function (item) {
  return item.message.match(/Foo/)
})
@end verbatim

You might think this will cause Vue to throw away the existing DOM and
re-render the entire list - luckily, that is not the case. Vue
implements some smart heuristics to maximize DOM element reuse, so
replacing an array with another array containing overlapping objects is
a very efficient operation.

@node Caveats
@subsection Caveats
@anchor{#caveats}
Due to limitations in JavaScript, there are types of changes that Vue
@strong{cannot detect} with arrays and objects. These are discussed in
the @uref{reactivity.html#Change-Detection-Caveats,reactivity} section.

@node Displaying Filtered/Sorted Results
@section Displaying Filtered/Sorted Results
@anchor{#displaying-filteredsorted-results}
Sometimes we want to display a filtered or sorted version of an array
without actually mutating or resetting the original data. In this case,
you can create a computed property that returns the filtered or sorted
array.

For example:

@verbatim
<li v-for="n in evenNumbers">{{ n }}</li>
@end verbatim

@verbatim
data: {
  numbers: [ 1, 2, 3, 4, 5 ]
},
computed: {
  evenNumbers: function () {
    return this.numbers.filter(function (number) {
      return number % 2 === 0
    })
  }
}
@end verbatim

In situations where computed properties are not feasible (e.g.@ inside
nested @code{v-for} loops), you can use a method:

@verbatim
<ul v-for="set in sets">
  <li v-for="n in even(set)">{{ n }}</li>
</ul>
@end verbatim

@verbatim
data: {
  sets: [[ 1, 2, 3, 4, 5 ], [6, 7, 8, 9, 10]]
},
methods: {
  even: function (numbers) {
    return numbers.filter(function (number) {
      return number % 2 === 0
    })
  }
}
@end verbatim

@node v-for with a Range
@section @code{v-for} with a Range
@anchor{#v-for-with-a-range}
@code{v-for} can also take an integer. In this case it will repeat the
template that many times.

@verbatim
<div>
  <span v-for="n in 10">{{ n }} </span>
</div>
@end verbatim

Result:

@{% raw %@}
@{@{ n @}@}
@{% endraw %@}

@node v-for on a <template>
@section @code{v-for} on a @code{<template>}
@anchor{#v-for-on-a-template}
Similar to template @code{v-if}, you can also use a @code{<template>}
tag with @code{v-for} to render a block of multiple elements. For
example:

@verbatim
<ul>
  <template v-for="item in items">
    <li>{{ item.msg }}</li>
    <li class="divider" role="presentation"></li>
  </template>
</ul>
@end verbatim

@node v-for with v-if
@section @code{v-for} with @code{v-if}
@anchor{#v-for-with-v-if}
Note that it's @strong{not} recommended to use @code{v-if} and
@code{v-for} together. Refer to
@uref{/v2/style-guide/#Avoid-v-if-with-v-for-essential,style guide} for
details.
When they exist on the same node, @code{v-for} has a higher priority
than @code{v-if}. That means the @code{v-if} will be run on each
iteration of the loop separately. This can be useful when you want to
render nodes for only @emph{some} items, like below:

@verbatim
<li v-for="todo in todos" v-if="!todo.isComplete">
  {{ todo }}
</li>
@end verbatim

The above only renders the todos that are not complete.

If instead, your intent is to conditionally skip execution of the loop,
you can place the @code{v-if} on a wrapper element (or
@uref{conditional.html#Conditional-Groups-with-v-if-on-lt-template-gt,@code{<template>}}).
For example:

@verbatim
<ul v-if="todos.length">
  <li v-for="todo in todos">
    {{ todo }}
  </li>
</ul>
<p v-else>No todos left!</p>
@end verbatim

@node v-for with a Component
@section @code{v-for} with a Component
@anchor{#v-for-with-a-component}
@quotation
This section assumes knowledge of @uref{components.html,Components}.
Feel free to skip it and come back later.
@end quotation
You can directly use @code{v-for} on a custom component, like any normal
element:

@verbatim
<my-component v-for="item in items" :key="item.id"></my-component>
@end verbatim

@quotation
In 2.2.0+, when using @code{v-for} with a component, a
@uref{list.html#key,@code{key}} is now required.
@end quotation
However, this won't automatically pass any data to the component,
because components have isolated scopes of their own. In order to pass
the iterated data into the component, we should also use props:

@verbatim
<my-component
  v-for="(item, index) in items"
  v-bind:item="item"
  v-bind:index="index"
  v-bind:key="item.id"
></my-component>
@end verbatim

The reason for not automatically injecting @code{item} into the
component is because that makes the component tightly coupled to how
@code{v-for} works. Being explicit about where its data comes from makes
the component reusable in other situations.

Here's a complete example of a simple todo list:

@verbatim
<div id="todo-list-example">
  <form v-on:submit.prevent="addNewTodo">
    <label for="new-todo">Add a todo</label>
    <input
      v-model="newTodoText"
      id="new-todo"
      placeholder="E.g. Feed the cat"
    >
    <button>Add</button>
  </form>
  <ul>
    <li
      is="todo-item"
      v-for="(todo, index) in todos"
      v-bind:key="todo.id"
      v-bind:title="todo.title"
      v-on:remove="todos.splice(index, 1)"
    ></li>
  </ul>
</div>
@end verbatim

Note the @code{is="todo-item"} attribute. This is necessary in DOM
templates, because only an @code{<li>} element is valid inside a
@code{<ul>}. It does the same thing as @code{<todo-item>}, but works
around a potential browser parsing error. See
@uref{components.html#DOM-Template-Parsing-Caveats,DOM Template Parsing
Caveats} to learn more.

@verbatim
Vue.component('todo-item', {
  template: '\
    <li>\
      {{ title }}\
      <button v-on:click="$emit(\'remove\')">Remove</button>\
    </li>\
  ',
  props: ['title']
})

new Vue({
  el: '#todo-list-example',
  data: {
    newTodoText: '',
    todos: [
      {
        id: 1,
        title: 'Do the dishes',
      },
      {
        id: 2,
        title: 'Take out the trash',
      },
      {
        id: 3,
        title: 'Mow the lawn'
      }
    ],
    nextTodoId: 4
  },
  methods: {
    addNewTodo: function () {
      this.todos.push({
        id: this.nextTodoId++,
        title: this.newTodoText
      })
      this.newTodoText = ''
    }
  }
})
@end verbatim

@{% raw %@}
<form v-on:submit.prevent=``addNewTodo''> Add a todo Add
@{% endraw %@}

@bye
