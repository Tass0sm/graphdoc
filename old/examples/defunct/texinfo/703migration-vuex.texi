\input texinfo
@documentencoding UTF-8

@ifnottex
@paragraphindent 0
@end ifnottex
@titlepage
@title Migration from Vuex 0.6.x to 1.0
@end titlepage

@node Top
@top Migration from Vuex 0.6.x to 1.0

@quotation
Vuex 2.0 is released, but this guide only covers the migration to 1.0?
Is that a typo? Also, it looks like Vuex 1.0 and 2.0 were released
simultaneously. What's going on? Which one should I use and what's
compatible with Vue 2.0?
@end quotation
Both Vuex 1.0 and 2.0:

@itemize
@item
fully support both Vue 1.0 and 2.0
@item
will be maintained for the foreseeable future
@end itemize

They have slightly different target users however.

@strong{Vuex 2.0} is a radical redesign and simplification of the API,
for those who are starting new projects or want to be on the cutting
edge of client-side state management. @strong{It is not covered by this
migration guide}, so you should check out
@uref{https://vuex.vuejs.org/en/index.html,the Vuex 2.0 docs} if you'd
like to learn more about it.

@strong{Vuex 1.0} is mostly backwards-compatible, so requires very few
changes to upgrade. It is recommended for those with large existing
codebases or who want the smoothest possible upgrade path to Vue 2.0.
This guide is dedicated to facilitating that process, but only includes
migration notes. For the complete usage guide, see
@uref{https://github.com/vuejs/vuex/tree/1.0/docs/en,the Vuex 1.0 docs}.

@node storewatch with String Property Path replaced
@section @code{store.watch} with String Property Path replaced
@anchor{#store.watch-with-string-property-path-replaced}
@code{store.watch} now only accept functions. So for example, you would
have to replace:

@verbatim
store.watch('user.notifications', callback)
@end verbatim

with:

@verbatim
store.watch(
  // When the returned result changes...
  function (state) {
    return state.user.notifications
  },
  // Run this callback
  callback
)
@end verbatim

This gives you more complete control over the reactive properties you'd
like to watch.

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find examples of
store.watch with a string as the first argument.
@{% endraw %@}

@node Store's Event Emitter removed
@section Store's Event Emitter removed
@anchor{#stores-event-emitter-removed}
The store instance no longer exposes the event emitter interface
(@code{on}, @code{off}, @code{emit}). If you were previously using the
store as a global event bus,
@uref{migration.html#dispatch-and-broadcast-removed,see this section}
for migration instructions.

Instead of using this interface to watch events emitted by the store
itself (e.g.@ @code{store.on('mutation', callback)}), a new method
@code{store.subscribe} is introduced. Typical usage inside a plugin
would be:

@verbatim
var myPlugin = store => {
  store.subscribe(function (mutation, state) {
    // Do something...
  })
}
@end verbatim

See example
@uref{https://github.com/vuejs/vuex/blob/1.0/docs/en/plugins.md,the
plugins docs} for more info.

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find examples of store.on,
store.off, and store.emit.
@{% endraw %@}

@node Middlewares replaced
@section Middlewares replaced
@anchor{#middlewares-replaced}
Middlewares are replaced by plugins. A plugin is a function that
receives the store as the only argument, and can listen to the mutation
event on the store:

@verbatim
const myPlugins = store => {
  store.subscribe('mutation', (mutation, state) => {
    // Do something...
  })
}
@end verbatim

For more details, see
@uref{https://github.com/vuejs/vuex/blob/1.0/docs/en/plugins.md,the
plugins docs}.

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find examples of the
middlewares option on a store.
@{% endraw %@}

@bye
