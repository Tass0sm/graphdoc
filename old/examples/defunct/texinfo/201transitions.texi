\input texinfo
@documentencoding UTF-8

@ifnottex
@paragraphindent 0
@end ifnottex
@titlepage
@title Enter/Leave & List Transitions
@end titlepage

@node Top
@top Enter/Leave & List Transitions

@node Overview
@section Overview
@anchor{#overview}
Vue provides a variety of ways to apply transition effects when items
are inserted, updated, or removed from the DOM. This includes tools to:

@itemize
@item
automatically apply classes for CSS transitions and animations
@item
integrate 3rd-party CSS animation libraries, such as Animate.css
@item
use JavaScript to directly manipulate the DOM during transition hooks
@item
integrate 3rd-party JavaScript animation libraries, such as Velocity.js
@end itemize

On this page, we'll only cover entering, leaving, and list transitions,
but you can see the next section for
@uref{transitioning-state.html,managing state transitions}.

@node Transitioning Single Elements/Components
@section Transitioning Single Elements/Components
@anchor{#transitioning-single-elementscomponents}
Vue provides a @code{transition} wrapper component, allowing you to add
entering/leaving transitions for any element or component in the
following contexts:

@itemize
@item
Conditional rendering (using @code{v-if})
@item
Conditional display (using @code{v-show})
@item
Dynamic components
@item
Component root nodes
@end itemize

This is what an example looks like in action:

@verbatim
<div id="demo">
  <button v-on:click="show = !show">
    Toggle
  </button>
  <transition name="fade">
    <p v-if="show">hello</p>
  </transition>
</div>
@end verbatim

@verbatim
new Vue({
  el: '#demo',
  data: {
    show: true
  }
})
@end verbatim

@verbatim
.fade-enter-active, .fade-leave-active {
  transition: opacity .5s;
}
.fade-enter, .fade-leave-to /* .fade-leave-active below version 2.1.8 */ {
  opacity: 0;
}
@end verbatim

@{% raw %@}
Toggle
hello
@{% endraw %@}

When an element wrapped in a @code{transition} component is inserted or
removed, this is what happens:

@enumerate 
@item
Vue will automatically sniff whether the target element has CSS
transitions or animations applied. If it does, CSS transition classes
will be added/removed at appropriate timings.

@item
If the transition component provided @ref{#JavaScript-Hooks,JavaScript
hooks}, these hooks will be called at appropriate timings.

@item
If no CSS transitions/animations are detected and no JavaScript hooks
are provided, the DOM operations for insertion and/or removal will be
executed immediately on next frame (Note: this is a browser animation
frame, different from Vue's concept of @code{nextTick}).

@end enumerate

@menu
* Transition Classes::
* CSS Transitions::
* CSS Animations::
* Custom Transition Classes::
* Using Transitions and Animations Together::
* Explicit Transition Durations::
* JavaScript Hooks::
@end menu

@node Transition Classes
@subsection Transition Classes
@anchor{#transition-classes}
There are six classes applied for enter/leave transitions.

@enumerate 
@item
@code{v-enter}: Starting state for enter. Added before element is
inserted, removed one frame after element is inserted.

@item
@code{v-enter-active}: Active state for enter. Applied during the entire
entering phase. Added before element is inserted, removed when
transition/animation finishes. This class can be used to define the
duration, delay and easing curve for the entering transition.

@item
@code{v-enter-to}: @strong{Only available in versions 2.1.8+.} Ending
state for enter. Added one frame after element is inserted (at the same
time @code{v-enter} is removed), removed when transition/animation
finishes.

@item
@code{v-leave}: Starting state for leave. Added immediately when a
leaving transition is triggered, removed after one frame.

@item
@code{v-leave-active}: Active state for leave. Applied during the entire
leaving phase. Added immediately when leave transition is triggered,
removed when the transition/animation finishes. This class can be used
to define the duration, delay and easing curve for the leaving
transition.

@item
@code{v-leave-to}: @strong{Only available in versions 2.1.8+.} Ending
state for leave. Added one frame after a leaving transition is triggered
(at the same time @code{v-leave} is removed), removed when the
transition/animation finishes.

@end enumerate

@float
@image{/images/transition,,,Transition Diagram,png}
@caption{Transition Diagram}
@end float

Each of these classes will be prefixed with the name of the transition.
Here the @code{v-} prefix is the default when you use a
@code{<transition>} element with no name. If you use
@code{<transition name="my-transition">} for example, then the
@code{v-enter} class would instead be @code{my-transition-enter}.

@code{v-enter-active} and @code{v-leave-active} give you the ability to
specify different easing curves for enter/leave transitions, which
you'll see an example of in the following section.

@node CSS Transitions
@subsection CSS Transitions
@anchor{#css-transitions}
One of the most common transition types uses CSS transitions. Here's an
example:

@verbatim
<div id="example-1">
  <button @click="show = !show">
    Toggle render
  </button>
  <transition name="slide-fade">
    <p v-if="show">hello</p>
  </transition>
</div>
@end verbatim

@verbatim
new Vue({
  el: '#example-1',
  data: {
    show: true
  }
})
@end verbatim

@verbatim
/* Enter and leave animations can use different */
/* durations and timing functions.              */
.slide-fade-enter-active {
  transition: all .3s ease;
}
.slide-fade-leave-active {
  transition: all .8s cubic-bezier(1.0, 0.5, 0.8, 1.0);
}
.slide-fade-enter, .slide-fade-leave-to
/* .slide-fade-leave-active below version 2.1.8 */ {
  transform: translateX(10px);
  opacity: 0;
}
@end verbatim

@{% raw %@}
<button @@click=``show = !show''> Toggle render
hello
@{% endraw %@}

@node CSS Animations
@subsection CSS Animations
@anchor{#css-animations}
CSS animations are applied in the same way as CSS transitions, the
difference being that @code{v-enter} is not removed immediately after
the element is inserted, but on an @code{animationend} event.

Here's an example, omitting prefixed CSS rules for the sake of brevity:

@verbatim
<div id="example-2">
  <button @click="show = !show">Toggle show</button>
  <transition name="bounce">
    <p v-if="show">Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris facilisis enim libero, at lacinia diam fermentum id. Pellentesque habitant morbi tristique senectus et netus.</p>
  </transition>
</div>
@end verbatim

@verbatim
new Vue({
  el: '#example-2',
  data: {
    show: true
  }
})
@end verbatim

@verbatim
.bounce-enter-active {
  animation: bounce-in .5s;
}
.bounce-leave-active {
  animation: bounce-in .5s reverse;
}
@keyframes bounce-in {
  0% {
    transform: scale(0);
  }
  50% {
    transform: scale(1.5);
  }
  100% {
    transform: scale(1);
  }
}
@end verbatim

@{% raw %@}
<button @@click=``show = !show''>Toggle show
Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris
facilisis enim libero, at lacinia diam fermentum id. Pellentesque
habitant morbi tristique senectus et netus.
@{% endraw %@}

@node Custom Transition Classes
@subsection Custom Transition Classes
@anchor{#custom-transition-classes}
You can also specify custom transition classes by providing the
following attributes:

@itemize
@item
@code{enter-class}
@item
@code{enter-active-class}
@item
@code{enter-to-class} (2.1.8+)
@item
@code{leave-class}
@item
@code{leave-active-class}
@item
@code{leave-to-class} (2.1.8+)
@end itemize

These will override the conventional class names. This is especially
useful when you want to combine Vue's transition system with an existing
CSS animation library, such as
@uref{https://daneden.github.io/animate.css/,Animate.css}.

Here's an example:

@verbatim
<link href="https://cdn.jsdelivr.net/npm/animate.css@3.5.1" rel="stylesheet" type="text/css">

<div id="example-3">
  <button @click="show = !show">
    Toggle render
  </button>
  <transition
    name="custom-classes-transition"
    enter-active-class="animated tada"
    leave-active-class="animated bounceOutRight"
  >
    <p v-if="show">hello</p>
  </transition>
</div>
@end verbatim

@verbatim
new Vue({
  el: '#example-3',
  data: {
    show: true
  }
})
@end verbatim

@{% raw %@}
<button @@click=``show = !show''> Toggle render
hello
@{% endraw %@}

@node Using Transitions and Animations Together
@subsection Using Transitions and Animations Together
@anchor{#using-transitions-and-animations-together}
Vue needs to attach event listeners in order to know when a transition
has ended. It can either be @code{transitionend} or @code{animationend},
depending on the type of CSS rules applied. If you are only using one or
the other, Vue can automatically detect the correct type.

However, in some cases you may want to have both on the same element,
for example having a CSS animation triggered by Vue, along with a CSS
transition effect on hover. In these cases, you will have to explicitly
declare the type you want Vue to care about in a @code{type} attribute,
with a value of either @code{animation} or @code{transition}.

@node Explicit Transition Durations
@subsection Explicit Transition Durations
@anchor{#explicit-transition-durations}
@quotation
New in 2.2.0+
@end quotation
In most cases, Vue can automatically figure out when the transition has
finished. By default, Vue waits for the first @code{transitionend} or
@code{animationend} event on the root transition element. However, this
may not always be desired - for example, we may have a choreographed
transition sequence where some nested inner elements have a delayed
transition or a longer transition duration than the root transition
element.

In such cases you can specify an explicit transition duration (in
milliseconds) using the @code{duration} prop on the @code{<transition>}
component:

@verbatim
<transition :duration="1000">...</transition>
@end verbatim

You can also specify separate values for enter and leave durations:

@verbatim
<transition :duration="{ enter: 500, leave: 800 }">...</transition>
@end verbatim

@node JavaScript Hooks
@subsection JavaScript Hooks
@anchor{#javascript-hooks}
You can also define JavaScript hooks in attributes:

@verbatim
<transition
  v-on:before-enter="beforeEnter"
  v-on:enter="enter"
  v-on:after-enter="afterEnter"
  v-on:enter-cancelled="enterCancelled"

  v-on:before-leave="beforeLeave"
  v-on:leave="leave"
  v-on:after-leave="afterLeave"
  v-on:leave-cancelled="leaveCancelled"
>
  <!-- ... -->
</transition>
@end verbatim

@verbatim
// ...
methods: {
  // --------
  // ENTERING
  // --------

  beforeEnter: function (el) {
    // ...
  },
  // the done callback is optional when
  // used in combination with CSS
  enter: function (el, done) {
    // ...
    done()
  },
  afterEnter: function (el) {
    // ...
  },
  enterCancelled: function (el) {
    // ...
  },

  // --------
  // LEAVING
  // --------

  beforeLeave: function (el) {
    // ...
  },
  // the done callback is optional when
  // used in combination with CSS
  leave: function (el, done) {
    // ...
    done()
  },
  afterLeave: function (el) {
    // ...
  },
  // leaveCancelled only available with v-show
  leaveCancelled: function (el) {
    // ...
  }
}
@end verbatim

These hooks can be used in combination with CSS transitions/animations
or on their own.

When using JavaScript-only transitions, @strong{the @code{done}
callbacks are required for the @code{enter} and @code{leave} hooks}.
Otherwise, the hooks will be called synchronously and the transition
will finish immediately.
It's also a good idea to explicitly add @code{v-bind:css="false"} for
JavaScript-only transitions so that Vue can skip the CSS detection. This
also prevents CSS rules from accidentally interfering with the
transition.
Now let's dive into an example. Here's a JavaScript transition using
Velocity.js:

@verbatim
<!--
Velocity works very much like jQuery.animate and is
a great option for JavaScript animations
-->
<script src="https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js"></script>

<div id="example-4">
  <button @click="show = !show">
    Toggle
  </button>
  <transition
    v-on:before-enter="beforeEnter"
    v-on:enter="enter"
    v-on:leave="leave"
    v-bind:css="false"
  >
    <p v-if="show">
      Demo
    </p>
  </transition>
</div>
@end verbatim

@verbatim
new Vue({
  el: '#example-4',
  data: {
    show: false
  },
  methods: {
    beforeEnter: function (el) {
      el.style.opacity = 0
      el.style.transformOrigin = 'left'
    },
    enter: function (el, done) {
      Velocity(el, { opacity: 1, fontSize: '1.4em' }, { duration: 300 })
      Velocity(el, { fontSize: '1em' }, { complete: done })
    },
    leave: function (el, done) {
      Velocity(el, { translateX: '15px', rotateZ: '50deg' }, { duration: 600 })
      Velocity(el, { rotateZ: '100deg' }, { loop: 2 })
      Velocity(el, {
        rotateZ: '45deg',
        translateY: '30px',
        translateX: '30px',
        opacity: 0
      }, { complete: done })
    }
  }
})
@end verbatim

@{% raw %@}
<button @@click=``show = !show''> Toggle
Demo
@{% endraw %@}

@node Transitions on Initial Render
@section Transitions on Initial Render
@anchor{#transitions-on-initial-render}
If you also want to apply a transition on the initial render of a node,
you can add the @code{appear} attribute:

@verbatim
<transition appear>
  <!-- ... -->
</transition>
@end verbatim

By default, this will use the transitions specified for entering and
leaving. If you'd like however, you can also specify custom CSS classes:

@verbatim
<transition
  appear
  appear-class="custom-appear-class"
  appear-to-class="custom-appear-to-class" (2.1.8+)
  appear-active-class="custom-appear-active-class"
>
  <!-- ... -->
</transition>
@end verbatim

and custom JavaScript hooks:

@verbatim
<transition
  appear
  v-on:before-appear="customBeforeAppearHook"
  v-on:appear="customAppearHook"
  v-on:after-appear="customAfterAppearHook"
  v-on:appear-cancelled="customAppearCancelledHook"
>
  <!-- ... -->
</transition>
@end verbatim

In the example above, either @code{appear} attribute or
@code{v-on:appear} hook will cause an appear transition.

@node Transitioning Between Elements
@section Transitioning Between Elements
@anchor{#transitioning-between-elements}
We discuss @ref{#Transitioning-Between-Components,transitioning between
components} later, but you can also transition between raw elements
using @code{v-if}/@code{v-else}. One of the most common two-element
transitions is between a list container and a message describing an
empty list:

@verbatim
<transition>
  <table v-if="items.length > 0">
    <!-- ... -->
  </table>
  <p v-else>Sorry, no items found.</p>
</transition>
@end verbatim

This works well, but there's one caveat to be aware of:

When toggling between elements that have @strong{the same tag name}, you
must tell Vue that they are distinct elements by giving them unique
@code{key} attributes. Otherwise, Vue's compiler will only replace the
content of the element for efficiency. Even when technically unnecessary
though, @strong{it's considered good practice to always key multiple
items within a @code{<transition>} component.}
For example:

@verbatim
<transition>
  <button v-if="isEditing" key="save">
    Save
  </button>
  <button v-else key="edit">
    Edit
  </button>
</transition>
@end verbatim

In these cases, you can also use the @code{key} attribute to transition
between different states of the same element. Instead of using
@code{v-if} and @code{v-else}, the above example could be rewritten as:

@verbatim
<transition>
  <button v-bind:key="isEditing">
    {{ isEditing ? 'Save' : 'Edit' }}
  </button>
</transition>
@end verbatim

It's actually possible to transition between any number of elements,
either by using multiple @code{v-if}s or binding a single element to a
dynamic property. For example:

@verbatim
<transition>
  <button v-if="docState === 'saved'" key="saved">
    Edit
  </button>
  <button v-if="docState === 'edited'" key="edited">
    Save
  </button>
  <button v-if="docState === 'editing'" key="editing">
    Cancel
  </button>
</transition>
@end verbatim

Which could also be written as:

@verbatim
<transition>
  <button v-bind:key="docState">
    {{ buttonMessage }}
  </button>
</transition>
@end verbatim

@verbatim
// ...
computed: {
  buttonMessage: function () {
    switch (this.docState) {
      case 'saved': return 'Edit'
      case 'edited': return 'Save'
      case 'editing': return 'Cancel'
    }
  }
}
@end verbatim

@menu
* Transition Modes::
@end menu

@node Transition Modes
@subsection Transition Modes
@anchor{#transition-modes}
There's still one problem though. Try clicking the button below:

@{% raw %@}
<button v-if=``on'' key=``on'' @@click=``on = false''> on <button v-else
key=``off'' @@click=``on = true''> off
@{% endraw %@}

As it's transitioning between the ``on'' button and the ``off'' button,
both buttons are rendered - one transitioning out while the other
transitions in. This is the default behavior of @code{<transition>} -
entering and leaving happens simultaneously.

Sometimes this works great, like when transitioning items are absolutely
positioned on top of each other:

@{% raw %@}

@verbatim
<transition name="no-mode-absolute-fade">
  <button v-if="on" key="on" @click="on = false">
    on
  </button>
  <button v-else key="off" @click="on = true">
    off
  </button>
</transition>
@end verbatim

@{% endraw %@}

And then maybe also translated so that they look like slide transitions:

@{% raw %@}

@verbatim
<transition name="no-mode-translate-fade">
  <button v-if="on" key="on" @click="on = false">
    on
  </button>
  <button v-else key="off" @click="on = true">
    off
  </button>
</transition>
@end verbatim

@{% endraw %@}

Simultaneous entering and leaving transitions aren't always desirable
though, so Vue offers some alternative @strong{transition modes}:

@itemize
@item
@code{in-out}: New element transitions in first, then when complete, the
current element transitions out.

@item
@code{out-in}: Current element transitions out first, then when
complete, the new element transitions in.

@end itemize

Now let's update the transition for our on/off buttons with
@code{out-in}:

@verbatim
<transition name="fade" mode="out-in">
  <!-- ... the buttons ... -->
</transition>
@end verbatim

@{% raw %@}
<button v-if=``on'' key=``on'' @@click=``on = false''> on <button v-else
key=``off'' @@click=``on = true''> off
@{% endraw %@}

With one attribute addition, we've fixed that original transition
without having to add any special styling.

The @code{in-out} mode isn't used as often, but can sometimes be useful
for a slightly different transition effect. Let's try combining it with
the slide-fade transition we worked on earlier:

@{% raw %@}

@verbatim
<transition name="in-out-translate-fade" mode="in-out">
  <button v-if="on" key="on" @click="on = false">
    on
  </button>
  <button v-else key="off" @click="on = true">
    off
  </button>
</transition>
@end verbatim

@{% endraw %@}

Pretty cool, right?

@node Transitioning Between Components
@section Transitioning Between Components
@anchor{#transitioning-between-components}
Transitioning between components is even simpler - we don't even need
the @code{key} attribute. Instead, we wrap a
@uref{components.html#Dynamic-Components,dynamic component}:

@verbatim
<transition name="component-fade" mode="out-in">
  <component v-bind:is="view"></component>
</transition>
@end verbatim

@verbatim
new Vue({
  el: '#transition-components-demo',
  data: {
    view: 'v-a'
  },
  components: {
    'v-a': {
      template: '<div>Component A</div>'
    },
    'v-b': {
      template: '<div>Component B</div>'
    }
  }
})
@end verbatim

@verbatim
.component-fade-enter-active, .component-fade-leave-active {
  transition: opacity .3s ease;
}
.component-fade-enter, .component-fade-leave-to
/* .component-fade-leave-active below version 2.1.8 */ {
  opacity: 0;
}
@end verbatim

@{% raw %@}
A B
@{% endraw %@}

@node List Transitions
@section List Transitions
@anchor{#list-transitions}
So far, we've managed transitions for:

@itemize
@item
Individual nodes
@item
Multiple nodes where only 1 is rendered at a time
@end itemize

So what about for when we have a whole list of items we want to render
simultaneously, for example with @code{v-for}? In this case, we'll use
the @code{<transition-group>} component. Before we dive into an example
though, there are a few things that are important to know about this
component:

@itemize
@item
Unlike @code{<transition>}, it renders an actual element: a
@code{<span>} by default. You can change the element that's rendered
with the @code{tag} attribute.
@item
@ref{#Transition-Modes,Transition modes} are not available, because we
are no longer alternating between mutually exclusive elements.
@item
Elements inside are @strong{always required} to have a unique @code{key}
attribute.
@item
CSS transition classes will be applied to inner elements and not to the
group/container itself.
@end itemize

@menu
* List Entering/Leaving Transitions::
* List Move Transitions::
* Staggering List Transitions::
@end menu

@node List Entering/Leaving Transitions
@subsection List Entering/Leaving Transitions
@anchor{#list-enteringleaving-transitions}
Now let's dive into an example, transitioning entering and leaving using
the same CSS classes we've used previously:

@verbatim
<div id="list-demo">
  <button v-on:click="add">Add</button>
  <button v-on:click="remove">Remove</button>
  <transition-group name="list" tag="p">
    <span v-for="item in items" v-bind:key="item" class="list-item">
      {{ item }}
    </span>
  </transition-group>
</div>
@end verbatim

@verbatim
new Vue({
  el: '#list-demo',
  data: {
    items: [1,2,3,4,5,6,7,8,9],
    nextNum: 10
  },
  methods: {
    randomIndex: function () {
      return Math.floor(Math.random() * this.items.length)
    },
    add: function () {
      this.items.splice(this.randomIndex(), 0, this.nextNum++)
    },
    remove: function () {
      this.items.splice(this.randomIndex(), 1)
    },
  }
})
@end verbatim

@verbatim
.list-item {
  display: inline-block;
  margin-right: 10px;
}
.list-enter-active, .list-leave-active {
  transition: all 1s;
}
.list-enter, .list-leave-to /* .list-leave-active below version 2.1.8 */ {
  opacity: 0;
  transform: translateY(30px);
}
@end verbatim

@{% raw %@}
Add Remove <span v-for=``item in items'' :key=``item''
class=``list-item''> @{@{ item @}@}
@{% endraw %@}

There's one problem with this example. When you add or remove an item,
the ones around it instantly snap into their new place instead of
smoothly transitioning. We'll fix that later.

@node List Move Transitions
@subsection List Move Transitions
@anchor{#list-move-transitions}
The @code{<transition-group>} component has another trick up its sleeve.
It can not only animate entering and leaving, but also changes in
position. The only new concept you need to know to use this feature is
the addition of @strong{the @code{v-move} class}, which is added when
items are changing positions. Like the other classes, its prefix will
match the value of a provided @code{name} attribute and you can also
manually specify a class with the @code{move-class} attribute.

This class is mostly useful for specifying the transition timing and
easing curve, as you'll see below:

@verbatim
<script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.14.1/lodash.min.js"></script>

<div id="flip-list-demo" class="demo">
  <button v-on:click="shuffle">Shuffle</button>
  <transition-group name="flip-list" tag="ul">
    <li v-for="item in items" v-bind:key="item">
      {{ item }}
    </li>
  </transition-group>
</div>
@end verbatim

@verbatim
new Vue({
  el: '#flip-list-demo',
  data: {
    items: [1,2,3,4,5,6,7,8,9]
  },
  methods: {
    shuffle: function () {
      this.items = _.shuffle(this.items)
    }
  }
})
@end verbatim

@verbatim
.flip-list-move {
  transition: transform 1s;
}
@end verbatim

@{% raw %@}
Shuffle <li v-for=``item in items'' :key=``item''> @{@{ item @}@}
@{% endraw %@}

This might seem like magic, but under the hood, Vue is using an
animation technique called
@uref{https://aerotwist.com/blog/flip-your-animations/,FLIP} to smoothly
transition elements from their old position to their new position using
transforms.

We can combine this technique with our previous implementation to
animate every possible change to our list!

@verbatim
<script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.14.1/lodash.min.js"></script>

<div id="list-complete-demo" class="demo">
  <button v-on:click="shuffle">Shuffle</button>
  <button v-on:click="add">Add</button>
  <button v-on:click="remove">Remove</button>
  <transition-group name="list-complete" tag="p">
    <span
      v-for="item in items"
      v-bind:key="item"
      class="list-complete-item"
    >
      {{ item }}
    </span>
  </transition-group>
</div>
@end verbatim

@verbatim
new Vue({
  el: '#list-complete-demo',
  data: {
    items: [1,2,3,4,5,6,7,8,9],
    nextNum: 10
  },
  methods: {
    randomIndex: function () {
      return Math.floor(Math.random() * this.items.length)
    },
    add: function () {
      this.items.splice(this.randomIndex(), 0, this.nextNum++)
    },
    remove: function () {
      this.items.splice(this.randomIndex(), 1)
    },
    shuffle: function () {
      this.items = _.shuffle(this.items)
    }
  }
})
@end verbatim

@verbatim
.list-complete-item {
  transition: all 1s;
  display: inline-block;
  margin-right: 10px;
}
.list-complete-enter, .list-complete-leave-to
/* .list-complete-leave-active below version 2.1.8 */ {
  opacity: 0;
  transform: translateY(30px);
}
.list-complete-leave-active {
  position: absolute;
}
@end verbatim

@{% raw %@}
Shuffle Add Remove <span v-for=``item in items'' :key=``item''
class=``list-complete-item''> @{@{ item @}@}
@{% endraw %@}

One important note is that these FLIP transitions do not work with
elements set to @code{display: inline}. As an alternative, you can use
@code{display: inline-block} or place elements in a flex context.
These FLIP animations are also not limited to a single axis. Items in a
multidimensional grid can be
@uref{https://codesandbox.io/s/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-list-move-transitions,transitioned
too}:

@{% raw %@}
Lazy Sudoku
Keep hitting the shuffle button until you win.
<button @@click=``shuffle''> Shuffle <div v-for=``cell in cells''
:key=``cell.id'' class=``cell''> @{@{ cell.number @}@}
@{% endraw %@}

@node Staggering List Transitions
@subsection Staggering List Transitions
@anchor{#staggering-list-transitions}
By communicating with JavaScript transitions through data attributes,
it's also possible to stagger transitions in a list:

@verbatim
<script src="https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js"></script>

<div id="staggered-list-demo">
  <input v-model="query">
  <transition-group
    name="staggered-fade"
    tag="ul"
    v-bind:css="false"
    v-on:before-enter="beforeEnter"
    v-on:enter="enter"
    v-on:leave="leave"
  >
    <li
      v-for="(item, index) in computedList"
      v-bind:key="item.msg"
      v-bind:data-index="index"
    >{{ item.msg }}</li>
  </transition-group>
</div>
@end verbatim

@verbatim
new Vue({
  el: '#staggered-list-demo',
  data: {
    query: '',
    list: [
      { msg: 'Bruce Lee' },
      { msg: 'Jackie Chan' },
      { msg: 'Chuck Norris' },
      { msg: 'Jet Li' },
      { msg: 'Kung Fury' }
    ]
  },
  computed: {
    computedList: function () {
      var vm = this
      return this.list.filter(function (item) {
        return item.msg.toLowerCase().indexOf(vm.query.toLowerCase()) !== -1
      })
    }
  },
  methods: {
    beforeEnter: function (el) {
      el.style.opacity = 0
      el.style.height = 0
    },
    enter: function (el, done) {
      var delay = el.dataset.index * 150
      setTimeout(function () {
        Velocity(
          el,
          { opacity: 1, height: '1.6em' },
          { complete: done }
        )
      }, delay)
    },
    leave: function (el, done) {
      var delay = el.dataset.index * 150
      setTimeout(function () {
        Velocity(
          el,
          { opacity: 0, height: 0 },
          { complete: done }
        )
      }, delay)
    }
  }
})
@end verbatim

@{% raw %@}
@{@{ item.msg @}@}
@{% endraw %@}

@node Reusable Transitions
@section Reusable Transitions
@anchor{#reusable-transitions}
Transitions can be reused through Vue's component system. To create a
reusable transition, all you have to do is place a @code{<transition>}
or @code{<transition-group>} component at the root, then pass any
children into the transition component.

Here's an example using a template component:

@verbatim
Vue.component('my-special-transition', {
  template: '\
    <transition\
      name="very-special-transition"\
      mode="out-in"\
      v-on:before-enter="beforeEnter"\
      v-on:after-enter="afterEnter"\
    >\
      <slot></slot>\
    </transition>\
  ',
  methods: {
    beforeEnter: function (el) {
      // ...
    },
    afterEnter: function (el) {
      // ...
    }
  }
})
@end verbatim

And @uref{render-function.html#Functional-Components,functional
components} are especially well-suited to this task:

@verbatim
Vue.component('my-special-transition', {
  functional: true,
  render: function (createElement, context) {
    var data = {
      props: {
        name: 'very-special-transition',
        mode: 'out-in'
      },
      on: {
        beforeEnter: function (el) {
          // ...
        },
        afterEnter: function (el) {
          // ...
        }
      }
    }
    return createElement('transition', data, context.children)
  }
})
@end verbatim

@node Dynamic Transitions
@section Dynamic Transitions
@anchor{#dynamic-transitions}
Yes, even transitions in Vue are data-driven! The most basic example of
a dynamic transition binds the @code{name} attribute to a dynamic
property.

@verbatim
<transition v-bind:name="transitionName">
  <!-- ... -->
</transition>
@end verbatim

This can be useful when you've defined CSS transitions/animations using
Vue's transition class conventions and want to switch between them.

Really though, any transition attribute can be dynamically bound. And
it's not only attributes. Since event hooks are methods, they have
access to any data in the context. That means depending on the state of
your component, your JavaScript transitions can behave differently.

@verbatim
<script src="https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js"></script>

<div id="dynamic-fade-demo" class="demo">
  Fade In: <input type="range" v-model="fadeInDuration" min="0" v-bind:max="maxFadeDuration">
  Fade Out: <input type="range" v-model="fadeOutDuration" min="0" v-bind:max="maxFadeDuration">
  <transition
    v-bind:css="false"
    v-on:before-enter="beforeEnter"
    v-on:enter="enter"
    v-on:leave="leave"
  >
    <p v-if="show">hello</p>
  </transition>
  <button
    v-if="stop"
    v-on:click="stop = false; show = false"
  >Start animating</button>
  <button
    v-else
    v-on:click="stop = true"
  >Stop it!</button>
</div>
@end verbatim

@verbatim
new Vue({
  el: '#dynamic-fade-demo',
  data: {
    show: true,
    fadeInDuration: 1000,
    fadeOutDuration: 1000,
    maxFadeDuration: 1500,
    stop: true
  },
  mounted: function () {
    this.show = false
  },
  methods: {
    beforeEnter: function (el) {
      el.style.opacity = 0
    },
    enter: function (el, done) {
      var vm = this
      Velocity(el,
        { opacity: 1 },
        {
          duration: this.fadeInDuration,
          complete: function () {
            done()
            if (!vm.stop) vm.show = false
          }
        }
      )
    },
    leave: function (el, done) {
      var vm = this
      Velocity(el,
        { opacity: 0 },
        {
          duration: this.fadeOutDuration,
          complete: function () {
            done()
            vm.show = true
          }
        }
      )
    }
  }
})
@end verbatim

@{% raw %@}
Fade In: Fade Out:
hello
Start animating Stop it!
@{% endraw %@}

Finally, the ultimate way of creating dynamic transitions is through
components that accept props to change the nature of the transition(s)
to be used. It may sound cheesy, but the only limit really is your
imagination.

@bye
