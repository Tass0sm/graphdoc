\input texinfo
@documentencoding UTF-8

@ifnottex
@paragraphindent 0
@end ifnottex
@titlepage
@title Installation
@end titlepage

@node Top
@top Installation

@node Compatibility Note
@subsection Compatibility Note
@anchor{#compatibility-note}
Vue does @strong{not} support IE8 and below, because it uses ECMAScript
5 features that are un-shimmable in IE8. However it supports all
@uref{https://caniuse.com/#feat=es5,ECMAScript 5 compliant browsers}.

@node Semantic Versioning
@subsection Semantic Versioning
@anchor{#semantic-versioning}
Vue follows @uref{https://semver.org/,Semantic Versioning} in all its
official projects for documented features and behavior. For undocumented
behavior or exposed internals, changes are described in
@uref{https://github.com/vuejs/vue/releases,release notes}.

@node Release Notes
@subsection Release Notes
@anchor{#release-notes}
Latest stable version: @{@{vue_version@}@}

Detailed release notes for each version are available on
@uref{https://github.com/vuejs/vue/releases,GitHub}.

@node Vue Devtools
@section Vue Devtools
@anchor{#vue-devtools}
When using Vue, we recommend also installing the
@uref{https://github.com/vuejs/vue-devtools#vue-devtools,Vue Devtools}
in your browser, allowing you to inspect and debug your Vue applications
in a more user-friendly interface.

@node Direct <script> Include
@section Direct @code{<script>} Include
@anchor{#direct-script-include}
Simply download and include with a script tag. @code{Vue} will be
registered as a global variable.

Don't use the minified version during development. You will miss out on
all the nice warnings for common mistakes!
Development VersionWith full warnings and debug mode

Production VersionWarnings stripped, @{@{gz_size@}@}KB min+gzip

@menu
* CDN::
@end menu

@node CDN
@subsection CDN
@anchor{#cdn}
For prototyping or learning purposes, you can use the latest version
with:

@verbatim
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
@end verbatim

For production, we recommend linking to a specific version number and
build to avoid unexpected breakage from newer versions:

@verbatim
<script src="https://cdn.jsdelivr.net/npm/vue@2.6.0"></script>
@end verbatim

If you are using native ES Modules, there is also an ES Modules
compatible build:

@verbatim
<script type="module">
  import Vue from 'https://cdn.jsdelivr.net/npm/vue@2.6.0/dist/vue.esm.browser.js'
</script>
@end verbatim

You can browse the source of the NPM package at
@uref{https://cdn.jsdelivr.net/npm/vue/,cdn.jsdelivr.net/npm/vue}.

Vue is also available on
@uref{https://unpkg.com/vue@@%7B%7Bvue_version%7D%7D/dist/vue.js,unpkg}
and
@uref{https://cdnjs.cloudflare.com/ajax/libs/vue/%7B%7Bvue_version%7D%7D/vue.js,cdnjs}
(cdnjs takes some time to sync so the latest release may not be
available yet).

Make sure to read about @ref{#Explanation-of-Different-Builds,the
different builds of Vue} and use the @strong{production version} in your
published site, replacing @code{vue.js} with @code{vue.min.js}. This is
a smaller build optimized for speed instead of development experience.

@node NPM
@section NPM
@anchor{#npm}
NPM is the recommended installation method when building large scale
applications with Vue. It pairs nicely with module bundlers such as
@uref{https://webpack.js.org/,Webpack} or
@uref{http://browserify.org/,Browserify}. Vue also provides accompanying
tools for authoring @uref{single-file-components.html,Single File
Components}.

@verbatim
# latest stable
$ npm install vue
@end verbatim

@node CLI
@section CLI
@anchor{#cli}
Vue provides an @uref{https://github.com/vuejs/vue-cli,official CLI} for
quickly scaffolding ambitious Single Page Applications. It provides
batteries-included build setups for a modern frontend workflow. It takes
only a few minutes to get up and running with hot-reload, lint-on-save,
and production-ready builds. See @uref{https://cli.vuejs.org,the Vue CLI
docs} for more details.

The CLI assumes prior knowledge of Node.js and the associated build
tools. If you are new to Vue or front-end build tools, we strongly
suggest going through the guide without any build tools before using the
CLI.
Watch a video explanation on Vue Mastery

@node Explanation of Different Builds
@section Explanation of Different Builds
@anchor{#explanation-of-different-builds}
In the @uref{https://cdn.jsdelivr.net/npm/vue/dist/,@code{dist/}
directory of the NPM package} you will find many different builds of
Vue.js. Here's an overview of the difference between them:

@multitable {@strong{Runtime-only (production)}} {vue.runtime.min.js} {vue.runtime.common.js} {ES Module (for bundlers)} {ES Module (for browsers)} 
@headitem 
UMD
 @tab CommonJS
 @tab ES Module (for bundlers)
 @tab ES Module (for browsers)
@item 
@strong{Full}
 @tab vue.js
 @tab vue.common.js
 @tab vue.esm.js
 @tab vue.esm.browser.js
@item 
@strong{Runtime-only}
 @tab vue.runtime.js
 @tab vue.runtime.common.js
 @tab vue.runtime.esm.js
 @tab -
@item 
@strong{Full (production)}
 @tab vue.min.js
 @tab -
 @tab -
 @tab vue.esm.browser.min.js
@item 
@strong{Runtime-only (production)}
 @tab vue.runtime.min.js
 @tab -
 @tab -
 @tab -
@end multitable

@menu
* Terms::
* Runtime + Compiler vs@ Runtime-only::
* Development vs@ Production Mode::
* CSP environments::
@end menu

@node Terms
@subsection Terms
@anchor{#terms}
@itemize
@item
@strong{Full}: builds that contain both the compiler and the runtime.

@item
@strong{Compiler}: code that is responsible for compiling template
strings into JavaScript render functions.

@item
@strong{Runtime}: code that is responsible for creating Vue instances,
rendering and patching virtual DOM, etc. Basically everything minus the
compiler.

@item
@strong{@uref{https://github.com/umdjs/umd,UMD}}: UMD builds can be used
directly in the browser via a @code{<script>} tag. The default file from
jsDelivr CDN at @url{https://cdn.jsdelivr.net/npm/vue} is the Runtime +
Compiler UMD build (@code{vue.js}).

@item
@strong{@uref{http://wiki.commonjs.org/wiki/Modules/1.1,CommonJS}}:
CommonJS builds are intended for use with older bundlers like
@uref{http://browserify.org/,browserify} or
@uref{https://webpack.github.io,webpack 1}. The default file for these
bundlers (@code{pkg.main}) is the Runtime only CommonJS build
(@code{vue.runtime.common.js}).

@item
@strong{@uref{http://exploringjs.com/es6/ch_modules.html,ES Module}}:
starting in 2.6 Vue provides two ES Modules (ESM) builds:

@itemize
@item
ESM for bundlers: intended for use with modern bundlers like
@uref{https://webpack.js.org,webpack 2} or
@uref{https://rollupjs.org/,Rollup}. ESM format is designed to be
statically analyzable so the bundlers can take advantage of that to
perform ``tree-shaking'' and eliminate unused code from your final
bundle. The default file for these bundlers (@code{pkg.module}) is the
Runtime only ES Module build (@code{vue.runtime.esm.js}).

@item
ESM for browsers (2.6+ only): intended for direct imports in modern
browsers via @code{<script type="module">}.

@end itemize

@end itemize

@node Runtime + Compiler vs@ Runtime-only
@subsection Runtime + Compiler vs.@ Runtime-only
@anchor{#runtime-compiler-vs.-runtime-only}
If you need to compile templates on the client (e.g.@ passing a string
to the @code{template} option, or mounting to an element using its
in-DOM HTML as the template), you will need the compiler and thus the
full build:

@verbatim
// this requires the compiler
new Vue({
  template: '<div>{{ hi }}</div>'
})

// this does not
new Vue({
  render (h) {
    return h('div', this.hi)
  }
})
@end verbatim

When using @code{vue-loader} or @code{vueify}, templates inside
@code{*.vue} files are pre-compiled into JavaScript at build time. You
don't really need the compiler in the final bundle, and can therefore
use the runtime-only build.

Since the runtime-only builds are roughly 30% lighter-weight than their
full-build counterparts, you should use it whenever you can. If you
still wish to use the full build instead, you need to configure an alias
in your bundler:

@menu
* Webpack::
* Rollup::
* Browserify::
* Parcel::
@end menu

@node Webpack
@subsubsection Webpack
@anchor{#webpack}

@verbatim
module.exports = {
  // ...
  resolve: {
    alias: {
      'vue$': 'vue/dist/vue.esm.js' // 'vue/dist/vue.common.js' for webpack 1
    }
  }
}
@end verbatim

@node Rollup
@subsubsection Rollup
@anchor{#rollup}

@verbatim
const alias = require('rollup-plugin-alias')

rollup({
  // ...
  plugins: [
    alias({
      'vue': require.resolve('vue/dist/vue.esm.js')
    })
  ]
})
@end verbatim

@node Browserify
@subsubsection Browserify
@anchor{#browserify}
Add to your project's @code{package.json}:

@verbatim
{
  // ...
  "browser": {
    "vue": "vue/dist/vue.common.js"
  }
}
@end verbatim

@node Parcel
@subsubsection Parcel
@anchor{#parcel}
Add to your project's @code{package.json}:

@verbatim
{
  // ...
  "alias": {
    "vue" : "./node_modules/vue/dist/vue.common.js"
  }
}
@end verbatim

@node Development vs@ Production Mode
@subsection Development vs.@ Production Mode
@anchor{#development-vs.-production-mode}
Development/production modes are hard-coded for the UMD builds: the
un-minified files are for development, and the minified files are for
production.

CommonJS and ES Module builds are intended for bundlers, therefore we
don't provide minified versions for them. You will be responsible for
minifying the final bundle yourself.

CommonJS and ES Module builds also preserve raw checks for
@code{process.env.NODE_ENV} to determine the mode they should run in.
You should use appropriate bundler configurations to replace these
environment variables in order to control which mode Vue will run in.
Replacing @code{process.env.NODE_ENV} with string literals also allows
minifiers like UglifyJS to completely drop the development-only code
blocks, reducing final file size.

@menu
* Webpack::
* Rollup::
* Browserify::
@end menu

@node Webpack
@subsubsection Webpack
@anchor{#webpack-1}
In Webpack 4+, you can use the @code{mode} option:

@verbatim
module.exports = {
  mode: 'production'
}
@end verbatim

But in Webpack 3 and earlier, you'll need to use
@uref{https://webpack.js.org/plugins/define-plugin/,DefinePlugin}:

@verbatim
var webpack = require('webpack')

module.exports = {
  // ...
  plugins: [
    // ...
    new webpack.DefinePlugin({
      'process.env': {
        NODE_ENV: JSON.stringify('production')
      }
    })
  ]
}
@end verbatim

@node Rollup
@subsubsection Rollup
@anchor{#rollup-1}
Use
@uref{https://github.com/rollup/rollup-plugin-replace,rollup-plugin-replace}:

@verbatim
const replace = require('rollup-plugin-replace')

rollup({
  // ...
  plugins: [
    replace({
      'process.env.NODE_ENV': JSON.stringify('production')
    })
  ]
}).then(...)
@end verbatim

@node Browserify
@subsubsection Browserify
@anchor{#browserify-1}
Apply a global @uref{https://github.com/hughsk/envify,envify} transform
to your bundle.

@verbatim
NODE_ENV=production browserify -g envify -e main.js | uglifyjs -c -m > build.js
@end verbatim

Also see @uref{deployment.html,Production Deployment Tips}.

@node CSP environments
@subsection CSP environments
@anchor{#csp-environments}
Some environments, such as Google Chrome Apps, enforce Content Security
Policy (CSP), which prohibits the use of @code{new Function()} for
evaluating expressions. The full build depends on this feature to
compile templates, so is unusable in these environments.

On the other hand, the runtime-only build is fully CSP-compliant. When
using the runtime-only build with
@uref{https://github.com/vuejs-templates/webpack-simple,Webpack +
vue-loader} or
@uref{https://github.com/vuejs-templates/browserify-simple,Browserify +
vueify}, your templates will be precompiled into @code{render} functions
which work perfectly in CSP environments.

@node Dev Build
@section Dev Build
@anchor{#dev-build}
@strong{Important}: the built files in GitHub's @code{/dist} folder are
only checked-in during releases. To use Vue from the latest source code
on GitHub, you will have to build it yourself!

@verbatim
git clone https://github.com/vuejs/vue.git node_modules/vue
cd node_modules/vue
npm install
npm run build
@end verbatim

@node Bower
@section Bower
@anchor{#bower}
Only UMD builds are available from Bower.

@verbatim
# latest stable
$ bower install vue
@end verbatim

@node AMD Module Loaders
@section AMD Module Loaders
@anchor{#amd-module-loaders}
All UMD builds can be used directly as an AMD module.

@bye
