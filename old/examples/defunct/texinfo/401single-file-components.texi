\input texinfo
@documentencoding UTF-8

@ifnottex
@paragraphindent 0
@end ifnottex
@titlepage
@title Single File Components
@end titlepage

@node Top
@top Single File Components

@node Introduction
@section Introduction
@anchor{#introduction}
Watch a free video lesson on Vue School
In many Vue projects, global components will be defined using
@code{Vue.component}, followed by @code{new Vue(@{ el: '#container' @})}
to target a container element in the body of every page.

This can work very well for small to medium-sized projects, where
JavaScript is only used to enhance certain views. In more complex
projects however, or when your frontend is entirely driven by
JavaScript, these disadvantages become apparent:

@itemize
@item
@strong{Global definitions} force unique names for every component
@item
@strong{String templates} lack syntax highlighting and require ugly
slashes for multiline HTML
@item
@strong{No CSS support} means that while HTML and JavaScript are
modularized into components, CSS is conspicuously left out
@item
@strong{No build step} restricts us to HTML and ES5 JavaScript, rather
than preprocessors like Pug (formerly Jade) and Babel
@end itemize

All of these are solved by @strong{single-file components} with a
@code{.vue} extension, made possible with build tools such as Webpack or
Browserify.

Here's an example of a file we'll call @code{Hello.vue}:

Now we get:

@itemize
@item
@uref{https://github.com/vuejs/awesome-vue#source-code-editing,Complete
syntax highlighting}
@item
@uref{https://webpack.js.org/concepts/modules/#what-is-a-webpack-module,CommonJS
modules}
@item
@uref{https://vue-loader.vuejs.org/en/features/scoped-css.html,Component-scoped
CSS}
@end itemize

As promised, we can also use preprocessors such as Pug, Babel (with
ES2015 modules), and Stylus for cleaner and more feature-rich
components.

These specific languages are only examples. You could as easily use
Bubl√©, TypeScript, SCSS, PostCSS - or whatever other preprocessors that
help you be productive. If using Webpack with @code{vue-loader}, it also
has first-class support for CSS Modules.

@menu
* What About Separation of Concerns?::
@end menu

@node What About Separation of Concerns?
@subsection What About Separation of Concerns?
@anchor{#what-about-separation-of-concerns}
One important thing to note is that @strong{separation of concerns is
not equal to separation of file types.} In modern UI development, we
have found that instead of dividing the codebase into three huge layers
that interweave with one another, it makes much more sense to divide
them into loosely-coupled components and compose them. Inside a
component, its template, logic and styles are inherently coupled, and
collocating them actually makes the component more cohesive and
maintainable.

Even if you don't like the idea of Single-File Components, you can still
leverage its hot-reloading and pre-compilation features by separating
your JavaScript and CSS into separate files:

@verbatim
<!-- my-component.vue -->
<template>
  <div>This will be pre-compiled</div>
</template>
<script src="./my-component.js"></script>
<style src="./my-component.css"></style>
@end verbatim

@node Getting Started
@section Getting Started
@anchor{#getting-started}

@menu
* Example Sandbox::
* For Users New to Module Build Systems in JavaScript::
* For Advanced Users::
@end menu

@node Example Sandbox
@subsection Example Sandbox
@anchor{#example-sandbox}
If you want to dive right in and start playing with single-file
components, check out @uref{https://codesandbox.io/s/o29j95wx9,this
simple todo app} on CodeSandbox.

@node For Users New to Module Build Systems in JavaScript
@subsection For Users New to Module Build Systems in JavaScript
@anchor{#for-users-new-to-module-build-systems-in-javascript}
With @code{.vue} components, we're entering the realm of advanced
JavaScript applications. That means learning to use a few additional
tools if you haven't already:

@itemize
@item
@strong{Node Package Manager (NPM)}: Read the
@uref{https://docs.npmjs.com/packages-and-modules/getting-packages-from-the-registry,Getting
Started guide} section about how to get packages from the registry.

@item
@strong{Modern JavaScript with ES2015/16}: Read through Babel's
@uref{https://babeljs.io/docs/learn-es2015/,Learn ES2015 guide}. You
don't have to memorize every feature right now, but keep this page as a
reference you can come back to.

@end itemize

After you've taken a day to dive into these resources, we recommend
checking out @uref{https://cli.vuejs.org/,Vue CLI 3}. Follow the
instructions and you should have a Vue project with @code{.vue}
components, ES2015, Webpack and hot-reloading in no time!

@node For Advanced Users
@subsection For Advanced Users
@anchor{#for-advanced-users}
The CLI takes care of most of the tooling configurations for you, but
also allows fine-grained customization through its own
@uref{https://cli.vuejs.org/config/,config options}.

In case you prefer setting up your own build setup from scratch, you
will need to manually configure webpack with
@uref{https://vue-loader.vuejs.org,vue-loader}. To learn more about
webpack itself, check out
@uref{https://webpack.js.org/configuration/,their official docs} and
@uref{https://webpack.academy/p/the-core-concepts,Webpack Academy}.

@bye
