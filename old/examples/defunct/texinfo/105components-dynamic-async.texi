\input texinfo
@documentencoding UTF-8

@ifnottex
@paragraphindent 0
@end ifnottex
@titlepage
@title Dynamic & Async Components
@end titlepage

@node Top
@top Dynamic & Async Components

@quotation
This page assumes you've already read the
@uref{components.html,Components Basics}. Read that first if you are new
to components.
@end quotation

@node keep-alive with Dynamic Components
@section @code{keep-alive} with Dynamic Components
@anchor{#keep-alive-with-dynamic-components}
Earlier, we used the @code{is} attribute to switch between components in
a tabbed interface:

@{% codeblock lang:html %@} @{% endcodeblock %@}

When switching between these components though, you'll sometimes want to
maintain their state or avoid re-rendering for performance reasons. For
example, when expanding our tabbed interface a little:

@{% raw %@}
@{@{ tab @}@}
@{% endraw %@}

You'll notice that if you select a post, switch to the @emph{Archive}
tab, then switch back to @emph{Posts}, it's no longer showing the post
you selected. That's because each time you switch to a new tab, Vue
creates a new instance of the @code{currentTabComponent}.

Recreating dynamic components is normally useful behavior, but in this
case, we'd really like those tab component instances to be cached once
they're created for the first time. To solve this problem, we can wrap
our dynamic component with a @code{<keep-alive>} element:

@verbatim
<!-- Inactive components will be cached! -->
<keep-alive>
  <component v-bind:is="currentTabComponent"></component>
</keep-alive>
@end verbatim

Check out the result below:

@{% raw %@}
@{@{ tab @}@}
@{% endraw %@}

Now the @emph{Posts} tab maintains its state (the selected post) even
when it's not rendered. See
@uref{https://codesandbox.io/s/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-keep-alive-with-dynamic-components,this
example} for the complete code.

Note that @code{<keep-alive>} requires the components being switched
between to all have names, either using the @code{name} option on a
component, or through local/global registration.
Check out more details on @code{<keep-alive>} in the
@uref{../api/#keep-alive,API reference}.

@node Async Components
@section Async Components
@anchor{#async-components}
Watch a free video lesson on Vue School
In large applications, we may need to divide the app into smaller chunks
and only load a component from the server when it's needed. To make that
easier, Vue allows you to define your component as a factory function
that asynchronously resolves your component definition. Vue will only
trigger the factory function when the component needs to be rendered and
will cache the result for future re-renders. For example:

@verbatim
Vue.component('async-example', function (resolve, reject) {
  setTimeout(function () {
    // Pass the component definition to the resolve callback
    resolve({
      template: '<div>I am async!</div>'
    })
  }, 1000)
})
@end verbatim

As you can see, the factory function receives a @code{resolve} callback,
which should be called when you have retrieved your component definition
from the server. You can also call @code{reject(reason)} to indicate the
load has failed. The @code{setTimeout} here is for demonstration; how to
retrieve the component is up to you. One recommended approach is to use
async components together with
@uref{https://webpack.js.org/guides/code-splitting/,Webpack's
code-splitting feature}:

@verbatim
Vue.component('async-webpack-example', function (resolve) {
  // This special require syntax will instruct Webpack to
  // automatically split your built code into bundles which
  // are loaded over Ajax requests.
  require(['./my-async-component'], resolve)
})
@end verbatim

You can also return a @code{Promise} in the factory function, so with
Webpack 2 and ES2015 syntax you can make use of dynamic imports:

@verbatim
Vue.component(
  'async-webpack-example',
  // A dynamic import returns a Promise.
  () => import('./my-async-component')
)
@end verbatim

When using @uref{components-registration.html#Local-Registration,local
registration}, you can also directly provide a function that returns a
@code{Promise}:

@verbatim
new Vue({
  // ...
  components: {
    'my-component': () => import('./my-async-component')
  }
})
@end verbatim

If you're a Browserify user that would like to use async components, its
creator has unfortunately
@uref{https://github.com/substack/node-browserify/issues/58#issuecomment-21978224,made
it clear} that async loading ``is not something that Browserify will
ever support.'' Officially, at least. The Browserify community has found
@uref{https://github.com/vuejs/vuejs.org/issues/620,some workarounds},
which may be helpful for existing and complex applications. For all
other scenarios, we recommend using Webpack for built-in, first-class
async support.

@menu
* Handling Loading State::
@end menu

@node Handling Loading State
@subsection Handling Loading State
@anchor{#handling-loading-state}
@quotation
New in 2.3.0+
@end quotation
The async component factory can also return an object of the following
format:

@verbatim
const AsyncComponent = () => ({
  // The component to load (should be a Promise)
  component: import('./MyComponent.vue'),
  // A component to use while the async component is loading
  loading: LoadingComponent,
  // A component to use if the load fails
  error: ErrorComponent,
  // Delay before showing the loading component. Default: 200ms.
  delay: 200,
  // The error component will be displayed if a timeout is
  // provided and exceeded. Default: Infinity.
  timeout: 3000
})
@end verbatim

@quotation
Note that you must use @uref{https://github.com/vuejs/vue-router,Vue
Router} 2.4.0+ if you wish to use the above syntax for route components.
@end quotation

@bye
