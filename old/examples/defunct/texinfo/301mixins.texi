\input texinfo
@documentencoding UTF-8

@ifnottex
@paragraphindent 0
@end ifnottex
@titlepage
@title Mixins
@end titlepage

@node Top
@top Mixins

@node Basics
@section Basics
@anchor{#basics}
Mixins are a flexible way to distribute reusable functionalities for Vue
components. A mixin object can contain any component options. When a
component uses a mixin, all options in the mixin will be ``mixed'' into
the component's own options.

Watch a video explanation on Vue Mastery
Example:

@verbatim
// define a mixin object
var myMixin = {
  created: function () {
    this.hello()
  },
  methods: {
    hello: function () {
      console.log('hello from mixin!')
    }
  }
}

// define a component that uses this mixin
var Component = Vue.extend({
  mixins: [myMixin]
})

var component = new Component() // => "hello from mixin!"
@end verbatim

@node Option Merging
@section Option Merging
@anchor{#option-merging}
When a mixin and the component itself contain overlapping options, they
will be ``merged'' using appropriate strategies.

For example, data objects undergo a recursive merge, with the
component's data taking priority in cases of conflicts.

@verbatim
var mixin = {
  data: function () {
    return {
      message: 'hello',
      foo: 'abc'
    }
  }
}

new Vue({
  mixins: [mixin],
  data: function () {
    return {
      message: 'goodbye',
      bar: 'def'
    }
  },
  created: function () {
    console.log(this.$data)
    // => { message: "goodbye", foo: "abc", bar: "def" }
  }
})
@end verbatim

Hook functions with the same name are merged into an array so that all
of them will be called. Mixin hooks will be called @strong{before} the
component's own hooks.

@verbatim
var mixin = {
  created: function () {
    console.log('mixin hook called')
  }
}

new Vue({
  mixins: [mixin],
  created: function () {
    console.log('component hook called')
  }
})

// => "mixin hook called"
// => "component hook called"
@end verbatim

Options that expect object values, for example @code{methods},
@code{components} and @code{directives}, will be merged into the same
object. The component's options will take priority when there are
conflicting keys in these objects:

@verbatim
var mixin = {
  methods: {
    foo: function () {
      console.log('foo')
    },
    conflicting: function () {
      console.log('from mixin')
    }
  }
}

var vm = new Vue({
  mixins: [mixin],
  methods: {
    bar: function () {
      console.log('bar')
    },
    conflicting: function () {
      console.log('from self')
    }
  }
})

vm.foo() // => "foo"
vm.bar() // => "bar"
vm.conflicting() // => "from self"
@end verbatim

Note that the same merge strategies are used in @code{Vue.extend()}.

@node Global Mixin
@section Global Mixin
@anchor{#global-mixin}
You can also apply a mixin globally. Use with caution! Once you apply a
mixin globally, it will affect @strong{every} Vue instance created
afterwards. When used properly, this can be used to inject processing
logic for custom options:

@verbatim
// inject a handler for `myOption` custom option
Vue.mixin({
  created: function () {
    var myOption = this.$options.myOption
    if (myOption) {
      console.log(myOption)
    }
  }
})

new Vue({
  myOption: 'hello!'
})
// => "hello!"
@end verbatim

Use global mixins sparsely and carefully, because it affects every
single Vue instance created, including third party components. In most
cases, you should only use it for custom option handling like
demonstrated in the example above. It's also a good idea to ship them as
@uref{plugins.html,Plugins} to avoid duplicate application.

@node Custom Option Merge Strategies
@section Custom Option Merge Strategies
@anchor{#custom-option-merge-strategies}
When custom options are merged, they use the default strategy which
overwrites the existing value. If you want a custom option to be merged
using custom logic, you need to attach a function to
@code{Vue.config.optionMergeStrategies}:

@verbatim
Vue.config.optionMergeStrategies.myOption = function (toVal, fromVal) {
  // return mergedVal
}
@end verbatim

For most object-based options, you can use the same strategy used by
@code{methods}:

@verbatim
var strategies = Vue.config.optionMergeStrategies
strategies.myOption = strategies.methods
@end verbatim

A more advanced example can be found on
@uref{https://github.com/vuejs/vuex,Vuex}'s 1.x merging strategy:

@verbatim
const merge = Vue.config.optionMergeStrategies.computed
Vue.config.optionMergeStrategies.vuex = function (toVal, fromVal) {
  if (!toVal) return fromVal
  if (!fromVal) return toVal
  return {
    getters: merge(toVal.getters, fromVal.getters),
    state: merge(toVal.state, fromVal.state),
    actions: merge(toVal.actions, fromVal.actions)
  }
}
@end verbatim

@bye
