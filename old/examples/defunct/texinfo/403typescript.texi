\input texinfo
@documentencoding UTF-8

@ifnottex
@paragraphindent 0
@end ifnottex
@titlepage
@title TypeScript Support
@end titlepage

@node Top
@top TypeScript Support

@quotation
@uref{https://cli.vuejs.org,Vue CLI} provides built-in TypeScript
tooling support.
@end quotation

@node Official Declaration in NPM Packages
@section Official Declaration in NPM Packages
@anchor{#official-declaration-in-npm-packages}
A static type system can help prevent many potential runtime errors,
especially as applications grow. That's why Vue ships with
@uref{https://github.com/vuejs/vue/tree/dev/types,official type
declarations} for @uref{https://www.typescriptlang.org/,TypeScript} -
not only in Vue core, but also for
@uref{https://github.com/vuejs/vue-router/tree/dev/types,vue-router} and
@uref{https://github.com/vuejs/vuex/tree/dev/types,vuex} as well.

Since these are @uref{https://cdn.jsdelivr.net/npm/vue/types/,published
on NPM}, and the latest TypeScript knows how to resolve type
declarations in NPM packages, this means when installed via NPM, you
don't need any additional tooling to use TypeScript with Vue.

@node Recommended Configuration
@section Recommended Configuration
@anchor{#recommended-configuration}

@verbatim
// tsconfig.json
{
  "compilerOptions": {
    // this aligns with Vue's browser support
    "target": "es5",
    // this enables stricter inference for data properties on `this`
    "strict": true,
    // if using webpack 2+ or rollup, to leverage tree shaking:
    "module": "es2015",
    "moduleResolution": "node"
  }
}
@end verbatim

Note that you have to include @code{strict: true} (or at least
@code{noImplicitThis: true} which is a part of @code{strict} flag) to
leverage type checking of @code{this} in component methods otherwise it
is always treated as @code{any} type.

See
@uref{https://www.typescriptlang.org/docs/handbook/compiler-options.html,TypeScript
compiler options docs} for more details.

@node Development Tooling
@section Development Tooling
@anchor{#development-tooling}

@menu
* Project Creation::
* Editor Support::
@end menu

@node Project Creation
@subsection Project Creation
@anchor{#project-creation}
@uref{https://github.com/vuejs/vue-cli,Vue CLI 3} can generate new
projects that use TypeScript. To get started:

@verbatim
# 1. Install Vue CLI, if it's not already installed
npm install --global @vue/cli

# 2. Create a new project, then choose the "Manually select features" option
vue create my-project-name
@end verbatim

@node Editor Support
@subsection Editor Support
@anchor{#editor-support}
For developing Vue applications with TypeScript, we strongly recommend
using @uref{https://code.visualstudio.com/,Visual Studio Code}, which
provides great out-of-the-box support for TypeScript. If you are using
@uref{./single-file-components.html,single-file components} (SFCs), get
the awesome @uref{https://github.com/vuejs/vetur,Vetur extension}, which
provides TypeScript inference inside SFCs and many other great features.

@uref{https://www.jetbrains.com/webstorm/,WebStorm} also provides
out-of-the-box support for both TypeScript and Vue.

@node Basic Usage
@section Basic Usage
@anchor{#basic-usage}
To let TypeScript properly infer types inside Vue component options, you
need to define components with @code{Vue.component} or
@code{Vue.extend}:

@verbatim
import Vue from 'vue'

const Component = Vue.extend({
  // type inference enabled
})

const Component = {
  // this will NOT have type inference,
  // because TypeScript can't tell this is options for a Vue component.
}
@end verbatim

@node Class-Style Vue Components
@section Class-Style Vue Components
@anchor{#class-style-vue-components}
If you prefer a class-based API when declaring components, you can use
the officially maintained
@uref{https://github.com/vuejs/vue-class-component,vue-class-component}
decorator:

@verbatim
import Vue from 'vue'
import Component from 'vue-class-component'

// The @Component decorator indicates the class is a Vue component
@Component({
  // All component options are allowed in here
  template: '<button @click="onClick">Click!</button>'
})
export default class MyComponent extends Vue {
  // Initial data can be declared as instance properties
  message: string = 'Hello!'

  // Component methods can be declared as instance methods
  onClick (): void {
    window.alert(this.message)
  }
}
@end verbatim

@node Augmenting Types for Use with Plugins
@section Augmenting Types for Use with Plugins
@anchor{#augmenting-types-for-use-with-plugins}
Plugins may add to Vue's global/instance properties and component
options. In these cases, type declarations are needed to make plugins
compile in TypeScript. Fortunately, there's a TypeScript feature to
augment existing types called
@uref{https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation,module
augmentation}.

For example, to declare an instance property @code{$myProperty} with
type @code{string}:

@verbatim
// 1. Make sure to import 'vue' before declaring augmented types
import Vue from 'vue'

// 2. Specify a file with the types you want to augment
//    Vue has the constructor type in types/vue.d.ts
declare module 'vue/types/vue' {
  // 3. Declare augmentation for Vue
  interface Vue {
    $myProperty: string
  }
}
@end verbatim

After including the above code as a declaration file (like
@code{my-property.d.ts}) in your project, you can use @code{$myProperty}
on a Vue instance.

@verbatim
var vm = new Vue()
console.log(vm.$myProperty) // This should compile successfully
@end verbatim

You can also declare additional global properties and component options:

@verbatim
import Vue from 'vue'

declare module 'vue/types/vue' {
  // Global properties can be declared
  // on the `VueConstructor` interface
  interface VueConstructor {
    $myGlobal: string
  }
}

// ComponentOptions is declared in types/options.d.ts
declare module 'vue/types/options' {
  interface ComponentOptions<V extends Vue> {
    myOption?: string
  }
}
@end verbatim

The above declarations allow the following code to be compiled:

@verbatim
// Global property
console.log(Vue.$myGlobal)

// Additional component option
var vm = new Vue({
  myOption: 'Hello'
})
@end verbatim

@node Annotating Return Types
@section Annotating Return Types
@anchor{#annotating-return-types}
Because of the circular nature of Vue's declaration files, TypeScript
may have difficulties inferring the types of certain methods. For this
reason, you may need to annotate the return type on methods like
@code{render} and those in @code{computed}.

@verbatim
import Vue, { VNode } from 'vue'

const Component = Vue.extend({
  data () {
    return {
      msg: 'Hello'
    }
  },
  methods: {
    // need annotation due to `this` in return type
    greet (): string {
      return this.msg + ' world'
    }
  },
  computed: {
    // need annotation
    greeting(): string {
      return this.greet() + '!'
    }
  },
  // `createElement` is inferred, but `render` needs return type
  render (createElement): VNode {
    return createElement('div', this.greeting)
  }
})
@end verbatim

If you find type inference or member completion isn't working,
annotating certain methods may help address these problems. Using the
@code{--noImplicitAny} option will help find many of these unannotated
methods.

@node Annotating Props
@section Annotating Props
@anchor{#annotating-props}

@verbatim
import Vue, { PropType } from 'vue'

interface ComplexMessage { 
  title: string,
  okMessage: string,
  cancelMessage: string
}
const Component = Vue.extend({
  props: {
    name: String,
    success: { type: String },
    callback: { 
      type: Function as PropType<() => void>
    },
    message: {
      type: Object as PropType<ComplexMessage>,
      required: true,
      validator (message: ComplexMessage) {
        return !!message.title;
      }
    }
  }
})
@end verbatim

If you find validator not getting type inference or member completion
isn't working, annotating the argument with the expected type may help
address these problems.

@bye
