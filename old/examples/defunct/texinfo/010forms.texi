\input texinfo
@documentencoding UTF-8

@ifnottex
@paragraphindent 0
@end ifnottex
@titlepage
@title Form Input Bindings
@end titlepage

@node Top
@top Form Input Bindings

@node Basic Usage
@section Basic Usage
@anchor{#basic-usage}
You can use the @code{v-model} directive to create two-way data bindings
on form input, textarea, and select elements. It automatically picks the
correct way to update the element based on the input type. Although a
bit magical, @code{v-model} is essentially syntax sugar for updating
data on user input events, plus special care for some edge cases.

@code{v-model} will ignore the initial @code{value}, @code{checked}, or
@code{selected} attributes found on any form elements. It will always
treat the Vue instance data as the source of truth. You should declare
the initial value on the JavaScript side, inside the @code{data} option
of your component.
@code{v-model} internally uses different properties and emits different
events for different input elements: - text and textarea elements use
@code{value} property and @code{input} event; - checkboxes and
radiobuttons use @code{checked} property and @code{change} event; -
select fields use @code{value} as a prop and @code{change} as an event.

For languages that require an
@uref{https://en.wikipedia.org/wiki/Input_method,IME} (Chinese,
Japanese, Korean, etc.), you'll notice that @code{v-model} doesn't get
updated during IME composition. If you want to cater to these updates as
well, use the @code{input} event instead.

@menu
* Text::
* Multiline text::
* Checkbox::
* Radio::
* Select::
@end menu

@node Text
@subsection Text
@anchor{#text}

@verbatim
<input v-model="message" placeholder="edit me">
<p>Message is: {{ message }}</p>
@end verbatim

@{% raw %@}
Message is: @{@{ message @}@}
@{% endraw %@}

@node Multiline text
@subsection Multiline text
@anchor{#multiline-text}

@verbatim
<span>Multiline message is:</span>
<p style="white-space: pre-line;">{{ message }}</p>
<br>
<textarea v-model="message" placeholder="add multiple lines"></textarea>
@end verbatim

@{% raw %@}
Multiline message is:
@{@{ message @}@}
@{% endraw %@}

@{% raw %@}
Interpolation on textareas (<textarea>@{@{text@}@}</textarea>) won't
work. Use v-model instead.
@{% endraw %@}

@node Checkbox
@subsection Checkbox
@anchor{#checkbox}
Single checkbox, boolean value:

@verbatim
<input type="checkbox" id="checkbox" v-model="checked">
<label for="checkbox">{{ checked }}</label>
@end verbatim

@{% raw %@}
@{@{ checked @}@}
@{% endraw %@}

Multiple checkboxes, bound to the same Array:

@verbatim
<input type="checkbox" id="jack" value="Jack" v-model="checkedNames">
<label for="jack">Jack</label>
<input type="checkbox" id="john" value="John" v-model="checkedNames">
<label for="john">John</label>
<input type="checkbox" id="mike" value="Mike" v-model="checkedNames">
<label for="mike">Mike</label>
<br>
<span>Checked names: {{ checkedNames }}</span>
@end verbatim

@verbatim
new Vue({
  el: '...',
  data: {
    checkedNames: []
  }
})
@end verbatim

@{% raw %@}
Jack John Mike Checked names: @{@{ checkedNames @}@}
@{% endraw %@}

@node Radio
@subsection Radio
@anchor{#radio}

@verbatim
<input type="radio" id="one" value="One" v-model="picked">
<label for="one">One</label>
<br>
<input type="radio" id="two" value="Two" v-model="picked">
<label for="two">Two</label>
<br>
<span>Picked: {{ picked }}</span>
@end verbatim

@{% raw %@}
One Two Picked: @{@{ picked @}@}
@{% endraw %@}

@node Select
@subsection Select
@anchor{#select}
Single select:

@verbatim
<select v-model="selected">
  <option disabled value="">Please select one</option>
  <option>A</option>
  <option>B</option>
  <option>C</option>
</select>
<span>Selected: {{ selected }}</span>
@end verbatim

@verbatim
new Vue({
  el: '...',
  data: {
    selected: ''
  }
})
@end verbatim

@{% raw %@}
Please select one A B C Selected: @{@{ selected @}@}
@{% endraw %@}

If the initial value of your @code{v-model} expression does not match
any of the options, the @code{<select>} element will render in an
``unselected'' state. On iOS, this will prevent the user from being able
to select the first item, because iOS does not fire a @code{change}
event in this case. It is therefore recommended to provide a
@code{disabled} option with an empty value, as demonstrated in the
example above.
Multiple select (bound to Array):

@verbatim
<select v-model="selected" multiple>
  <option>A</option>
  <option>B</option>
  <option>C</option>
</select>
<br>
<span>Selected: {{ selected }}</span>
@end verbatim

@{% raw %@}
A B C Selected: @{@{ selected @}@}
@{% endraw %@}

Dynamic options rendered with @code{v-for}:

@verbatim
<select v-model="selected">
  <option v-for="option in options" v-bind:value="option.value">
    {{ option.text }}
  </option>
</select>
<span>Selected: {{ selected }}</span>
@end verbatim

@verbatim
new Vue({
  el: '...',
  data: {
    selected: 'A',
    options: [
      { text: 'One', value: 'A' },
      { text: 'Two', value: 'B' },
      { text: 'Three', value: 'C' }
    ]
  }
})
@end verbatim

@{% raw %@}
@{@{ option.text @}@} Selected: @{@{ selected @}@}
@{% endraw %@}

@node Value Bindings
@section Value Bindings
@anchor{#value-bindings}
For radio, checkbox and select options, the @code{v-model} binding
values are usually static strings (or booleans for checkboxes):

@verbatim
<!-- `picked` is a string "a" when checked -->
<input type="radio" v-model="picked" value="a">

<!-- `toggle` is either true or false -->
<input type="checkbox" v-model="toggle">

<!-- `selected` is a string "abc" when the first option is selected -->
<select v-model="selected">
  <option value="abc">ABC</option>
</select>
@end verbatim

But sometimes, we may want to bind the value to a dynamic property on
the Vue instance. We can use @code{v-bind} to achieve that. In addition,
using @code{v-bind} allows us to bind the input value to non-string
values.

@menu
* Checkbox::
* Radio::
* Select Options::
@end menu

@node Checkbox
@subsection Checkbox
@anchor{#checkbox-1}

@verbatim
<input
  type="checkbox"
  v-model="toggle"
  true-value="yes"
  false-value="no"
>
@end verbatim

@verbatim
// when checked:
vm.toggle === 'yes'
// when unchecked:
vm.toggle === 'no'
@end verbatim

The @code{true-value} and @code{false-value} attributes don't affect the
input's @code{value} attribute, because browsers don't include unchecked
boxes in form submissions. To guarantee that one of two values is
submitted in a form (i.e.@ ``yes'' or ``no''), use radio inputs instead.

@node Radio
@subsection Radio
@anchor{#radio-1}

@verbatim
<input type="radio" v-model="pick" v-bind:value="a">
@end verbatim

@verbatim
// when checked:
vm.pick === vm.a
@end verbatim

@node Select Options
@subsection Select Options
@anchor{#select-options}

@verbatim
<select v-model="selected">
  <!-- inline object literal -->
  <option v-bind:value="{ number: 123 }">123</option>
</select>
@end verbatim

@verbatim
// when selected:
typeof vm.selected // => 'object'
vm.selected.number // => 123
@end verbatim

@node Modifiers
@section Modifiers
@anchor{#modifiers}

@menu
* lazy::
* number::
* trim::
@end menu

@node lazy
@subsection @code{.lazy}
@anchor{#lazy}
By default, @code{v-model} syncs the input with the data after each
@code{input} event (with the exception of IME composition, as
@ref{#vmodel-ime-tip,stated above}). You can add the @code{lazy}
modifier to instead sync @emph{after} @code{change} events:

@verbatim
<!-- synced after "change" instead of "input" -->
<input v-model.lazy="msg">
@end verbatim

@node number
@subsection @code{.number}
@anchor{#number}
If you want user input to be automatically typecast as a Number, you can
add the @code{number} modifier to your @code{v-model} managed inputs:

@verbatim
<input v-model.number="age" type="number">
@end verbatim

This is often useful, because even with @code{type="number"}, the value
of HTML input elements always returns a string. If the value cannot be
parsed with @code{parseFloat()}, then the original value is returned.

@node trim
@subsection @code{.trim}
@anchor{#trim}
If you want whitespace from user input to be trimmed automatically, you
can add the @code{trim} modifier to your @code{v-model}-managed inputs:

@verbatim
<input v-model.trim="msg">
@end verbatim

@node v-model with Components
@section @code{v-model} with Components
@anchor{#v-model-with-components}
@quotation
If you're not yet familiar with Vue's components, you can skip this for
now.
@end quotation
HTML's built-in input types won't always meet your needs. Fortunately,
Vue components allow you to build reusable inputs with completely
customized behavior. These inputs even work with @code{v-model}!

To learn more, read about
@uref{components.html#Using-v-model-on-Components,custom inputs} in the
Components guide.

@bye
