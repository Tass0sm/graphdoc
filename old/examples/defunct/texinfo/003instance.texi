\input texinfo
@documentencoding UTF-8

@ifnottex
@paragraphindent 0
@end ifnottex
@titlepage
@title The Vue Instance
@end titlepage

@node Top
@top The Vue Instance

@node Creating a Vue Instance
@section Creating a Vue Instance
@anchor{#creating-a-vue-instance}
Every Vue application starts by creating a new @strong{Vue instance}
with the @code{Vue} function:

@verbatim
var vm = new Vue({
  // options
})
@end verbatim

Although not strictly associated with the
@uref{https://en.wikipedia.org/wiki/Model_View_ViewModel,MVVM pattern},
Vue's design was partly inspired by it. As a convention, we often use
the variable @code{vm} (short for ViewModel) to refer to our Vue
instance.

When you create a Vue instance, you pass in an @strong{options object}.
The majority of this guide describes how you can use these options to
create your desired behavior. For reference, you can also browse the
full list of options in the @uref{../api/#Options-Data,API reference}.

A Vue application consists of a @strong{root Vue instance} created with
@code{new Vue}, optionally organized into a tree of nested, reusable
components. For example, a todo app's component tree might look like
this:

@verbatim
Root Instance
└─ TodoList
   ├─ TodoItem
   │  ├─ TodoButtonDelete
   │  └─ TodoButtonEdit
   └─ TodoListFooter
      ├─ TodosButtonClear
      └─ TodoListStatistics
@end verbatim

We'll talk about @uref{components.html,the component system} in detail
later. For now, just know that all Vue components are also Vue
instances, and so accept the same options object (except for a few
root-specific options).

@node Data and Methods
@section Data and Methods
@anchor{#data-and-methods}
When a Vue instance is created, it adds all the properties found in its
@code{data} object to Vue's @strong{reactivity system}. When the values
of those properties change, the view will ``react'', updating to match
the new values.

@verbatim
// Our data object
var data = { a: 1 }

// The object is added to a Vue instance
var vm = new Vue({
  data: data
})

// Getting the property on the instance
// returns the one from the original data
vm.a == data.a // => true

// Setting the property on the instance
// also affects the original data
vm.a = 2
data.a // => 2

// ... and vice-versa
data.a = 3
vm.a // => 3
@end verbatim

When this data changes, the view will re-render. It should be noted that
properties in @code{data} are only @strong{reactive} if they existed
when the instance was created. That means if you add a new property,
like:

@verbatim
vm.b = 'hi'
@end verbatim

Then changes to @code{b} will not trigger any view updates. If you know
you'll need a property later, but it starts out empty or non-existent,
you'll need to set some initial value. For example:

@verbatim
data: {
  newTodoText: '',
  visitCount: 0,
  hideCompletedTodos: false,
  todos: [],
  error: null
}
@end verbatim

The only exception to this being the use of @code{Object.freeze()},
which prevents existing properties from being changed, which also means
the reactivity system can't @emph{track} changes.

@verbatim
var obj = {
  foo: 'bar'
}

Object.freeze(obj)

new Vue({
  el: '#app',
  data: obj
})
@end verbatim

@verbatim
<div id="app">
  <p>{{ foo }}</p>
  <!-- this will no longer update `foo`! -->
  <button v-on:click="foo = 'baz'">Change it</button>
</div>
@end verbatim

In addition to data properties, Vue instances expose a number of useful
instance properties and methods. These are prefixed with @code{$} to
differentiate them from user-defined properties. For example:

@verbatim
var data = { a: 1 }
var vm = new Vue({
  el: '#example',
  data: data
})

vm.$data === data // => true
vm.$el === document.getElementById('example') // => true

// $watch is an instance method
vm.$watch('a', function (newValue, oldValue) {
  // This callback will be called when `vm.a` changes
})
@end verbatim

In the future, you can consult the @uref{../api/#Instance-Properties,API
reference} for a full list of instance properties and methods.

@node Instance Lifecycle Hooks
@section Instance Lifecycle Hooks
@anchor{#instance-lifecycle-hooks}
Watch a free lesson on Vue School
Each Vue instance goes through a series of initialization steps when
it's created - for example, it needs to set up data observation, compile
the template, mount the instance to the DOM, and update the DOM when
data changes. Along the way, it also runs functions called
@strong{lifecycle hooks}, giving users the opportunity to add their own
code at specific stages.

For example, the @uref{../api/#created,@code{created}} hook can be used
to run code after an instance is created:

@verbatim
new Vue({
  data: {
    a: 1
  },
  created: function () {
    // `this` points to the vm instance
    console.log('a is: ' + this.a)
  }
})
// => "a is: 1"
@end verbatim

There are also other hooks which will be called at different stages of
the instance's lifecycle, such as @uref{../api/#mounted,@code{mounted}},
@uref{../api/#updated,@code{updated}}, and
@uref{../api/#destroyed,@code{destroyed}}. All lifecycle hooks are
called with their @code{this} context pointing to the Vue instance
invoking it.

Don't use
@uref{https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions,arrow
functions} on an options property or callback, such as
@code{created: () => console.log(this.a)} or
@code{vm.$watch('a', newValue => this.myMethod())}. Since an arrow
function doesn't have a @code{this}, @code{this} will be treated as any
other variable and lexically looked up through parent scopes until
found, often resulting in errors such as
@code{Uncaught TypeError: Cannot read property of undefined} or
@code{Uncaught TypeError: this.myMethod is not a function}.

@node Lifecycle Diagram
@section Lifecycle Diagram
@anchor{#lifecycle-diagram}
Below is a diagram for the instance lifecycle. You don't need to fully
understand everything going on right now, but as you learn and build
more, it will be a useful reference.

@float
@image{/images/lifecycle,,,The Vue Instance Lifecycle,png}
@caption{The Vue Instance Lifecycle}
@end float

@bye
