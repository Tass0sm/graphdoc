\input texinfo
@documentencoding UTF-8

@ifnottex
@paragraphindent 0
@end ifnottex
@titlepage
@title Template Syntax
@end titlepage

@node Top
@top Template Syntax

Vue.js uses an HTML-based template syntax that allows you to
declaratively bind the rendered DOM to the underlying Vue instance's
data. All Vue.js templates are valid HTML that can be parsed by
spec-compliant browsers and HTML parsers.

Under the hood, Vue compiles the templates into Virtual DOM render
functions. Combined with the reactivity system, Vue is able to
intelligently figure out the minimal number of components to re-render
and apply the minimal amount of DOM manipulations when the app state
changes.

If you are familiar with Virtual DOM concepts and prefer the raw power
of JavaScript, you can also @uref{render-function.html,directly write
render functions} instead of templates, with optional JSX support.

@node Interpolations
@section Interpolations
@anchor{#interpolations}

@menu
* Text::
* Raw HTML::
* Attributes::
* Using JavaScript Expressions::
@end menu

@node Text
@subsection Text
@anchor{#text}
The most basic form of data binding is text interpolation using the
``Mustache'' syntax (double curly braces):

@verbatim
<span>Message: {{ msg }}</span>
@end verbatim

The mustache tag will be replaced with the value of the @code{msg}
property on the corresponding data object. It will also be updated
whenever the data object's @code{msg} property changes.

You can also perform one-time interpolations that do not update on data
change by using the @uref{../api/#v-once,v-once directive}, but keep in
mind this will also affect any other bindings on the same node:

@verbatim
<span v-once>This will never change: {{ msg }}</span>
@end verbatim

@node Raw HTML
@subsection Raw HTML
@anchor{#raw-html}
The double mustaches interprets the data as plain text, not HTML. In
order to output real HTML, you will need to use the
@uref{../api/#v-html,@code{v-html} directive}:

@verbatim
<p>Using mustaches: {{ rawHtml }}</p>
<p>Using v-html directive: <span v-html="rawHtml"></span></p>
@end verbatim

@{% raw %@}
Using mustaches: @{@{ rawHtml @}@}
Using v-html directive:
@{% endraw %@}

The contents of the @code{span} will be replaced with the value of the
@code{rawHtml} property, interpreted as plain HTML - data bindings are
ignored. Note that you cannot use @code{v-html} to compose template
partials, because Vue is not a string-based templating engine. Instead,
components are preferred as the fundamental unit for UI reuse and
composition.

Dynamically rendering arbitrary HTML on your website can be very
dangerous because it can easily lead to
@uref{https://en.wikipedia.org/wiki/Cross-site_scripting,XSS
vulnerabilities}. Only use HTML interpolation on trusted content and
@strong{never} on user-provided content.

@node Attributes
@subsection Attributes
@anchor{#attributes}
Mustaches cannot be used inside HTML attributes. Instead, use a
@uref{../api/#v-bind,@code{v-bind} directive}:

@verbatim
<div v-bind:id="dynamicId"></div>
@end verbatim

In the case of boolean attributes, where their mere existence implies
@code{true}, @code{v-bind} works a little differently. In this example:

@verbatim
<button v-bind:disabled="isButtonDisabled">Button</button>
@end verbatim

If @code{isButtonDisabled} has the value of @code{null},
@code{undefined}, or @code{false}, the @code{disabled} attribute will
not even be included in the rendered @code{<button>} element.

@node Using JavaScript Expressions
@subsection Using JavaScript Expressions
@anchor{#using-javascript-expressions}
So far we've only been binding to simple property keys in our templates.
But Vue.js actually supports the full power of JavaScript expressions
inside all data bindings:

@verbatim
{{ number + 1 }}

{{ ok ? 'YES' : 'NO' }}

{{ message.split('').reverse().join('') }}

<div v-bind:id="'list-' + id"></div>
@end verbatim

These expressions will be evaluated as JavaScript in the data scope of
the owner Vue instance. One restriction is that each binding can only
contain @strong{one single expression}, so the following will
@strong{NOT} work:

@verbatim
<!-- this is a statement, not an expression: -->
{{ var a = 1 }}

<!-- flow control won't work either, use ternary expressions -->
{{ if (ok) { return message } }}
@end verbatim

Template expressions are sandboxed and only have access to a
@uref{https://github.com/vuejs/vue/blob/v2.6.10/src/core/instance/proxy.js#L9,whitelist
of globals} such as @code{Math} and @code{Date}. You should not attempt
to access user-defined globals in template expressions.

@node Directives
@section Directives
@anchor{#directives}
Directives are special attributes with the @code{v-} prefix. Directive
attribute values are expected to be @strong{a single JavaScript
expression} (with the exception of @code{v-for}, which will be discussed
later). A directive's job is to reactively apply side effects to the DOM
when the value of its expression changes. Let's review the example we
saw in the introduction:

@verbatim
<p v-if="seen">Now you see me</p>
@end verbatim

Here, the @code{v-if} directive would remove/insert the @code{<p>}
element based on the truthiness of the value of the expression
@code{seen}.

@menu
* Arguments::
* Dynamic Arguments::
* Modifiers::
@end menu

@node Arguments
@subsection Arguments
@anchor{#arguments}
Some directives can take an ``argument'', denoted by a colon after the
directive name. For example, the @code{v-bind} directive is used to
reactively update an HTML attribute:

@verbatim
<a v-bind:href="url"> ... </a>
@end verbatim

Here @code{href} is the argument, which tells the @code{v-bind}
directive to bind the element's @code{href} attribute to the value of
the expression @code{url}.

Another example is the @code{v-on} directive, which listens to DOM
events:

@verbatim
<a v-on:click="doSomething"> ... </a>
@end verbatim

Here the argument is the event name to listen to. We will talk about
event handling in more detail too.

@node Dynamic Arguments
@subsection Dynamic Arguments
@anchor{#dynamic-arguments}
@quotation
New in 2.6.0+
@end quotation
Starting in version 2.6.0, it is also possible to use a JavaScript
expression in a directive argument by wrapping it with square brackets:

@verbatim
<!--
Note that there are some constraints to the argument expression, as explained
in the "Dynamic Argument Expression Constraints" section below.
-->
<a v-bind:[attributeName]="url"> ... </a>
@end verbatim

Here @code{attributeName} will be dynamically evaluated as a JavaScript
expression, and its evaluated value will be used as the final value for
the argument. For example, if your Vue instance has a data property,
@code{attributeName}, whose value is @code{"href"}, then this binding
will be equivalent to @code{v-bind:href}.

Similarly, you can use dynamic arguments to bind a handler to a dynamic
event name:

@verbatim
<a v-on:[eventName]="doSomething"> ... </a>
@end verbatim

In this example, when @code{eventName}'s value is @code{"focus"},
@code{v-on:[eventName]} will be equivalent to @code{v-on:focus}.

@menu
* Dynamic Argument Value Constraints::
* Dynamic Argument Expression Constraints::
@end menu

@node Dynamic Argument Value Constraints
@subsubsection Dynamic Argument Value Constraints
@anchor{#dynamic-argument-value-constraints}
Dynamic arguments are expected to evaluate to a string, with the
exception of @code{null}. The special value @code{null} can be used to
explicitly remove the binding. Any other non-string value will trigger a
warning.

@node Dynamic Argument Expression Constraints
@subsubsection Dynamic Argument Expression Constraints
@anchor{#dynamic-argument-expression-constraints}
Dynamic argument expressions have some syntax constraints because
certain characters, such as spaces and quotes, are invalid inside HTML
attribute names. For example, the following is invalid:

@verbatim
<!-- This will trigger a compiler warning. -->
<a v-bind:['foo' + bar]="value"> ... </a>
@end verbatim

The workaround is to either use expressions without spaces or quotes, or
replace the complex expression with a computed property.

When using in-DOM templates (i.e., templates written directly in an HTML
file), you should also avoid naming keys with uppercase characters, as
browsers will coerce attribute names into lowercase:

@verbatim
<!--
This will be converted to v-bind:[someattr] in in-DOM templates.
Unless you have a "someattr" property in your instance, your code won't work.
-->
<a v-bind:[someAttr]="value"> ... </a>
@end verbatim

@node Modifiers
@subsection Modifiers
@anchor{#modifiers}
Modifiers are special postfixes denoted by a dot, which indicate that a
directive should be bound in some special way. For example, the
@code{.prevent} modifier tells the @code{v-on} directive to call
@code{event.preventDefault()} on the triggered event:

@verbatim
<form v-on:submit.prevent="onSubmit"> ... </form>
@end verbatim

You'll see other examples of modifiers later,
@uref{events.html#Event-Modifiers,for @code{v-on}} and
@uref{forms.html#Modifiers,for @code{v-model}}, when we explore those
features.

@node Shorthands
@section Shorthands
@anchor{#shorthands}
The @code{v-} prefix serves as a visual cue for identifying Vue-specific
attributes in your templates. This is useful when you are using Vue.js
to apply dynamic behavior to some existing markup, but can feel verbose
for some frequently used directives. At the same time, the need for the
@code{v-} prefix becomes less important when you are building a
@uref{https://en.wikipedia.org/wiki/Single-page_application,SPA}, where
Vue manages every template. Therefore, Vue provides special shorthands
for two of the most often used directives, @code{v-bind} and
@code{v-on}:

@menu
* v-bind Shorthand::
* v-on Shorthand::
@end menu

@node v-bind Shorthand
@subsection @code{v-bind} Shorthand
@anchor{#v-bind-shorthand}

@verbatim
<!-- full syntax -->
<a v-bind:href="url"> ... </a>

<!-- shorthand -->
<a :href="url"> ... </a>

<!-- shorthand with dynamic argument (2.6.0+) -->
<a :[key]="url"> ... </a>
@end verbatim

@node v-on Shorthand
@subsection @code{v-on} Shorthand
@anchor{#v-on-shorthand}

@verbatim
<!-- full syntax -->
<a v-on:click="doSomething"> ... </a>

<!-- shorthand -->
<a @click="doSomething"> ... </a>

<!-- shorthand with dynamic argument (2.6.0+) -->
<a @[event]="doSomething"> ... </a>
@end verbatim

They may look a bit different from normal HTML, but @code{:} and
@code{@@} are valid characters for attribute names and all Vue-supported
browsers can parse it correctly. In addition, they do not appear in the
final rendered markup. The shorthand syntax is totally optional, but you
will likely appreciate it when you learn more about its usage later.

@bye
