\input texinfo
@documentencoding UTF-8

@ifnottex
@paragraphindent 0
@end ifnottex
@titlepage
@title Slots
@end titlepage

@node Top
@top Slots

@quotation
This page assumes you've already read the
@uref{components.html,Components Basics}. Read that first if you are new
to components.
@end quotation
@quotation
In 2.6.0, we introduced a new unified syntax (the @code{v-slot}
directive) for named and scoped slots. It replaces the @code{slot} and
@code{slot-scope} attributes, which are now deprecated, but have
@emph{not} been removed and are still documented
@ref{#Deprecated-Syntax,here}. The rationale for introducing the new
syntax is described in this
@uref{https://github.com/vuejs/rfcs/blob/master/active-rfcs/0001-new-slot-syntax.md,RFC}.
@end quotation

@node Slot Content
@section Slot Content
@anchor{#slot-content}
Vue implements a content distribution API inspired by the
@uref{https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md,Web
Components spec draft}, using the @code{<slot>} element to serve as
distribution outlets for content.

This allows you to compose components like this:

@verbatim
<navigation-link url="/profile">
  Your Profile
</navigation-link>
@end verbatim

Then in the template for @code{<navigation-link>}, you might have:

@verbatim
<a
  v-bind:href="url"
  class="nav-link"
>
  <slot></slot>
</a>
@end verbatim

When the component renders, @code{<slot></slot>} will be replaced by
``Your Profile''. Slots can contain any template code, including HTML:

@verbatim
<navigation-link url="/profile">
  <!-- Add a Font Awesome icon -->
  <span class="fa fa-user"></span>
  Your Profile
</navigation-link>
@end verbatim

Or even other components:

@verbatim
<navigation-link url="/profile">
  <!-- Use a component to add an icon -->
  <font-awesome-icon name="user"></font-awesome-icon>
  Your Profile
</navigation-link>
@end verbatim

If @code{<navigation-link>}'s template did @strong{not} contain a
@code{<slot>} element, any content provided between its opening and
closing tag would be discarded.

@node Compilation Scope
@section Compilation Scope
@anchor{#compilation-scope}
When you want to use data inside a slot, such as in:

@verbatim
<navigation-link url="/profile">
  Logged in as {{ user.name }}
</navigation-link>
@end verbatim

That slot has access to the same instance properties (i.e.@ the same
``scope'') as the rest of the template. The slot does @strong{not} have
access to @code{<navigation-link>}'s scope. For example, trying to
access @code{url} would not work:

@verbatim
<navigation-link url="/profile">
  Clicking here will send you to: {{ url }}
  <!--
  The `url` will be undefined, because this content is passed
  _to_ <navigation-link>, rather than defined _inside_ the
  <navigation-link> component.
  -->
</navigation-link>
@end verbatim

As a rule, remember that:

@quotation
Everything in the parent template is compiled in parent scope;
everything in the child template is compiled in the child scope.
@end quotation

@node Fallback Content
@section Fallback Content
@anchor{#fallback-content}
There are cases when it's useful to specify fallback (i.e.@ default)
content for a slot, to be rendered only when no content is provided. For
example, in a @code{<submit-button>} component:

@verbatim
<button type="submit">
  <slot></slot>
</button>
@end verbatim

We might want the text ``Submit'' to be rendered inside the
@code{<button>} most of the time. To make ``Submit'' the fallback
content, we can place it in between the @code{<slot>} tags:

@verbatim
<button type="submit">
  <slot>Submit</slot>
</button>
@end verbatim

Now when we use @code{<submit-button>} in a parent component, providing
no content for the slot:

@verbatim
<submit-button></submit-button>
@end verbatim

will render the fallback content, ``Submit'':

@verbatim
<button type="submit">
  Submit
</button>
@end verbatim

But if we provide content:

@verbatim
<submit-button>
  Save
</submit-button>
@end verbatim

Then the provided content will be rendered instead:

@verbatim
<button type="submit">
  Save
</button>
@end verbatim

@node Named Slots
@section Named Slots
@anchor{#named-slots}
@quotation
Updated in 2.6.0+. @ref{#Deprecated-Syntax,See here} for the deprecated
syntax using the @code{slot} attribute.
@end quotation
There are times when it's useful to have multiple slots. For example, in
a @code{<base-layout>} component with the following template:

@verbatim
<div class="container">
  <header>
    <!-- We want header content here -->
  </header>
  <main>
    <!-- We want main content here -->
  </main>
  <footer>
    <!-- We want footer content here -->
  </footer>
</div>
@end verbatim

For these cases, the @code{<slot>} element has a special attribute,
@code{name}, which can be used to define additional slots:

@verbatim
<div class="container">
  <header>
    <slot name="header"></slot>
  </header>
  <main>
    <slot></slot>
  </main>
  <footer>
    <slot name="footer"></slot>
  </footer>
</div>
@end verbatim

A @code{<slot>} outlet without @code{name} implicitly has the name
``default''.

To provide content to named slots, we can use the @code{v-slot}
directive on a @code{<template>}, providing the name of the slot as
@code{v-slot}'s argument:

@verbatim
<base-layout>
  <template v-slot:header>
    <h1>Here might be a page title</h1>
  </template>

  <p>A paragraph for the main content.</p>
  <p>And another one.</p>

  <template v-slot:footer>
    <p>Here's some contact info</p>
  </template>
</base-layout>
@end verbatim

Now everything inside the @code{<template>} elements will be passed to
the corresponding slots. Any content not wrapped in a @code{<template>}
using @code{v-slot} is assumed to be for the default slot.

However, you can still wrap default slot content in a @code{<template>}
if you wish to be explicit:

@verbatim
<base-layout>
  <template v-slot:header>
    <h1>Here might be a page title</h1>
  </template>

  <template v-slot:default>
    <p>A paragraph for the main content.</p>
    <p>And another one.</p>
  </template>

  <template v-slot:footer>
    <p>Here's some contact info</p>
  </template>
</base-layout>
@end verbatim

Either way, the rendered HTML will be:

@verbatim
<div class="container">
  <header>
    <h1>Here might be a page title</h1>
  </header>
  <main>
    <p>A paragraph for the main content.</p>
    <p>And another one.</p>
  </main>
  <footer>
    <p>Here's some contact info</p>
  </footer>
</div>
@end verbatim

Note that @strong{@code{v-slot} can only be added to a
@code{<template>}} (with
@ref{#Abbreviated-Syntax-for-Lone-Default-Slots,one exception}), unlike
the deprecated @ref{#Deprecated-Syntax,@code{slot} attribute}.

@node Scoped Slots
@section Scoped Slots
@anchor{#scoped-slots}
@quotation
Updated in 2.6.0+. @ref{#Deprecated-Syntax,See here} for the deprecated
syntax using the @code{slot-scope} attribute.
@end quotation
Sometimes, it's useful for slot content to have access to data only
available in the child component. For example, imagine a
@code{<current-user>} component with the following template:

@verbatim
<span>
  <slot>{{ user.lastName }}</slot>
</span>
@end verbatim

We might want to replace this fallback content to display the user's
first name, instead of last, like this:

@verbatim
<current-user>
  {{ user.firstName }}
</current-user>
@end verbatim

That won't work, however, because only the @code{<current-user>}
component has access to the @code{user} and the content we're providing
is rendered in the parent.

To make @code{user} available to the slot content in the parent, we can
bind @code{user} as an attribute to the @code{<slot>} element:

@verbatim
<span>
  <slot v-bind:user="user">
    {{ user.lastName }}
  </slot>
</span>
@end verbatim

Attributes bound to a @code{<slot>} element are called @strong{slot
props}. Now, in the parent scope, we can use @code{v-slot} with a value
to define a name for the slot props we've been provided:

@verbatim
<current-user>
  <template v-slot:default="slotProps">
    {{ slotProps.user.firstName }}
  </template>
</current-user>
@end verbatim

In this example, we've chosen to name the object containing all our slot
props @code{slotProps}, but you can use any name you like.

@menu
* Abbreviated Syntax for Lone Default Slots::
* Destructuring Slot Props::
@end menu

@node Abbreviated Syntax for Lone Default Slots
@subsection Abbreviated Syntax for Lone Default Slots
@anchor{#abbreviated-syntax-for-lone-default-slots}
In cases like above, when @emph{only} the default slot is provided
content, the component's tags can be used as the slot's template. This
allows us to use @code{v-slot} directly on the component:

@verbatim
<current-user v-slot:default="slotProps">
  {{ slotProps.user.firstName }}
</current-user>
@end verbatim

This can be shortened even further. Just as non-specified content is
assumed to be for the default slot, @code{v-slot} without an argument is
assumed to refer to the default slot:

@verbatim
<current-user v-slot="slotProps">
  {{ slotProps.user.firstName }}
</current-user>
@end verbatim

Note that the abbreviated syntax for default slot @strong{cannot} be
mixed with named slots, as it would lead to scope ambiguity:

@verbatim
<!-- INVALID, will result in warning -->
<current-user v-slot="slotProps">
  {{ slotProps.user.firstName }}
  <template v-slot:other="otherSlotProps">
    slotProps is NOT available here
  </template>
</current-user>
@end verbatim

Whenever there are multiple slots, use the full @code{<template>} based
syntax for @emph{all} slots:

@verbatim
<current-user>
  <template v-slot:default="slotProps">
    {{ slotProps.user.firstName }}
  </template>

  <template v-slot:other="otherSlotProps">
    ...
  </template>
</current-user>
@end verbatim

@node Destructuring Slot Props
@subsection Destructuring Slot Props
@anchor{#destructuring-slot-props}
Internally, scoped slots work by wrapping your slot content in a
function passed a single argument:

@verbatim
function (slotProps) {
  // ... slot content ...
}
@end verbatim

That means the value of @code{v-slot} can actually accept any valid
JavaScript expression that can appear in the argument position of a
function definition. So in supported environments
(@uref{single-file-components.html,single-file components} or
@uref{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Browser_compatibility,modern
browsers}), you can also use
@uref{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Object_destructuring,ES2015
destructuring} to pull out specific slot props, like so:

@verbatim
<current-user v-slot="{ user }">
  {{ user.firstName }}
</current-user>
@end verbatim

This can make the template much cleaner, especially when the slot
provides many props. It also opens other possibilities, such as renaming
props, e.g.@ @code{user} to @code{person}:

@verbatim
<current-user v-slot="{ user: person }">
  {{ person.firstName }}
</current-user>
@end verbatim

You can even define fallbacks, to be used in case a slot prop is
undefined:

@verbatim
<current-user v-slot="{ user = { firstName: 'Guest' } }">
  {{ user.firstName }}
</current-user>
@end verbatim

@node Dynamic Slot Names
@section Dynamic Slot Names
@anchor{#dynamic-slot-names}
@quotation
New in 2.6.0+
@end quotation
@uref{syntax.html#Dynamic-Arguments,Dynamic directive arguments} also
work on @code{v-slot}, allowing the definition of dynamic slot names:

@verbatim
<base-layout>
  <template v-slot:[dynamicSlotName]>
    ...
  </template>
</base-layout>
@end verbatim

@node Named Slots Shorthand
@section Named Slots Shorthand
@anchor{#named-slots-shorthand}
@quotation
New in 2.6.0+
@end quotation
Similar to @code{v-on} and @code{v-bind}, @code{v-slot} also has a
shorthand, replacing everything before the argument (@code{v-slot:})
with the special symbol @code{#}. For example, @code{v-slot:header} can
be rewritten as @code{#header}:

@verbatim
<base-layout>
  <template #header>
    <h1>Here might be a page title</h1>
  </template>

  <p>A paragraph for the main content.</p>
  <p>And another one.</p>

  <template #footer>
    <p>Here's some contact info</p>
  </template>
</base-layout>
@end verbatim

However, just as with other directives, the shorthand is only available
when an argument is provided. That means the following syntax is
invalid:

@verbatim
<!-- This will trigger a warning -->
<current-user #="{ user }">
  {{ user.firstName }}
</current-user>
@end verbatim

Instead, you must always specify the name of the slot if you wish to use
the shorthand:

@verbatim
<current-user #default="{ user }">
  {{ user.firstName }}
</current-user>
@end verbatim

@node Other Examples
@section Other Examples
@anchor{#other-examples}
@strong{Slot props allow us to turn slots into reusable templates that
can render different content based on input props.} This is most useful
when you are designing a reusable component that encapsulates data logic
while allowing the consuming parent component to customize part of its
layout.

For example, we are implementing a @code{<todo-list>} component that
contains the layout and filtering logic for a list:

@verbatim
<ul>
  <li
    v-for="todo in filteredTodos"
    v-bind:key="todo.id"
  >
    {{ todo.text }}
  </li>
</ul>
@end verbatim

Instead of hard-coding the content for each todo, we can let the parent
component take control by making every todo a slot, then binding
@code{todo} as a slot prop:

@verbatim
<ul>
  <li
    v-for="todo in filteredTodos"
    v-bind:key="todo.id"
  >
    <!--
    We have a slot for each todo, passing it the
    `todo` object as a slot prop.
    -->
    <slot name="todo" v-bind:todo="todo">
      <!-- Fallback content -->
      {{ todo.text }}
    </slot>
  </li>
</ul>
@end verbatim

Now when we use the @code{<todo-list>} component, we can optionally
define an alternative @code{<template>} for todo items, but with access
to data from the child:

@verbatim
<todo-list v-bind:todos="todos">
  <template v-slot:todo="{ todo }">
    <span v-if="todo.isComplete">✓</span>
    {{ todo.text }}
  </template>
</todo-list>
@end verbatim

However, even this barely scratches the surface of what scoped slots are
capable of. For real-life, powerful examples of scoped slot usage, we
recommend browsing libraries such as
@uref{https://github.com/Akryum/vue-virtual-scroller,Vue Virtual
Scroller}, @uref{https://github.com/posva/vue-promised,Vue Promised},
and @uref{https://github.com/LinusBorg/portal-vue,Portal Vue}.

@node Deprecated Syntax
@section Deprecated Syntax
@anchor{#deprecated-syntax}
@quotation
The @code{v-slot} directive was introduced in Vue 2.6.0, offering an
improved, alternative API to the still-supported @code{slot} and
@code{slot-scope} attributes. The full rationale for introducing
@code{v-slot} is described in this
@uref{https://github.com/vuejs/rfcs/blob/master/active-rfcs/0001-new-slot-syntax.md,RFC}.
The @code{slot} and @code{slot-scope} attributes will continue to be
supported in all future 2.x releases, but are officially deprecated and
will eventually be removed in Vue 3.
@end quotation

@menu
* Named Slots with the slot Attribute::
* Scoped Slots with the slot-scope Attribute::
@end menu

@node Named Slots with the slot Attribute
@subsection Named Slots with the @code{slot} Attribute
@anchor{#named-slots-with-the-slot-attribute}
@quotation
Deprecated in 2.6.0+. See @ref{#Named-Slots,here} for the new,
recommended syntax.
@end quotation
To pass content to named slots from the parent, use the special
@code{slot} attribute on @code{<template>} (using the
@code{<base-layout>} component described @ref{#Named-Slots,here} as
example):

@verbatim
<base-layout>
  <template slot="header">
    <h1>Here might be a page title</h1>
  </template>

  <p>A paragraph for the main content.</p>
  <p>And another one.</p>

  <template slot="footer">
    <p>Here's some contact info</p>
  </template>
</base-layout>
@end verbatim

Or, the @code{slot} attribute can also be used directly on a normal
element:

@verbatim
<base-layout>
  <h1 slot="header">Here might be a page title</h1>

  <p>A paragraph for the main content.</p>
  <p>And another one.</p>

  <p slot="footer">Here's some contact info</p>
</base-layout>
@end verbatim

There can still be one unnamed slot, which is the @strong{default slot}
that serves as a catch-all for any unmatched content. In both examples
above, the rendered HTML would be:

@verbatim
<div class="container">
  <header>
    <h1>Here might be a page title</h1>
  </header>
  <main>
    <p>A paragraph for the main content.</p>
    <p>And another one.</p>
  </main>
  <footer>
    <p>Here's some contact info</p>
  </footer>
</div>
@end verbatim

@node Scoped Slots with the slot-scope Attribute
@subsection Scoped Slots with the @code{slot-scope} Attribute
@anchor{#scoped-slots-with-the-slot-scope-attribute}
@quotation
Deprecated in 2.6.0+. See @ref{#Scoped-Slots,here} for the new,
recommended syntax.
@end quotation
To receive props passed to a slot, the parent component can use
@code{<template>} with the @code{slot-scope} attribute (using the
@code{<slot-example>} described @ref{#Scoped-Slots,here} as example):

@verbatim
<slot-example>
  <template slot="default" slot-scope="slotProps">
    {{ slotProps.msg }}
  </template>
</slot-example>
@end verbatim

Here, @code{slot-scope} declares the received props object as the
@code{slotProps} variable, and makes it available inside the
@code{<template>} scope. You can name @code{slotProps} anything you like
similar to naming function arguments in JavaScript.

Here @code{slot="default"} can be omitted as it is implied:

@verbatim
<slot-example>
  <template slot-scope="slotProps">
    {{ slotProps.msg }}
  </template>
</slot-example>
@end verbatim

The @code{slot-scope} attribute can also be used directly on a
non-@code{<template>} element (including components):

@verbatim
<slot-example>
  <span slot-scope="slotProps">
    {{ slotProps.msg }}
  </span>
</slot-example>
@end verbatim

The value of @code{slot-scope} can accept any valid JavaScript
expression that can appear in the argument position of a function
definition. This means in supported environments
(@uref{single-file-components.html,single-file components} or
@uref{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Browser_compatibility,modern
browsers}) you can also use
@uref{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Object_destructuring,ES2015
destructuring} in the expression, like so:

@verbatim
<slot-example>
  <span slot-scope="{ msg }">
    {{ msg }}
  </span>
</slot-example>
@end verbatim

Using the @code{<todo-list>} described @ref{#Other-Examples,here} as an
example, here's the equivalent usage using @code{slot-scope}:

@verbatim
<todo-list v-bind:todos="todos">
  <template slot="todo" slot-scope="{ todo }">
    <span v-if="todo.isComplete">✓</span>
    {{ todo.text }}
  </template>
</todo-list>
@end verbatim

@bye
