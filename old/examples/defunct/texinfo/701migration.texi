\input texinfo
@documentencoding UTF-8

@ifnottex
@paragraphindent 0
@end ifnottex
@titlepage
@title Migration from Vue 1.x
@end titlepage

@node Top
@top Migration from Vue 1.x

@node FAQ
@section FAQ
@anchor{#faq}
@quotation
Woah - this is a super long page! Does that mean 2.0 is completely
different, I'll have to learn the basics all over again, and migrating
will be practically impossible?
@end quotation
I'm glad you asked! The answer is no. About 90% of the API is the same
and the core concepts haven't changed. It's long because we like to
offer very detailed explanations and include a lot of examples. Rest
assured, @strong{this is not something you have to read from top to
bottom!}

@quotation
Where should I start in a migration?
@end quotation
@enumerate 
@item
Start by running the
@uref{https://github.com/vuejs/vue-migration-helper,migration helper} on
a current project. We've carefully minified and compressed a senior Vue
dev into a simple command line interface. Whenever they recognize an
obsolete feature, they'll let you know, offer suggestions, and provide
links to more info.

@item
After that, browse through the table of contents for this page in the
sidebar. If you see a topic you may be affected by, but the migration
helper didn't catch, check it out.

@item
If you have any tests, run them and see what still fails. If you don't
have tests, just open the app in your browser and keep an eye out for
warnings or errors as you navigate around.

@item
By now, your app should be fully migrated. If you're still hungry for
more though, you can read the rest of this page - or dive in to the new
and improved guide from @uref{index.html,the beginning}. Many parts will
be skimmable, since you're already familiar with the core concepts.

@end enumerate

@quotation
How long will it take to migrate a Vue 1.x app to 2.0?
@end quotation
It depends on a few factors:

@itemize
@item
The size of your app (small to medium-sized apps will probably be less
than a day)

@item
How many times you get distracted and start playing with a cool new
feature. ðŸ˜‰ @ Not judging, it also happened to us while building 2.0!

@item
Which obsolete features you're using. Most can be upgraded with
find-and-replace, but others might take a few minutes. If you're not
currently following best practices, Vue 2.0 will also try harder to
force you to. This is a good thing in the long run, but could also mean
a significant (though possibly overdue) refactor.

@end itemize

@quotation
If I upgrade to Vue 2, will I also have to upgrade Vuex and Vue Router?
@end quotation
Only Vue Router 2 is compatible with Vue 2, so yes, you'll have to
follow the @uref{migration-vue-router.html,migration path for Vue
Router} as well. Fortunately, most applications don't have a lot of
router code, so this likely won't take more than an hour.

As for Vuex, even version 0.8 is compatible with Vue 2, so you're not
forced to upgrade. The only reason you may want to upgrade immediately
is to take advantage of the new features in Vuex 2, such as modules and
reduced boilerplate.

@node Templates
@section Templates
@anchor{#templates}

@menu
* Fragment Instances removed::
@end menu

@node Fragment Instances removed
@subsection Fragment Instances removed
@anchor{#fragment-instances-removed}
Every component must have exactly one root element. Fragment instances
are no longer allowed. If you have a template like this:

@verbatim
<p>foo</p>
<p>bar</p>
@end verbatim

It's recommended to wrap the entire contents in a new element, like
this:

@verbatim
<div>
  <p>foo</p>
  <p>bar</p>
</div>
@end verbatim

@{% raw %@}
Upgrade Path
Run your end-to-end test suite or app after upgrading and look for
console warnings about multiple root elements in a template.
@{% endraw %@}

@node Lifecycle Hooks
@section Lifecycle Hooks
@anchor{#lifecycle-hooks}

@menu
* beforeCompile removed::
* compiled replaced::
* attached removed::
* detached removed::
* init renamed::
* ready replaced::
@end menu

@node beforeCompile removed
@subsection @code{beforeCompile} removed
@anchor{#beforecompile-removed}
Use the @code{created} hook instead.

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find all examples of this
hook.
@{% endraw %@}

@node compiled replaced
@subsection @code{compiled} replaced
@anchor{#compiled-replaced}
Use the new @code{mounted} hook instead.

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find all examples of this
hook.
@{% endraw %@}

@node attached removed
@subsection @code{attached} removed
@anchor{#attached-removed}
Use a custom in-DOM check in other hooks. For example, to replace:

@verbatim
attached: function () {
  doSomething()
}
@end verbatim

You could use:

@verbatim
mounted: function () {
  this.$nextTick(function () {
    doSomething()
  })
}
@end verbatim

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find all examples of this
hook.
@{% endraw %@}

@node detached removed
@subsection @code{detached} removed
@anchor{#detached-removed}
Use a custom in-DOM check in other hooks. For example, to replace:

@verbatim
detached: function () {
  doSomething()
}
@end verbatim

You could use:

@verbatim
destroyed: function () {
  this.$nextTick(function () {
    doSomething()
  })
}
@end verbatim

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find all examples of this
hook.
@{% endraw %@}

@node init renamed
@subsection @code{init} renamed
@anchor{#init-renamed}
Use the new @code{beforeCreate} hook instead, which is essentially the
same thing. It was renamed for consistency with other lifecycle methods.

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find all examples of this
hook.
@{% endraw %@}

@node ready replaced
@subsection @code{ready} replaced
@anchor{#ready-replaced}
Use the new @code{mounted} hook instead. It should be noted though that
with @code{mounted}, there's no guarantee to be in-document. For that,
also include @code{Vue.nextTick}/@code{vm.$nextTick}. For example:

@verbatim
mounted: function () {
  this.$nextTick(function () {
    // code that assumes this.$el is in-document
  })
}
@end verbatim

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find all examples of this
hook.
@{% endraw %@}

@node v-for
@section @code{v-for}
@anchor{#v-for}

@menu
* v-for Argument Order for Arrays changed::
* v-for Argument Order for Objects changed::
* $index and $key removed::
* track-by replaced::
* v-for Range Values changed::
@end menu

@node v-for Argument Order for Arrays changed
@subsection @code{v-for} Argument Order for Arrays changed
@anchor{#v-for-argument-order-for-arrays-changed}
When including an @code{index}, the argument order for arrays used to be
@code{(index, value)}. It is now @code{(value, index)} to be more
consistent with JavaScript's native array methods such as @code{forEach}
and @code{map}.

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find examples of the
obsolete argument order. Note that if you name your index arguments
something unusual like position or num, the helper will not flag them.
@{% endraw %@}

@node v-for Argument Order for Objects changed
@subsection @code{v-for} Argument Order for Objects changed
@anchor{#v-for-argument-order-for-objects-changed}
When including a property name/key, the argument order for objects used
to be @code{(name, value)}. It is now @code{(value, name)} to be more
consistent with common object iterators such as lodash's.

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find examples of the
obsolete argument order. Note that if you name your key arguments
something like name or property, the helper will not flag them.
@{% endraw %@}

@node $index and $key removed
@subsection @code{$index} and @code{$key} removed
@anchor{#index-and-key-removed}
The implicitly assigned @code{$index} and @code{$key} variables have
been removed in favor of explicitly defining them in @code{v-for}. This
makes the code easier to read for developers less experienced with Vue
and also results in much clearer behavior when dealing with nested
loops.

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find examples of these
removed variables. If you miss any, you should also see console errors
such as: Uncaught ReferenceError: $index is not defined
@{% endraw %@}

@node track-by replaced
@subsection @code{track-by} replaced
@anchor{#track-by-replaced}
@code{track-by} has been replaced with @code{key}, which works like any
other attribute: without the @code{v-bind:} or @code{:} prefix, it is
treated as a literal string. In most cases, you'd want to use a dynamic
binding which expects a full expression instead of a key. For example,
in place of:

@{% codeblock lang:html %@}
@{% endcodeblock %@}

You would now write:

@{% codeblock lang:html %@}
@{% endcodeblock %@}

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find examples of track-by.
@{% endraw %@}

@node v-for Range Values changed
@subsection @code{v-for} Range Values changed
@anchor{#v-for-range-values-changed}
Previously, @code{v-for="number in 10"} would have @code{number}
starting at 0 and ending at 9. Now it starts at 1 and ends at 10.

@{% raw %@}
Upgrade Path
Search your codebase for the regex /@tex
\w
@end tex+ in @tex
\d+
@end tex/. Wherever it appears in a v-for, check to see if you may be
affected.
@{% endraw %@}

@node Props
@section Props
@anchor{#props}

@menu
* coerce Prop Option removed::
* twoWay Prop Option removed::
* once and sync Modifiers on v-bind removed::
* Prop Mutation deprecated::
* Props on a Root Instance replaced::
@end menu

@node coerce Prop Option removed
@subsection @code{coerce} Prop Option removed
@anchor{#coerce-prop-option-removed}
If you want to coerce a prop, setup a local computed value based on it
instead. For example, instead of:

@verbatim
props: {
  username: {
    type: String,
    coerce: function (value) {
      return value
        .toLowerCase()
        .replace(/\s+/, '-')
    }
  }
}
@end verbatim

You could write:

@verbatim
props: {
  username: String,
},
computed: {
  normalizedUsername: function () {
    return this.username
      .toLowerCase()
      .replace(/\s+/, '-')
  }
}
@end verbatim

There are a few advantages:

@itemize
@item
You still have access to the original value of the prop.
@item
You are forced to be more explicit, by giving your coerced value a name
that differentiates it from the value passed in the prop.
@end itemize

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find examples of the coerce
option.
@{% endraw %@}

@node twoWay Prop Option removed
@subsection @code{twoWay} Prop Option removed
@anchor{#twoway-prop-option-removed}
Props are now always one-way down. To produce side effects in the parent
scope, a component needs to explicitly emit an event instead of relying
on implicit binding. For more information, see:

@itemize
@item
@uref{components.html#Custom-Events,Custom component events}
@item
@uref{components.html#Form-Input-Components-using-Custom-Events,Custom
input components} (using component events)
@item
@uref{state-management.html,Global state management}
@end itemize

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find examples of the twoWay
option.
@{% endraw %@}

@node once and sync Modifiers on v-bind removed
@subsection @code{.once} and @code{.sync} Modifiers on @code{v-bind}
removed
@anchor{#once-and-.sync-modifiers-on-v-bind-removed}
Props are now always one-way down. To produce side effects in the parent
scope, a component needs to explicitly emit an event instead of relying
on implicit binding. For more information, see:

@itemize
@item
@uref{components.html#Custom-Events,Custom component events}
@item
@uref{components.html#Form-Input-Components-using-Custom-Events,Custom
input components} (using component events)
@item
@uref{state-management.html,Global state management}
@end itemize

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find examples of the .once
and .sync modifiers.
@{% endraw %@}

@node Prop Mutation deprecated
@subsection Prop Mutation deprecated
@anchor{#prop-mutation-deprecated}
Mutating a prop locally is now considered an anti-pattern,
e.g.@ declaring a prop and then setting
@code{this.myProp = 'someOtherValue'} in the component. Due to the new
rendering mechanism, whenever the parent component re-renders, the child
component's local changes will be overwritten.

Most use cases of mutating a prop can be replaced by one of these
options:

@itemize
@item
a data property, with the prop used to set its default value
@item
a computed property
@end itemize

@{% raw %@}
Upgrade Path
Run your end-to-end test suite or app after upgrading and look for
console warnings about prop mutations.
@{% endraw %@}

@node Props on a Root Instance replaced
@subsection Props on a Root Instance replaced
@anchor{#props-on-a-root-instance-replaced}
On root Vue instances (i.e.@ instances created with
@code{new Vue(@{ ... @})}), you must use @code{propsData} instead of
@code{props}.

@{% raw %@}
Upgrade Path
Run your end-to-end test suite, if you have one. The failed tests should
alert to you to the fact that props passed to root instances are no
longer working.
@{% endraw %@}

@node Computed properties
@section Computed properties
@anchor{#computed-properties}

@menu
* cache false deprecated::
@end menu

@node cache false deprecated
@subsection @code{cache: false} deprecated
@anchor{#cache-false-deprecated}
Caching invalidation of computed properties will be removed in future
major versions of Vue. Replace any uncached computed properties with
methods, which will have the same result.

For example:

@verbatim
template: '<p>message: {{ timeMessage }}</p>',
computed: {
  timeMessage: {
    cache: false,
    get: function () {
      return Date.now() + this.message
    }
  }
}
@end verbatim

Or with component methods:

@verbatim
template: '<p>message: {{ getTimeMessage() }}</p>',
methods: {
  getTimeMessage: function () {
    return Date.now() + this.message
  }
}
@end verbatim

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find examples of the cache:
false option.
@{% endraw %@}

@node Built-In Directives
@section Built-In Directives
@anchor{#built-in-directives}

@menu
* Truthiness/Falsiness with v-bind changed::
* Listening for Native Events on Components with v-on changed::
* debounce Param Attribute for v-model removed::
* lazy or number Param Attributes for v-model replaced::
* value Attribute with v-model removed::
* v-model with v-for Iterated Primitive Values removed::
* v-bindstyle with Object Syntax and !important removed::
* v-el and v-ref replaced::
* v-else with v-show removed::
@end menu

@node Truthiness/Falsiness with v-bind changed
@subsection Truthiness/Falsiness with @code{v-bind} changed
@anchor{#truthinessfalsiness-with-v-bind-changed}
When used with @code{v-bind}, the only falsy values are now:
@code{null}, @code{undefined}, and @code{false}. This means @code{0} and
empty strings will render as truthy. So for example,
@code{v-bind:draggable="''"} will render as @code{draggable="true"}.

For enumerated attributes, in addition to the falsy values above, the
string @code{"false"} will also render as @code{attr="false"}.

Note that for other directives (e.g.@ @code{v-if} and @code{v-show}),
JavaScript's normal truthiness still applies.
@{% raw %@}
Upgrade Path
Run your end-to-end test suite, if you have one. The failed tests should
alert to you to any parts of your app that may be affected by this
change.
@{% endraw %@}

@node Listening for Native Events on Components with v-on changed
@subsection Listening for Native Events on Components with @code{v-on}
changed
@anchor{#listening-for-native-events-on-components-with-v-on-changed}
When used on a component, @code{v-on} now only listens to custom events
@code{$emit}ted by that component. To listen for a native DOM event on
the root element, you can use the @code{.native} modifier. For example:

@{% codeblock lang:html %@} <my-component
v-on:click.native=``doSomething''> @{% endcodeblock %@}

@{% raw %@}
Upgrade Path
Run your end-to-end test suite, if you have one. The failed tests should
alert to you to any parts of your app that may be affected by this
change.
@{% endraw %@}

@node debounce Param Attribute for v-model removed
@subsection @code{debounce} Param Attribute for @code{v-model} removed
@anchor{#debounce-param-attribute-for-v-model-removed}
Debouncing is used to limit how often we execute Ajax requests and other
expensive operations. Vue's @code{debounce} attribute parameter for
@code{v-model} made this easy for very simple cases, but it actually
debounced @strong{state updates} rather than the expensive operations
themselves. It's a subtle difference, but it comes with limitations as
an application grows.

These limitations become apparent when designing a search indicator,
like this one for example:

@{% raw %@}
@{@{ searchIndicator @}@}
@{% endraw %@}

Using the @code{debounce} attribute, there'd be no way to detect the
``Typing'' state, because we lose access to the input's real-time state.
By decoupling the debounce function from Vue however, we're able to
debounce only the operation we want to limit, removing the limits on
features we can develop:

@verbatim
<!--
By using the debounce function from lodash or another dedicated
utility library, we know the specific debounce implementation we
use will be best-in-class - and we can use it ANYWHERE. Not only
in our template.
-->
<script src="https://cdn.jsdelivr.net/lodash/4.13.1/lodash.js"></script>
<div id="debounce-search-demo">
  <input v-model="searchQuery" placeholder="Type something">
  <strong>{{ searchIndicator }}</strong>
</div>
@end verbatim

@verbatim
new Vue({
  el: '#debounce-search-demo',
  data: {
    searchQuery: '',
    searchQueryIsDirty: false,
    isCalculating: false
  },
  computed: {
    searchIndicator: function () {
      if (this.isCalculating) {
        return 'âŸ³ Fetching new results'
      } else if (this.searchQueryIsDirty) {
        return '... Typing'
      } else {
        return 'âœ“ Done'
      }
    }
  },
  watch: {
    searchQuery: function () {
      this.searchQueryIsDirty = true
      this.expensiveOperation()
    }
  },
  methods: {
    // This is where the debounce actually belongs.
    expensiveOperation: _.debounce(function () {
      this.isCalculating = true
      setTimeout(function () {
        this.isCalculating = false
        this.searchQueryIsDirty = false
      }.bind(this), 1000)
    }, 500)
  }
})
@end verbatim

Another advantage of this approach is there will be times when
debouncing isn't quite the right wrapper function. For example, when
hitting an API for search suggestions, waiting to offer suggestions
until after the user has stopped typing for a period of time isn't an
ideal experience. What you probably want instead is a
@strong{throttling} function. Now since you're already using a utility
library like lodash, refactoring to use its @code{throttle} function
instead takes only a few seconds.

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find examples of the
debounce attribute.
@{% endraw %@}

@node lazy or number Param Attributes for v-model replaced
@subsection @code{lazy} or @code{number} Param Attributes for
@code{v-model} replaced
@anchor{#lazy-or-number-param-attributes-for-v-model-replaced}
The @code{lazy} and @code{number} param attributes are now modifiers, to
make it more clear what That means instead of:

@verbatim
<input v-model="name" lazy>
<input v-model="age" type="number" number>
@end verbatim

You would use:

@verbatim
<input v-model.lazy="name">
<input v-model.number="age" type="number">
@end verbatim

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find examples of the these
param attributes.
@{% endraw %@}

@node value Attribute with v-model removed
@subsection @code{value} Attribute with @code{v-model} removed
@anchor{#value-attribute-with-v-model-removed}
@code{v-model} no longer cares about the initial value of an inline
@code{value} attribute. For predictability, it will instead always treat
the Vue instance data as the source of truth.

That means this element:

@verbatim
<input v-model="text" value="foo">
@end verbatim

backed by this data:

@verbatim
data: {
  text: 'bar'
}
@end verbatim

will render with a value of ``bar'' instead of ``foo''. The same goes
for a @code{<textarea>} with existing content. Instead of:

@verbatim
<textarea v-model="text">
  hello world
</textarea>
@end verbatim

You should ensure your initial value for @code{text} is ``hello world''.

@{% raw %@}
Upgrade Path
Run your end-to-end test suite or app after upgrading and look for
console warnings about inline value attributes with v-model.
@{% endraw %@}

@node v-model with v-for Iterated Primitive Values removed
@subsection @code{v-model} with @code{v-for} Iterated Primitive Values
removed
@anchor{#v-model-with-v-for-iterated-primitive-values-removed}
Cases like this no longer work:

@verbatim
<input v-for="str in strings" v-model="str">
@end verbatim

The reason is this is the equivalent JavaScript that the @code{<input>}
would compile to:

@verbatim
strings.map(function (str) {
  return createElement('input', ...)
})
@end verbatim

As you can see, @code{v-model}'s two-way binding doesn't make sense
here. Setting @code{str} to another value in the iterator function will
do nothing because it's only a local variable in the function scope.

Instead, you should use an array of @strong{objects} so that
@code{v-model} can update the field on the object. For example:

@{% codeblock lang:html %@} @{% endcodeblock %@}

@{% raw %@}
Upgrade Path
Run your test suite, if you have one. The failed tests should alert to
you to any parts of your app that may be affected by this change.
@{% endraw %@}

@node v-bindstyle with Object Syntax and !important removed
@subsection @code{v-bind:style} with Object Syntax and @code{!important}
removed
@anchor{#v-bindstyle-with-object-syntax-and-important-removed}
This will no longer work:

@verbatim
<p v-bind:style="{ color: myColor + ' !important' }">hello</p>
@end verbatim

If you really need to override another @code{!important}, you must use
the string syntax:

@verbatim
<p v-bind:style="'color: ' + myColor + ' !important'">hello</p>
@end verbatim

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find examples of style
bindings with !important in objects.
@{% endraw %@}

@node v-el and v-ref replaced
@subsection @code{v-el} and @code{v-ref} replaced
@anchor{#v-el-and-v-ref-replaced}
For simplicity, @code{v-el} and @code{v-ref} have been merged into the
@code{ref} attribute, accessible on a component instance via
@code{$refs}. That means @code{v-el:my-element} would become
@code{ref="myElement"} and @code{v-ref:my-component} would become
@code{ref="myComponent"}. When used on a normal element, the @code{ref}
will be the DOM element, and when used on a component, the @code{ref}
will be the component instance.

Since @code{v-ref} is no longer a directive, but a special attribute, it
can also be dynamically defined. This is especially useful in
combination with @code{v-for}. For example:

@verbatim
<p v-for="item in items" v-bind:ref="'item' + item.id"></p>
@end verbatim

Previously, @code{v-el}/@code{v-ref} combined with @code{v-for} would
produce an array of elements/components, because there was no way to
give each item a unique name. You can still achieve this behavior by
giving each item the same @code{ref}:

@verbatim
<p v-for="item in items" ref="items"></p>
@end verbatim

Unlike in 1.x, these @code{$refs} are not reactive, because they're
registered/updated during the render process itself. Making them
reactive would require duplicate renders for every change.

On the other hand, @code{$refs} are designed primarily for programmatic
access in JavaScript - it is not recommended to rely on them in
templates, because that would mean referring to state that does not
belong to the instance itself. This would violate Vue's data-driven view
model.

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find examples of v-el and
v-ref.
@{% endraw %@}

@node v-else with v-show removed
@subsection @code{v-else} with @code{v-show} removed
@anchor{#v-else-with-v-show-removed}
@code{v-else} no longer works with @code{v-show}. Use @code{v-if} with a
negation expression instead. For example, instead of:

@verbatim
<p v-if="foo">Foo</p>
<p v-else v-show="bar">Not foo, but bar</p>
@end verbatim

You can use:

@verbatim
<p v-if="foo">Foo</p>
<p v-if="!foo && bar">Not foo, but bar</p>
@end verbatim

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find examples of the v-else
with v-show.
@{% endraw %@}

@node Custom Directives simplified
@section Custom Directives simplified
@anchor{#custom-directives-simplified}
Directives have a greatly reduced scope of responsibility: they are now
only used for applying low-level direct DOM manipulations. In most
cases, you should prefer using components as the main code-reuse
abstraction.

Some of the most notable differences include:

@itemize
@item
Directives no longer have instances. This means there's no more
@code{this} inside directive hooks. Instead, they receive everything
they might need as arguments. If you really must persist state across
hooks, you can do so on @code{el}.
@item
Options such as @code{acceptStatement}, @code{deep}, @code{priority},
etc have all been removed. To replace @code{twoWay} directives, see
@ref{#Two-Way-Filters-replaced,this example}.
@item
Some of the current hooks have different behavior and there are also a
couple new hooks.
@end itemize

Fortunately, since the new directives are much simpler, you can master
them more easily. Read the new @uref{custom-directive.html,Custom
Directives guide} to learn more.

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find examples of defined
directives. The helper will flag all of them, as it's likely in most
cases that you'll want to refactor to a component.
@{% endraw %@}

@menu
* Directive literal Modifier removed::
@end menu

@node Directive literal Modifier removed
@subsection Directive @code{.literal} Modifier removed
@anchor{#directive-.literal-modifier-removed}
The @code{.literal} modifier has been removed, as the same can be easily
achieved by providing a string literal as the value.

For example, you can update:

@verbatim
<p v-my-directive.literal="foo bar baz"></p>
@end verbatim

to:

@verbatim
<p v-my-directive="'foo bar baz'"></p>
@end verbatim

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find examples of the
@code{.literal} modifier on a directive.
@{% endraw %@}

@node Transitions
@section Transitions
@anchor{#transitions}

@menu
* transition Attribute replaced::
* Vuetransition for Reusable Transitions replaced::
* Transition stagger Attribute removed::
@end menu

@node transition Attribute replaced
@subsection @code{transition} Attribute replaced
@anchor{#transition-attribute-replaced}
Vue's transition system has changed quite drastically and now uses
@code{<transition>} and @code{<transition-group>} wrapper elements,
rather than the @code{transition} attribute. It's recommended to read
the new @uref{transitions.html,Transitions guide} to learn more.

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find examples of the
transition attribute.
@{% endraw %@}

@node Vuetransition for Reusable Transitions replaced
@subsection @code{Vue.transition} for Reusable Transitions replaced
@anchor{#vue.transition-for-reusable-transitions-replaced}
With the new transition system, you can now
@uref{transitions.html#Reusable-Transitions,use components for reusable
transitions}.

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find examples of
Vue.transition.
@{% endraw %@}

@node Transition stagger Attribute removed
@subsection Transition @code{stagger} Attribute removed
@anchor{#transition-stagger-attribute-removed}
If you need to stagger list transitions, you can control timing by
setting and accessing a @code{data-index} (or similar attribute) on an
element. See @uref{transitions.html#Staggering-List-Transitions,an
example here}.

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find examples of the
transition attribute. During your update, you can transition (pun very
much intended) to the new staggering strategy as well.
@{% endraw %@}

@node Events
@section Events
@anchor{#events}

@menu
* events option removed::
* Vuedirective'on'keyCodes replaced::
* $dispatch and $broadcast replaced::
@end menu

@node events option removed
@subsection @code{events} option removed
@anchor{#events-option-removed}
The @code{events} option has been removed. Event handlers should now be
registered in the @code{created} hook instead. Check out the
@ref{#dispatch-and-broadcast-replaced,@code{$dispatch} and
@code{$broadcast} migration guide} for a detailed example.

@node Vuedirective'on'keyCodes replaced
@subsection @code{Vue.directive('on').keyCodes} replaced
@anchor{#vue.directiveon.keycodes-replaced}
The new, more concise way to configure @code{keyCodes} is through
@code{Vue.config.keyCodes}. For example:

@verbatim
// enable v-on:keyup.f1
Vue.config.keyCodes.f1 = 112
@end verbatim

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find examples of the the
old keyCode configuration syntax.
@{% endraw %@}

@node $dispatch and $broadcast replaced
@subsection @code{$dispatch} and @code{$broadcast} replaced
@anchor{#dispatch-and-broadcast-replaced}
@code{$dispatch} and @code{$broadcast} have been removed in favor of
more explicitly cross-component communication and more maintainable
state management solutions, such as
@uref{https://github.com/vuejs/vuex,Vuex}.

The problem is event flows that depend on a component's tree structure
can be hard to reason about and are very brittle when the tree becomes
large. They don't scale well and only set you up for pain later.
@code{$dispatch} and @code{$broadcast} also do not solve communication
between sibling components.

One of the most common uses for these methods is to communicate between
a parent and its direct children. In these cases, you can actually
@uref{components.html#Form-Input-Components-using-Custom-Events,listen
to an @code{$emit} from a child with @code{v-on}}. This allows you to
keep the convenience of events with added explicitness.

However, when communicating between distant descendants/ancestors,
@code{$emit} won't help you. Instead, the simplest possible upgrade
would be to use a centralized event hub. This has the added benefit of
allowing you to communicate between components no matter where they are
in the component tree - even between siblings! Because Vue instances
implement an event emitter interface, you can actually use an empty Vue
instance for this purpose.

For example, let's say we have a todo app structured like this:

@verbatim
Todos
â”œâ”€ NewTodoInput
â””â”€ Todo
   â””â”€ DeleteTodoButton
@end verbatim

We could manage communication between components with this single event
hub:

@verbatim
// This is the event hub we'll use in every
// component to communicate between them.
var eventHub = new Vue()
@end verbatim

Then in our components, we can use @code{$emit}, @code{$on}, @code{$off}
to emit events, listen for events, and clean up event listeners,
respectively:

@verbatim
// NewTodoInput
// ...
methods: {
  addTodo: function () {
    eventHub.$emit('add-todo', { text: this.newTodoText })
    this.newTodoText = ''
  }
}
@end verbatim

@verbatim
// DeleteTodoButton
// ...
methods: {
  deleteTodo: function (id) {
    eventHub.$emit('delete-todo', id)
  }
}
@end verbatim

@verbatim
// Todos
// ...
created: function () {
  eventHub.$on('add-todo', this.addTodo)
  eventHub.$on('delete-todo', this.deleteTodo)
},
// It's good to clean up event listeners before
// a component is destroyed.
beforeDestroy: function () {
  eventHub.$off('add-todo', this.addTodo)
  eventHub.$off('delete-todo', this.deleteTodo)
},
methods: {
  addTodo: function (newTodo) {
    this.todos.push(newTodo)
  },
  deleteTodo: function (todoId) {
    this.todos = this.todos.filter(function (todo) {
      return todo.id !== todoId
    })
  }
}
@end verbatim

This pattern can serve as a replacement for @code{$dispatch} and
@code{$broadcast} in simple scenarios, but for more complex cases, it's
recommended to use a dedicated state management layer such as
@uref{https://github.com/vuejs/vuex,Vuex}.

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find examples of
@math{dispatch</code> and <code>}broadcast.
@{% endraw %@}

@node Filters
@section Filters
@anchor{#filters}

@menu
* Filters Outside Text Interpolations removed::
* Filter Argument Syntax changed::
* Built-In Text Filters removed::
* Two-Way Filters replaced::
@end menu

@node Filters Outside Text Interpolations removed
@subsection Filters Outside Text Interpolations removed
@anchor{#filters-outside-text-interpolations-removed}
Filters can now only be used inside text interpolations
(@code{@{% raw %@}@{@{ @}@}@{% endraw %@}} tags). In the past we've
found using filters within directives such as @code{v-model},
@code{v-on}, etc led to more complexity than convenience. For list
filtering on @code{v-for}, it's also better to move that logic into
JavaScript as computed properties, so that it can be reused throughout
your component.

In general, whenever something can be achieved in plain JavaScript, we
want to avoid introducing a special syntax like filters to take care of
the same concern. Here's how you can replace Vue's built-in directive
filters:

@menu
* Replacing the debounce Filter::
* Replacing the limitBy Filter::
* Replacing the filterBy Filter::
* Replacing the orderBy Filter::
@end menu

@node Replacing the debounce Filter
@subsubsection Replacing the @code{debounce} Filter
@anchor{#replacing-the-debounce-filter}
Instead of:

@verbatim
<input v-on:keyup="doStuff | debounce 500">
@end verbatim

@verbatim
methods: {
  doStuff: function () {
    // ...
  }
}
@end verbatim

Use @uref{https://lodash.com/docs/4.15.0#debounce,lodash's
@code{debounce}} (or possibly
@uref{https://lodash.com/docs/4.15.0#throttle,@code{throttle}}) to
directly limit calling the expensive method. You can achieve the same as
above like this:

@verbatim
<input v-on:keyup="doStuff">
@end verbatim

@verbatim
methods: {
  doStuff: _.debounce(function () {
    // ...
  }, 500)
}
@end verbatim

For more on the advantages of this strategy, see
@ref{#debounce-Param-Attribute-for-v-model-removed,the example here with
@code{v-model}}.

@node Replacing the limitBy Filter
@subsubsection Replacing the @code{limitBy} Filter
@anchor{#replacing-the-limitby-filter}
Instead of:

@verbatim
<p v-for="item in items | limitBy 10">{{ item }}</p>
@end verbatim

Use JavaScript's built-in
@uref{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice#Examples,@code{.slice}
method} in a computed property:

@verbatim
<p v-for="item in filteredItems">{{ item }}</p>
@end verbatim

@verbatim
computed: {
  filteredItems: function () {
    return this.items.slice(0, 10)
  }
}
@end verbatim

@node Replacing the filterBy Filter
@subsubsection Replacing the @code{filterBy} Filter
@anchor{#replacing-the-filterby-filter}
Instead of:

@verbatim
<p v-for="user in users | filterBy searchQuery in 'name'">{{ user.name }}</p>
@end verbatim

Use JavaScript's built-in
@uref{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter#Examples,@code{.filter}
method} in a computed property:

@verbatim
<p v-for="user in filteredUsers">{{ user.name }}</p>
@end verbatim

@verbatim
computed: {
  filteredUsers: function () {
    var self = this
    return self.users.filter(function (user) {
      return user.name.indexOf(self.searchQuery) !== -1
    })
  }
}
@end verbatim

JavaScript's native @code{.filter} can also manage much more complex
filtering operations, because you have access to the full power of
JavaScript within computed properties. For example, if you wanted to
find all active users and case-insensitively match against both their
name and email:

@verbatim
var self = this
self.users.filter(function (user) {
  var searchRegex = new RegExp(self.searchQuery, 'i')
  return user.isActive && (
    searchRegex.test(user.name) ||
    searchRegex.test(user.email)
  )
})
@end verbatim

@node Replacing the orderBy Filter
@subsubsection Replacing the @code{orderBy} Filter
@anchor{#replacing-the-orderby-filter}
Instead of:

@verbatim
<p v-for="user in users | orderBy 'name'">{{ user.name }}</p>
@end verbatim

Use @uref{https://lodash.com/docs/4.15.0#orderBy,lodash's
@code{orderBy}} (or possibly
@uref{https://lodash.com/docs/4.15.0#sortBy,@code{sortBy}}) in a
computed property:

@verbatim
<p v-for="user in orderedUsers">{{ user.name }}</p>
@end verbatim

@verbatim
computed: {
  orderedUsers: function () {
    return _.orderBy(this.users, 'name')
  }
}
@end verbatim

You can even order by multiple columns:

@{% codeblock lang:js %@} _.orderBy(this.users, [`name', `last_login'],
[`asc', `desc']) @{% endcodeblock %@}

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find examples of filters
being used inside directives. If you miss any, you should also see
console errors.
@{% endraw %@}

@node Filter Argument Syntax changed
@subsection Filter Argument Syntax changed
@anchor{#filter-argument-syntax-changed}
Filters' syntax for arguments now better aligns with JavaScript function
invocation. So instead of taking space-delimited arguments:

@verbatim
<p>{{ date | formatDate 'YY-MM-DD' timeZone }}</p>
@end verbatim

We surround the arguments with parentheses and delimit the arguments
with commas:

@verbatim
<p>{{ date | formatDate('YY-MM-DD', timeZone) }}</p>
@end verbatim

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find examples of the old
filter syntax. If you miss any, you should also see console errors.
@{% endraw %@}

@node Built-In Text Filters removed
@subsection Built-In Text Filters removed
@anchor{#built-in-text-filters-removed}
Although filters within text interpolations are still allowed, all of
the filters have been removed. Instead, it's recommended to use more
specialized libraries for solving problems in each domain
(e.g.@ @uref{https://date-fns.org/,@code{date-fns}} to format dates and
@uref{http://openexchangerates.github.io/accounting.js/,@code{accounting}}
for currencies).

For each of Vue's built-in text filters, we go through how you can
replace them below. The example code could exist in custom helper
functions, methods, or computed properties.

@menu
* Replacing the json Filter::
* Replacing the capitalize Filter::
* Replacing the uppercase Filter::
* Replacing the lowercase Filter::
* Replacing the pluralize Filter::
* Replacing the currency Filter::
@end menu

@node Replacing the json Filter
@subsubsection Replacing the @code{json} Filter
@anchor{#replacing-the-json-filter}
You actually don't need to for debugging anymore, as Vue will nicely
format output for you automatically, whether it's a string, number,
array, or plain object. If you want the exact same functionality as
JavaScript's @code{JSON.stringify} though, then you can use that in a
method or computed property.

@node Replacing the capitalize Filter
@subsubsection Replacing the @code{capitalize} Filter
@anchor{#replacing-the-capitalize-filter}

@verbatim
text[0].toUpperCase() + text.slice(1)
@end verbatim

@node Replacing the uppercase Filter
@subsubsection Replacing the @code{uppercase} Filter
@anchor{#replacing-the-uppercase-filter}

@verbatim
text.toUpperCase()
@end verbatim

@node Replacing the lowercase Filter
@subsubsection Replacing the @code{lowercase} Filter
@anchor{#replacing-the-lowercase-filter}

@verbatim
text.toLowerCase()
@end verbatim

@node Replacing the pluralize Filter
@subsubsection Replacing the @code{pluralize} Filter
@anchor{#replacing-the-pluralize-filter}
The @uref{https://www.npmjs.com/package/pluralize,pluralize} package on
NPM serves this purpose nicely, but if you only want to pluralize a
specific word or want to have special output for cases like @code{0},
then you can also easily define your own pluralize functions. For
example:

@verbatim
function pluralizeKnife (count) {
  if (count === 0) {
    return 'no knives'
  } else if (count === 1) {
    return '1 knife'
  } else {
    return count + 'knives'
  }
}
@end verbatim

@node Replacing the currency Filter
@subsubsection Replacing the @code{currency} Filter
@anchor{#replacing-the-currency-filter}
For a very naive implementation, you could do something like this:

@{% codeblock lang:js %@} `$' + price.toFixed(2) @{% endcodeblock %@}

In many cases though, you'll still run into strange behavior
(e.g.@ @code{0.035.toFixed(2)} rounds up to @code{0.04}, but
@code{0.045} rounds down to @code{0.04}). To work around these issues,
you can use the
@uref{http://openexchangerates.github.io/accounting.js/,@code{accounting}}
library to more reliably format currencies.

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find examples of the
obsolete text filters. If you miss any, you should also see console
errors.
@{% endraw %@}

@node Two-Way Filters replaced
@subsection Two-Way Filters replaced
@anchor{#two-way-filters-replaced}
Some users have enjoyed using two-way filters with @code{v-model} to
create interesting inputs with very little code. While @emph{seemingly}
simple however, two-way filters can also hide a great deal of complexity
- and even encourage poor UX by delaying state updates. Instead,
components wrapping an input are recommended as a more explicit and
feature-rich way of creating custom inputs.

As an example, we'll now walk the migration of a two-way currency
filter:

It mostly works well, but the delayed state updates can cause strange
behavior. For example, try entering @code{9.999} into one of those
inputs. When the input loses focus, its value will update to
@code{$10.00}. When looking at the calculated total however, you'll see
that @code{9.999} is what's stored in our data. The version of reality
that the user sees is out of sync!

To start transitioning towards a more robust solution using Vue 2.0,
let's first wrap this filter in a new @code{<currency-input>} component:

This allows us add behavior that a filter alone couldn't encapsulate,
such as selecting the content of an input on focus. Now the next step
will be to extract the business logic from the filter. Below, we pull
everything out into an external
@uref{https://gist.github.com/chrisvfritz/5f0a639590d6e648933416f90ba7ae4e,@code{currencyValidator}
object}:

This increased modularity not only makes it easier to migrate to Vue 2,
but also allows currency parsing and formatting to be:

@itemize
@item
unit tested in isolation from your Vue code
@item
used by other parts of your application, such as to validate the payload
to an API endpoint
@end itemize

Having this validator extracted out, we've also more comfortably built
it up into a more robust solution. The state quirks have been eliminated
and it's actually impossible for users to enter anything wrong, similar
to what the browser's native number input tries to do.

We're still limited however, by filters and by Vue 1.0 in general, so
let's complete the upgrade to Vue 2.0:

You may notice that:

@itemize
@item
Every aspect of our input is more explicit, using lifecycle hooks and
DOM events in place of the hidden behavior of two-way filters.
@item
We can now use @code{v-model} directly on our custom inputs, which is
not only more consistent with normal inputs, but also means our
component is Vuex-friendly.
@item
Since we're no longer using filter options that require a value to be
returned, our currency work could actually be done asynchronously. That
means if we had a lot of apps that had to work with currencies, we could
easily refactor this logic into a shared microservice.
@end itemize

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find examples of filters
used in directives like v-model. If you miss any, you should also see
console errors.
@{% endraw %@}

@node Slots
@section Slots
@anchor{#slots}

@menu
* Duplicate Slots removed::
* slot Attribute Styling removed::
@end menu

@node Duplicate Slots removed
@subsection Duplicate Slots removed
@anchor{#duplicate-slots-removed}
It is no longer supported to have @code{<slot>}s with the same name in
the same template. When a slot is rendered it is ``used up'' and cannot
be rendered elsewhere in the same render tree. If you must render the
same content in multiple places, pass that content as a prop.

@{% raw %@}
Upgrade Path
Run your end-to-end test suite or app after upgrading and look for
console warnings about duplicate slots v-model.
@{% endraw %@}

@node slot Attribute Styling removed
@subsection @code{slot} Attribute Styling removed
@anchor{#slot-attribute-styling-removed}
Content inserted via named @code{<slot>} no longer preserves the
@code{slot} attribute. Use a wrapper element to style them, or for
advanced use cases, modify the inserted content programmatically using
@uref{render-function.html,render functions}.

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find CSS selectors
targeting named slots (e.g.@ [slot=``my-slot-name'']).
@{% endraw %@}

@node Special Attributes
@section Special Attributes
@anchor{#special-attributes}

@menu
* keep-alive Attribute replaced::
@end menu

@node keep-alive Attribute replaced
@subsection @code{keep-alive} Attribute replaced
@anchor{#keep-alive-attribute-replaced}
@code{keep-alive} is no longer a special attribute, but rather a wrapper
component, similar to @code{<transition>}. For example:

@verbatim
<keep-alive>
  <component v-bind:is="view"></component>
</keep-alive>
@end verbatim

This makes it possible to use @code{<keep-alive>} on multiple
conditional children:

@verbatim
<keep-alive>
  <todo-list v-if="todos.length > 0"></todo-list>
  <no-todos-gif v-else></no-todos-gif>
</keep-alive>
@end verbatim

When @code{<keep-alive>} has multiple children, they should eventually
evaluate to a single child. Any child other than the first one will be
ignored.
When used together with @code{<transition>}, make sure to nest it
inside:

@verbatim
<transition>
  <keep-alive>
    <component v-bind:is="view"></component>
  </keep-alive>
</transition>
@end verbatim

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find keep-alive attributes.
@{% endraw %@}

@node Interpolation
@section Interpolation
@anchor{#interpolation}

@menu
* Interpolation within Attributes removed::
* HTML Interpolation removed::
* One-Time Bindings replaced::
@end menu

@node Interpolation within Attributes removed
@subsection Interpolation within Attributes removed
@anchor{#interpolation-within-attributes-removed}
Interpolation within attributes is no longer valid. For example:

@verbatim
<button class="btn btn-{{ size }}"></button>
@end verbatim

Should either be updated to use an inline expression:

@verbatim
<button v-bind:class="'btn btn-' + size"></button>
@end verbatim

Or a data/computed property:

@verbatim
<button v-bind:class="buttonClasses"></button>
@end verbatim

@verbatim
computed: {
  buttonClasses: function () {
    return 'btn btn-' + size
  }
}
@end verbatim

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find examples of
interpolation used within attributes.
@{% endraw %@}

@node HTML Interpolation removed
@subsection HTML Interpolation removed
@anchor{#html-interpolation-removed}
HTML interpolations (@code{@{% raw %@}@{@{@{ foo @}@}@}@{% endraw %@}})
have been removed in favor of the @uref{../api/#v-html,@code{v-html}
directive}.

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find HTML interpolations.
@{% endraw %@}

@node One-Time Bindings replaced
@subsection One-Time Bindings replaced
@anchor{#one-time-bindings-replaced}
One time bindings (@code{@{% raw %@}@{@{* foo @}@}@{% endraw %@}}) have
been replaced by the new @uref{../api/#v-once,@code{v-once} directive}.

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find one-time bindings.
@{% endraw %@}

@node Reactivity
@section Reactivity
@anchor{#reactivity}

@menu
* vm$watch changed::
* vm$set changed::
* vm$delete changed::
* Arrayprototype$set removed::
* Arrayprototype$remove removed::
* Vueset and Vuedelete on Vue instances removed::
* Replacing vm$data removed::
* vm$get removed::
@end menu

@node vm$watch changed
@subsection @code{vm.$watch} changed
@anchor{#vm.watch-changed}
Watchers created via @code{vm.$watch} are now fired before the
associated component rerenders. This gives you the chance to further
update state before the component rerender, thus avoiding unnecessary
updates. For example, you can watch a component prop and update the
component's own data when the prop changes.

If you were previously relying on @code{vm.$watch} to do something with
the DOM after a component updates, you can instead do so in the
@code{updated} lifecycle hook.

@{% raw %@}
Upgrade Path
Run your end-to-end test suite, if you have one. The failed tests should
alert to you to the fact that a watcher was relying on the old behavior.
@{% endraw %@}

@node vm$set changed
@subsection @code{vm.$set} changed
@anchor{#vm.set-changed}
@code{vm.$set} is now an alias for
@uref{../api/#Vue-set,@code{Vue.set}}.

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find examples of the
obsolete usage.
@{% endraw %@}

@node vm$delete changed
@subsection @code{vm.$delete} changed
@anchor{#vm.delete-changed}
@code{vm.$delete} is now an alias for
@uref{../api/#Vue-delete,@code{Vue.delete}}.

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find examples of the
obsolete usage.
@{% endraw %@}

@node Arrayprototype$set removed
@subsection @code{Array.prototype.$set} removed
@anchor{#array.prototype.set-removed}
Use @code{Vue.set} instead.

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find examples of .$set on
an array. If you miss any, you should see console errors from the
missing method.
@{% endraw %@}

@node Arrayprototype$remove removed
@subsection @code{Array.prototype.$remove} removed
@anchor{#array.prototype.remove-removed}
Use @code{Array.prototype.splice} instead. For example:

@verbatim
methods: {
  removeTodo: function (todo) {
    var index = this.todos.indexOf(todo)
    this.todos.splice(index, 1)
  }
}
@end verbatim

Or better yet, pass removal methods an index:

@verbatim
methods: {
  removeTodo: function (index) {
    this.todos.splice(index, 1)
  }
}
@end verbatim

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find examples of .$remove
on an array. If you miss any, you should see console errors from the
missing method.
@{% endraw %@}

@node Vueset and Vuedelete on Vue instances removed
@subsection @code{Vue.set} and @code{Vue.delete} on Vue instances
removed
@anchor{#vue.set-and-vue.delete-on-vue-instances-removed}
@code{Vue.set} and @code{Vue.delete} can no longer work on Vue
instances. It is now mandatory to properly declare all top-level
reactive properties in the data option. If you'd like to delete
properties on a Vue instance or its @code{$data}, set it to null.

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find examples of Vue.set or
Vue.delete on a Vue instance. If you miss any, they'll trigger console
warnings.
@{% endraw %@}

@node Replacing vm$data removed
@subsection Replacing @code{vm.$data} removed
@anchor{#replacing-vm.data-removed}
It is now prohibited to replace a component instance's root $data. This
prevents some edge cases in the reactivity system and makes the
component state more predictable (especially with type-checking
systems).

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find examples of
overwriting vm.$data. If you miss any, console warnings will be emitted.
@{% endraw %@}

@node vm$get removed
@subsection @code{vm.$get} removed
@anchor{#vm.get-removed}
Instead, retrieve reactive data directly.

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find examples of vm.$get.
If you miss any, you'll see console errors.
@{% endraw %@}

@node DOM-Focused Instance Methods
@section DOM-Focused Instance Methods
@anchor{#dom-focused-instance-methods}

@menu
* vm$appendTo removed::
* vm$before removed::
* vm$after removed::
* vm$remove removed::
@end menu

@node vm$appendTo removed
@subsection @code{vm.$appendTo} removed
@anchor{#vm.appendto-removed}
Use the native DOM API:

@{% codeblock lang:js %@} myElement.appendChild(vm.$el) @{% endcodeblock
%@}

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find examples of
vm.$appendTo. If you miss any, you'll see console errors.
@{% endraw %@}

@node vm$before removed
@subsection @code{vm.$before} removed
@anchor{#vm.before-removed}
Use the native DOM API:

@{% codeblock lang:js %@} myElement.parentNode.insertBefore(vm.$el,
myElement) @{% endcodeblock %@}

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find examples of
vm.$before. If you miss any, you'll see console errors.
@{% endraw %@}

@node vm$after removed
@subsection @code{vm.$after} removed
@anchor{#vm.after-removed}
Use the native DOM API:

@{% codeblock lang:js %@} myElement.parentNode.insertBefore(vm.$el,
myElement.nextSibling) @{% endcodeblock %@}

Or if @code{myElement} is the last child:

@{% codeblock lang:js %@} myElement.parentNode.appendChild(vm.$el) @{%
endcodeblock %@}

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find examples of vm.$after.
If you miss any, you'll see console errors.
@{% endraw %@}

@node vm$remove removed
@subsection @code{vm.$remove} removed
@anchor{#vm.remove-removed}
Use the native DOM API:

@{% codeblock lang:js %@} vm.$el.remove() @{% endcodeblock %@}

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find examples of
vm.$remove. If you miss any, you'll see console errors.
@{% endraw %@}

@node Meta Instance Methods
@section Meta Instance Methods
@anchor{#meta-instance-methods}

@menu
* vm$eval removed::
* vm$interpolate removed::
* vm$log removed::
@end menu

@node vm$eval removed
@subsection @code{vm.$eval} removed
@anchor{#vm.eval-removed}
No real use. If you do happen to rely on this feature somehow and aren't
sure how to work around it, post on @uref{https://forum.vuejs.org/,the
forum} for ideas.

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find examples of vm.$eval.
If you miss any, you'll see console errors.
@{% endraw %@}

@node vm$interpolate removed
@subsection @code{vm.$interpolate} removed
@anchor{#vm.interpolate-removed}
No real use. If you do happen to rely on this feature somehow and aren't
sure how to work around it, post on @uref{https://forum.vuejs.org/,the
forum} for ideas.

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find examples of
vm.$interpolate. If you miss any, you'll see console errors.
@{% endraw %@}

@node vm$log removed
@subsection @code{vm.$log} removed
@anchor{#vm.log-removed}
Use the @uref{https://github.com/vuejs/vue-devtools,Vue Devtools} for
the optimal debugging experience.

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find examples of vm.$log.
If you miss any, you'll see console errors.
@{% endraw %@}

@node Instance DOM Options
@section Instance DOM Options
@anchor{#instance-dom-options}

@menu
* replace false removed::
@end menu

@node replace false removed
@subsection @code{replace: false} removed
@anchor{#replace-false-removed}
Components now always replace the element they're bound to. To simulate
the behavior of @code{replace: false}, you can wrap your root component
with an element similar to the one you're replacing. For example:

@verbatim
new Vue({
  el: '#app',
  template: '<div id="app"> ... </div>'
})
@end verbatim

Or with a render function:

@verbatim
new Vue({
  el: '#app',
  render: function (h) {
    h('div', {
      attrs: {
        id: 'app',
      }
    }, /* ... */)
  }
})
@end verbatim

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find examples of replace:
false.
@{% endraw %@}

@node Global Config
@section Global Config
@anchor{#global-config}

@menu
* Vueconfigdebug removed::
* Vueconfigasync removed::
* Vueconfigdelimiters replaced::
* VueconfigunsafeDelimiters removed::
@end menu

@node Vueconfigdebug removed
@subsection @code{Vue.config.debug} removed
@anchor{#vue.config.debug-removed}
No longer necessary, since warnings come with stack traces by default
now.

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find examples of
Vue.config.debug.
@{% endraw %@}

@node Vueconfigasync removed
@subsection @code{Vue.config.async} removed
@anchor{#vue.config.async-removed}
Async is now required for rendering performance.

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find examples of
Vue.config.async.
@{% endraw %@}

@node Vueconfigdelimiters replaced
@subsection @code{Vue.config.delimiters} replaced
@anchor{#vue.config.delimiters-replaced}
This has been reworked as a @uref{../api/#delimiters,component-level
option}. This allows you to use alternative delimiters within your app
without breaking 3rd-party components.

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find examples of
Vue.config.delimiters.
@{% endraw %@}

@node VueconfigunsafeDelimiters removed
@subsection @code{Vue.config.unsafeDelimiters} removed
@anchor{#vue.config.unsafedelimiters-removed}
HTML interpolation has been @ref{#HTML-Interpolation-removed,removed in
favor of @code{v-html}}.

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find examples of
Vue.config.unsafeDelimiters. After this, the helper will also find
instances of HTML interpolation so that you can replace them with
@code{v-html}.
@{% endraw %@}

@node Global API
@section Global API
@anchor{#global-api}

@menu
* Vueextend with el removed::
* VueelementDirective removed::
* Vuepartial removed::
@end menu

@node Vueextend with el removed
@subsection @code{Vue.extend} with @code{el} removed
@anchor{#vue.extend-with-el-removed}
The el option can no longer be used in @code{Vue.extend}. It's only
valid as an instance creation option.

@{% raw %@}
Upgrade Path
Run your end-to-end test suite or app after upgrading and look for
console warnings about the el option with Vue.extend.
@{% endraw %@}

@node VueelementDirective removed
@subsection @code{Vue.elementDirective} removed
@anchor{#vue.elementdirective-removed}
Use components instead.

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find examples of
Vue.elementDirective.
@{% endraw %@}

@node Vuepartial removed
@subsection @code{Vue.partial} removed
@anchor{#vue.partial-removed}
Partials have been removed in favor of more explicit data flow between
components, using props. Unless you're using a partial in a
performance-critical area, the recommendation is to use a
@uref{components.html,normal component} instead. If you were dynamically
binding the @code{name} of a partial, you can use a
@uref{components.html#Dynamic-Components,dynamic component}.

If you happen to be using partials in a performance-critical part of
your app, then you should upgrade to
@uref{render-function.html#Functional-Components,functional components}.
They must be in a plain JS/JSX file (rather than in a @code{.vue} file)
and are stateless and instanceless, like partials. This makes rendering
extremely fast.

A benefit of functional components over partials is that they can be
much more dynamic, because they grant you access to the full power of
JavaScript. There is a cost to this power however. If you've never used
a component framework with render functions before, they may take a bit
longer to learn.

@{% raw %@}
Upgrade Path
Run the migration helper on your codebase to find examples of
Vue.partial.
@{% endraw %@}

@bye
