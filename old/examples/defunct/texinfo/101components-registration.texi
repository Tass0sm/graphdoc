\input texinfo
@documentencoding UTF-8

@ifnottex
@paragraphindent 0
@end ifnottex
@titlepage
@title Component Registration
@end titlepage

@node Top
@top Component Registration

@quotation
This page assumes you've already read the
@uref{components.html,Components Basics}. Read that first if you are new
to components.
@end quotation
Watch a free video lesson on Vue School

@node Component Names
@section Component Names
@anchor{#component-names}
When registering a component, it will always be given a name. For
example, in the global registration we've seen so far:

@verbatim
Vue.component('my-component-name', { /* ... */ })
@end verbatim

The component's name is the first argument of @code{Vue.component}.

The name you give a component may depend on where you intend to use it.
When using a component directly in the DOM (as opposed to in a string
template or @uref{single-file-components.html,single-file component}),
we strongly recommend following the
@uref{https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name,W3C
rules} for custom tag names (all-lowercase, must contain a hyphen). This
helps you avoid conflicts with current and future HTML elements.

You can see other recommendations for component names in the
@uref{../style-guide/#Base-component-names-strongly-recommended,Style
Guide}.

@menu
* Name Casing::
@end menu

@node Name Casing
@subsection Name Casing
@anchor{#name-casing}
You have two options when defining component names:

@menu
* With kebab-case::
* With PascalCase::
@end menu

@node With kebab-case
@subsubsection With kebab-case
@anchor{#with-kebab-case}

@verbatim
Vue.component('my-component-name', { /* ... */ })
@end verbatim

When defining a component with kebab-case, you must also use kebab-case
when referencing its custom element, such as in
@code{<my-component-name>}.

@node With PascalCase
@subsubsection With PascalCase
@anchor{#with-pascalcase}

@verbatim
Vue.component('MyComponentName', { /* ... */ })
@end verbatim

When defining a component with PascalCase, you can use either case when
referencing its custom element. That means both
@code{<my-component-name>} and @code{<MyComponentName>} are acceptable.
Note, however, that only kebab-case names are valid directly in the DOM
(i.e.@ non-string templates).

@node Global Registration
@section Global Registration
@anchor{#global-registration}
So far, we've only created components using @code{Vue.component}:

@verbatim
Vue.component('my-component-name', {
  // ... options ...
})
@end verbatim

These components are @strong{globally registered}. That means they can
be used in the template of any root Vue instance (@code{new Vue})
created after registration. For example:

@verbatim
Vue.component('component-a', { /* ... */ })
Vue.component('component-b', { /* ... */ })
Vue.component('component-c', { /* ... */ })

new Vue({ el: '#app' })
@end verbatim

@verbatim
<div id="app">
  <component-a></component-a>
  <component-b></component-b>
  <component-c></component-c>
</div>
@end verbatim

This even applies to all subcomponents, meaning all three of these
components will also be available @emph{inside each other}.

@node Local Registration
@section Local Registration
@anchor{#local-registration}
Global registration often isn't ideal. For example, if you're using a
build system like Webpack, globally registering all components means
that even if you stop using a component, it could still be included in
your final build. This unnecessarily increases the amount of JavaScript
your users have to download.

In these cases, you can define your components as plain JavaScript
objects:

@verbatim
var ComponentA = { /* ... */ }
var ComponentB = { /* ... */ }
var ComponentC = { /* ... */ }
@end verbatim

Then define the components you'd like to use in a @code{components}
option:

@verbatim
new Vue({
  el: '#app',
  components: {
    'component-a': ComponentA,
    'component-b': ComponentB
  }
})
@end verbatim

For each property in the @code{components} object, the key will be the
name of the custom element, while the value will contain the options
object for the component.

Note that @strong{locally registered components are @emph{not} also
available in subcomponents}. For example, if you wanted
@code{ComponentA} to be available in @code{ComponentB}, you'd have to
use:

@verbatim
var ComponentA = { /* ... */ }

var ComponentB = {
  components: {
    'component-a': ComponentA
  },
  // ...
}
@end verbatim

Or if you're using ES2015 modules, such as through Babel and Webpack,
that might look more like:

@verbatim
import ComponentA from './ComponentA.vue'

export default {
  components: {
    ComponentA
  },
  // ...
}
@end verbatim

Note that in ES2015+, placing a variable name like @code{ComponentA}
inside an object is shorthand for @code{ComponentA: ComponentA}, meaning
the name of the variable is both:

@itemize
@item
the custom element name to use in the template, and
@item
the name of the variable containing the component options
@end itemize

@node Module Systems
@section Module Systems
@anchor{#module-systems}
If you're not using a module system with @code{import}/@code{require},
you can probably skip this section for now. If you are, we have some
special instructions and tips just for you.

@menu
* Local Registration in a Module System::
* Automatic Global Registration of Base Components::
@end menu

@node Local Registration in a Module System
@subsection Local Registration in a Module System
@anchor{#local-registration-in-a-module-system}
If you're still here, then it's likely you're using a module system,
such as with Babel and Webpack. In these cases, we recommend creating a
@code{components} directory, with each component in its own file.

Then you'll need to import each component you'd like to use, before you
locally register it. For example, in a hypothetical @code{ComponentB.js}
or @code{ComponentB.vue} file:

@verbatim
import ComponentA from './ComponentA'
import ComponentC from './ComponentC'

export default {
  components: {
    ComponentA,
    ComponentC
  },
  // ...
}
@end verbatim

Now both @code{ComponentA} and @code{ComponentC} can be used inside
@code{ComponentB}'s template.

@node Automatic Global Registration of Base Components
@subsection Automatic Global Registration of Base Components
@anchor{#automatic-global-registration-of-base-components}
Many of your components will be relatively generic, possibly only
wrapping an element like an input or a button. We sometimes refer to
these as
@uref{../style-guide/#Base-component-names-strongly-recommended,base
components} and they tend to be used very frequently across your
components.

The result is that many components may include long lists of base
components:

@verbatim
import BaseButton from './BaseButton.vue'
import BaseIcon from './BaseIcon.vue'
import BaseInput from './BaseInput.vue'

export default {
  components: {
    BaseButton,
    BaseIcon,
    BaseInput
  }
}
@end verbatim

Just to support relatively little markup in a template:

@verbatim
<BaseInput
  v-model="searchText"
  @keydown.enter="search"
/>
<BaseButton @click="search">
  <BaseIcon name="search"/>
</BaseButton>
@end verbatim

Fortunately, if you're using Webpack (or
@uref{https://github.com/vuejs/vue-cli,Vue CLI 3+}, which uses Webpack
internally), you can use @code{require.context} to globally register
only these very common base components. Here's an example of the code
you might use to globally import base components in your app's entry
file (e.g.@ @code{src/main.js}):

@verbatim
import Vue from 'vue'
import upperFirst from 'lodash/upperFirst'
import camelCase from 'lodash/camelCase'

const requireComponent = require.context(
  // The relative path of the components folder
  './components',
  // Whether or not to look in subfolders
  false,
  // The regular expression used to match base component filenames
  /Base[A-Z]\w+\.(vue|js)$/
)

requireComponent.keys().forEach(fileName => {
  // Get component config
  const componentConfig = requireComponent(fileName)

  // Get PascalCase name of component
  const componentName = upperFirst(
    camelCase(
      // Gets the file name regardless of folder depth
      fileName
        .split('/')
        .pop()
        .replace(/\.\w+$/, '')
    )
  )


  // Register component globally
  Vue.component(
    componentName,
    // Look for the component options on `.default`, which will
    // exist if the component was exported with `export default`,
    // otherwise fall back to module's root.
    componentConfig.default || componentConfig
  )
})
@end verbatim

Remember that @strong{global registration must take place before the
root Vue instance is created (with @code{new Vue})}.
@uref{https://github.com/chrisvfritz/vue-enterprise-boilerplate/blob/master/src/components/_globals.js,Here's
an example} of this pattern in a real project context.

@bye
