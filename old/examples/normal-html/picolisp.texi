@node Top
@top PicoLisp Reference

@uref{mailto:abu@@software-lab.de,abu@@software-lab.de}

@emph{Perfection is attained}@*
@emph{not when there is nothing left to add}@*
@emph{but when there is nothing left to take away.}@*
@emph{(Antoine de Saint-Exup√©ry)}@*

@menu
* The PicoLisp Reference::
@end menu

@node The PicoLisp Reference
@chapter The PicoLisp Reference
@anchor{#the-picolisp-reference}
(c) Software Lab. Alexander Burger

This document describes the concepts, data types, and kernel functions
of the @uref{http://software-lab.de/down.html,PicoLisp} system.

This is @emph{not} a Lisp tutorial. For an introduction to Lisp, a
traditional Lisp book like "Lisp" by Winston/Horn (Addison-Wesley 1981)
is recommended. Note, however, that there are significant differences
between PicoLisp and Maclisp (and even greater differences to Common
Lisp).

Please take a look at the
@uref{https://software-lab.de/doc/tut.html,PicoLisp Tutorial} for an
explanation of some aspects of PicoLisp, and scan through the list of
@uref{https://software-lab.de/doc/faq.html,Frequently Asked Questions
(FAQ)}.

@itemize
@item
@ref{#intro,Introduction}
@item
@ref{#vm,The PicoLisp Machine}
@itemize
@item
@ref{#cell,The Cell}
@item
@ref{#data,Data Types}
@itemize
@item
@ref{#number,Numbers}
@item
@ref{#symbol,Symbols}
@itemize
@item
@ref{#nilSym,NIL}
@item
@ref{#internal,Internal Symbols}
@item
@ref{#transient,Transient Symbols}
@item
@ref{#external,External Symbols}
@end itemize

@item
@ref{#lst,Lists}
@end itemize

@item
@ref{#mem,Memory Management}
@end itemize

@item
@ref{#penv,Programming Environment}
@itemize
@item
@ref{#inst,Installation}
@item
@ref{#invoc,Invocation}
@item
@ref{#io,Input/Output}
@itemize
@item
@ref{#num-io,Numbers}
@item
@ref{#sym-io,Symbols}
@itemize
@item
@ref{#nilSym-io,NIL}
@item
@ref{#internal-io,Internal Symbols}
@item
@ref{#transient-io,Transient Symbols}
@item
@ref{#external-io,External Symbols}
@end itemize

@item
@ref{#lst-io,Lists}
@item
@ref{#macro-io,Read-Macros}
@end itemize

@item
@ref{#ev,Evaluation}
@item
@ref{#libs,Shared Libraries}
@item
@ref{#coroutines,Coroutines}
@item
@ref{#int,Interrupt}
@item
@ref{#errors,Error Handling}
@item
@ref{#atres,@@ Result}
@item
@ref{#cmp,Comparing}
@item
@ref{#oop,OO Concepts}
@item
@ref{#dbase,Database}
@itemize
@item
@ref{#trans,Transactions}
@item
@ref{#er,Entities / Relations}
@end itemize

@item
@ref{#pilog,Pilog (PicoLisp Prolog)}
@item
@ref{#conv,Naming Conventions}
@item
@ref{#trad,Breaking Traditions}
@end itemize

@item
@ref{#fun,Function Reference}
@item
@ref{#down,Download}
@end itemize

@iftex
@bigskip@hrule@bigskip
@end iftex
@ifnottex
------------------------------------------------------------------------
@end ifnottex

@menu
* Introduction::
* The PicoLisp Machine::
* Programming Environment::
* Function Reference::
* Download::
@end menu

@node Introduction
@section Introduction
@anchor{#introduction}
PicoLisp is the result of a language design study, trying to answer the
question "What is a minimal but useful architecture for a virtual
machine?". Because opinions differ about what is meant by "minimal" and
"useful", there are many answers to that question, and people might
consider other solutions more "minimal" or more "useful". But from a
practical point of view, PicoLisp has proven to be a valuable answer to
that question.

First of all, PicoLisp is a virtual machine architecture, and then a
programming language. It was designed in a "bottom up" way, and "bottom
up" is also the most natural way to understand and to use it: @emph{Form
Follows Function}.

PicoLisp has been used in several commercial and research programming
projects since 1988. Its internal structures are simple enough, allowing
an experienced programmer always to fully understand what's going on
under the hood, and its language features, efficiency and extensibility
make it suitable for almost any practical programming task.

In a nutshell, emphasis was put on four design objectives. The PicoLisp
system should be

@table @asis
@item Simple

The internal data structure should be as simple as possible. Only one
single data structure is used to build all higher level constructs.
@item Unlimited

There are no limits imposed upon the language due to limitations of the
virtual machine architecture. That is, there is no upper bound in symbol
name length, number digit counts, stack depth, or data structure and
buffer sizes, except for the total memory size of the host machine.
@item Dynamic

Behavior should be as dynamic as possible ("run"-time vs.
"compile"-time). All decisions are delayed until runtime where possible.
This involves matters like memory management, dynamic symbol binding,
and late method binding.
@item Practical

PicoLisp is not just a toy of theoretical value. It is in use since 1988
in actual application development, research and production.
@end table

@iftex
@bigskip@hrule@bigskip
@end iftex
@ifnottex
------------------------------------------------------------------------
@end ifnottex

@node The PicoLisp Machine
@section The PicoLisp Machine
@anchor{#the-picolisp-machine}
An important point in the PicoLisp philosophy is the knowledge about the
architecture and data structures of the internal machinery. The
high-level constructs of the programming language directly map to that
machinery, making the whole system both understandable and predictable.

This is similar to assembly language programming, where the programmer
has complete control over the machine.

@iftex
@bigskip@hrule@bigskip
@end iftex
@ifnottex
------------------------------------------------------------------------
@end ifnottex

@menu
* The Cell::
* Data Types::
* Memory Management::
@end menu

@node The Cell
@subsection The Cell
@anchor{#the-cell}
The PicoLisp virtual machine is both simpler and more powerful than most
current (hardware) processors. At the lowest level, it is constructed
from a single data structure called "cell":

@verbatim
         +-----+-----+
         | CAR | CDR |
         +-----+-----+
@end verbatim

A cell is a pair of machine words, which traditionally are called CAR
and CDR in the Lisp terminology. These words can represent either a
numeric value (scalar) or the address of another cell (pointer). All
higher level data structures are built out of cells.

The type information of higher level data is contained in the pointers
to these data. Assuming the implementation on a byte-addressed physical
machine and a pointer size of typically 8 bytes, each cell has a size of
16 bytes. Therefore, the pointer to a cell must point to a 16-byte
boundary (a number which is a multiple of 16), and its
bit-representation will look like:

@verbatim
      xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx0000
@end verbatim

(the '@code{x}' means "don't care"). For the individual data types, the
pointer is adjusted to point to other parts of a cell, in effect setting
some of the lower three bits to non-zero values. These bits are then
used by the interpreter to determine the data type.

In any case, bit(0) - the least significant of these bits - is reserved
as a mark bit for garbage collection.

Initially, all cells in the memory are unused (free), and linked
together to form a "free list". To create higher level data types at
runtime, cells are taken from that free list, and returned by the
garbage collector when they are no longer needed. All memory management
is done via that free list; there are no additional buffers, string
spaces or special memory areas, with two exceptions:

@itemize
@item
A certain fixed area of memory is set aside to contain the executable
code and global variables of the interpreter itself, and
@item
a standard push down stack for return addresses and temporary storage.
Both are not directly accessible by the programmer.
@end itemize

@iftex
@bigskip@hrule@bigskip
@end iftex
@ifnottex
------------------------------------------------------------------------
@end ifnottex

@node Data Types
@subsection Data Types
@anchor{#data-types}
On the virtual machine level, PicoLisp supports

@itemize
@item
three base data types: Numbers, Symbols and Cons Pairs (Lists),
@item
the three scope variations of symbols: Internal, Transient and External,
and
@item
the special symbol @code{NIL}.
@end itemize

They are all built from the single cell data structure, and all runtime
data cannot consist of any other types than these three.

The following diagram shows the complete data type hierarchy, consisting
of the three base types and the symbol variations:

@verbatim
                       cell
                        |
            +-----------+-----------+
            |           |           |
         Number       Symbol       Pair
                        |
                        |
   +--------+-----------+-----------+
   |        |           |           |
  NIL   Internal    Transient    External
@end verbatim

@iftex
@bigskip@hrule@bigskip
@end iftex
@ifnottex
------------------------------------------------------------------------
@end ifnottex

@menu
* Numbers::
* Symbols::
* Lists::
@end menu

@node Numbers
@subsubsection Numbers
@anchor{#numbers}
A number can represent a signed integral value of arbitrary size.
Internally, numeric values of up to 60 bits are stored in "short"
numbers,

@verbatim
      xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxS010
@end verbatim

i.e. the value is directly represented in the pointer, and doesn't take
any heap space.

Numbers larger than that are "big" numbers, stored in heap cells. The
CARs of one or more cells hold the number's "digits" (64 bits each),
with the least significant digit first, while the CDRs point to the
remaining digits.

@verbatim
         Bignum
         |
         V
      +-----+-----+
      | DIG |  |  |
      +-----+--+--+
               |
               V
            +-----+-----+
            | DIG |  |  |
            +-----+--+--+
                     |
                     V
                  +-----+-----+
                  | DIG | CNT |
                  +-----+-----+
@end verbatim

The CDR of the final cell holds the remaining bits in a short number.

The pointer to a big number points into the middle of the CAR, with an
offset of 4 from the cell's start address, and the sign bit in bit(3):

@verbatim
      xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxS100
@end verbatim

Thus, a number is recognized by the interpreter when either bit(1) is
non-zero (a short number) or bit(2) is non-zero (a big number).

@iftex
@bigskip@hrule@bigskip
@end iftex
@ifnottex
------------------------------------------------------------------------
@end ifnottex

@node Symbols
@subsubsection Symbols
@anchor{#symbols}
A symbol is more complex than a number. Each symbol has a value, and
optionally a name and an arbitrary number of properties. The CDR of a
symbol cell is also called VAL, and the CAR points to the symbol's tail.
As a minimum, a symbol consists of a single cell, and has no name or
properties:

@verbatim
            Symbol
            |
            V
      +-----+-----+
      |  /  | VAL |
      +-----+-----+
@end verbatim

That is, the symbol's tail is empty (points to @code{NIL}, as indicated
by the '@code{/}' character).

The pointer to a symbol points to the CDR of the cell, with an offset of
8 bytes from the cell's start address. Therefore, the bit pattern of a
symbol will be:

@verbatim
      xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx1000
@end verbatim

Thus, a symbol is recognized by the interpreter when bit(3) is non-zero.
(It should also be understood that both bit(2) and bit(1) must be zero,
thus avoiding confusion with the number types.)

A property is a key-value pair, represented by a cons pair in the
symbol's tail. This is called a "property list". The property list may
be terminated by a number (short or big) representing the symbol's name.
In the following example, a symbol with the name
@code{"abcdefghijklmno"} has three properties: A KEY/VAL pair, a cell
with only a KEY, and another KEY/VAL pair.

@verbatim
            Symbol
            |
            V
      +-----+-----+                                +----------+---------+
      |  |  | VAL |                                |'hgfedcba'|'onmlkji'|
      +--+--+-----+                                +----------+---------+
         | tail                                       ^
         |                                            |
         V                                            | name
         +-----+-----+     +-----+-----+     +-----+--+--+
         |  |  |  ---+---> | KEY |  ---+---> |  |  |  |  |
         +--+--+-----+     +-----+-----+     +--+--+-----+
            |                                   |
            V                                   V
            +-----+-----+                       +-----+-----+
            | VAL | KEY |                       | VAL | KEY |
            +-----+-----+                       +-----+-----+
@end verbatim

Each property in a symbol's tail is either a symbol (like the single KEY
above, then it represents the boolean value @code{T}) or a cons pair
with the property key in its CDR and the property value in its CAR. In
both cases, the key should be a symbol, because searches in the property
list are performed using pointer comparisons.

The name of a symbol is stored as a number at the end of the tail. It
contains the characters of the name in UTF-8 encoding, using between one
and seven bytes in a short number, or eight bytes in a bignum cell. The
first byte of the first character, for example, is stored in the lowest
8 bits of the number.

All symbols have the above structure, but depending on scope and
accessibility there are actually four types of symbols: @code{NIL},
@ref{#internal,internal}, @ref{#transient,transient} and
@ref{#external,external} symbols.

@iftex
@bigskip@hrule@bigskip
@end iftex
@ifnottex
------------------------------------------------------------------------
@end ifnottex
NIL
@code{NIL} is a special symbol which exists exactly once in the whole
system. It is used

@itemize
@item
as an end-of-list marker
@item
to represent the empty list
@item
to represent the boolean value "false"
@item
to represent the absolute minimum
@item
to represent a string of length zero
@item
to represent end of file
@item
to represent the value "Not a Number"
@item
as the root of all class hierarchies
@item
as volatile property key
@end itemize

For that, @code{NIL} has a special structure:

@verbatim
      NIL:  /
            |
            V
      +-----+-----+-----+-----+
      |'LIN'|  /  |  /  |  /  |
      +-----+-----+-----+-----+
@end verbatim

The reason for that structure is @code{NIL}'s dual nature both as a
symbol and as a list:

@itemize
@item
As a symbol, it should give @code{NIL} for its VAL, and be without
properties
@item
For the empty list, @code{NIL} should give @code{NIL} both for its CAR
and for its CDR
@end itemize

These requirements are fulfilled by the above structure.

@iftex
@bigskip@hrule@bigskip
@end iftex
@ifnottex
------------------------------------------------------------------------
@end ifnottex
Internal Symbols
Internal symbols are all those "normal" symbols, as they are used for
function definitions and variable names. They are "interned" into an
index structure, so that it is possible to find an internal symbol by
searching for its name.

There cannot be two different internal symbols with the same name.

Initially, a new internal symbol's VAL is @code{NIL}.

@iftex
@bigskip@hrule@bigskip
@end iftex
@ifnottex
------------------------------------------------------------------------
@end ifnottex
Transient Symbols
Transient symbols are only interned into an index structure for a
certain time (e.g. while reading the current source file), and are
released after that. That means, a transient symbol cannot be accessed
then by its name, and there may be several transient symbols in the
system having the same name.

Transient symbols are used

@itemize
@item
as text strings
@item
as identifiers with a limited access scope (like, for example,
@code{static} identifiers in the C language family)
@item
as anonymous, dynamically created objects (without a name)
@end itemize

Initially, a new transient symbol's VAL is that symbol itself.

A transient symbol without a name can be created with the @code{box} or
@code{new} functions.

@iftex
@bigskip@hrule@bigskip
@end iftex
@ifnottex
------------------------------------------------------------------------
@end ifnottex
External Symbols
External symbols reside in a database file (or a similar resources, see
@code{*Ext}), and are loaded into memory - and written back to the file
- dynamically as needed, and transparently to the programmer. They are
kept in memory ("cached") as long as they are accessible ("referred to")
from other parts of the program, or when they were modified but not yet
written to the database file (by @code{commit}).

The interpreter recognizes external symbols internally by an additional
tag bit in the tail structure.

There cannot be two different external symbols with the same name.
External symbols are maintained in index structures while they are
loaded into memory, and have their external location (disk file and
block offset) directly coded into their names (more details
@ref{#external-io,here}).

Initially, a new external symbol's VAL is @code{NIL}, unless otherwise
specified at creation time.

@iftex
@bigskip@hrule@bigskip
@end iftex
@ifnottex
------------------------------------------------------------------------
@end ifnottex

@node Lists
@subsubsection Lists
@anchor{#lists}
A list is a sequence of one or more cells (cons pairs), holding numbers,
symbols, or cons pairs.

@verbatim
      |
      V
      +-----+-----+
      | any |  |  |
      +-----+--+--+
               |
               V
               +-----+-----+
               | any |  |  |
               +-----+--+--+
                        |
                        V
                        ...
@end verbatim

Lists are used in PicoLisp to emulate composite data structures like
arrays, trees, stacks or queues.

In contrast to lists, numbers and symbols are collectively called
"Atoms".

Typically, the CDR of each cell in a list points to the following cell,
except for the last cell which points to @code{NIL}. If, however, the
CDR of the last cell points to an atom, that cell is called a "dotted
pair" (because of its I/O syntax with a dot '@code{.}' between the two
values).

@iftex
@bigskip@hrule@bigskip
@end iftex
@ifnottex
------------------------------------------------------------------------
@end ifnottex

@node Memory Management
@subsection Memory Management
@anchor{#memory-management}
The PicoLisp interpreter has complete knowledge of all data in the
system, due to the type information associated with every pointer.
Therefore, an efficient garbage collector mechanism can easily be
implemented. PicoLisp employs a simple but fast mark-and-sweep garbage
collector.

As the collection process is very fast (in the order of milliseconds per
megabyte), it was not necessary to develop more complicated,
time-consuming and error-prone garbage collection algorithms (e.g.
incremental collection). A compacting garbage collector is also not
necessary, because the single cell data type cannot cause heap
fragmentation.

@iftex
@bigskip@hrule@bigskip
@end iftex
@ifnottex
------------------------------------------------------------------------
@end ifnottex

@node Programming Environment
@section Programming Environment
@anchor{#programming-environment}
Lisp was chosen as the programming language, because of its clear and
simple structure.

In some previous versions, a Forth-like syntax was also implemented on
top of a similar virtual machine (Lifo). Though that language was more
flexible and expressive, the traditional Lisp syntax proved easier to
handle, and the virtual machine can be kept considerably simpler.
PicoLisp inherits the major advantages of classical Lisp systems like

@itemize
@item
Dynamic data types and structures
@item
Formal equivalence of code and data
@item
Functional programming style
@item
An interactive environment
@end itemize

In the following, some concepts and peculiarities of the PicoLisp
language and environment are described.

@iftex
@bigskip@hrule@bigskip
@end iftex
@ifnottex
------------------------------------------------------------------------
@end ifnottex

@menu
* Installation::
* Invocation::
* Input/Output::
* Evaluation::
* Shared Libraries::
* Coroutines::
* Interrupt::
* Error Handling::
* @@ Result::
* Comparing::
* OO Concepts::
* Database::
* Pilog PicoLisp Prolog::
* Naming Conventions::
* Breaking Traditions::
@end menu

@node Installation
@subsection Installation
@anchor{#installation}
PicoLisp supports two installation strategies: Local and Global.

Normally, if you didn't build PicoLisp yourself but installed it with
your operating system's package manager, you will have a global
installation. This allows system-wide access to the executable and
library/documentation files.

To get a local installation, you can directly download the PicoLisp
tarball, and follow the instructions in the INSTALL file.

A local installation will not interfere in any way with the world
outside its directory. There is no need to touch any system locations,
and you don't have to be root to install it. Many different versions -
or local modifications - of PicoLisp can co-exist on a single machine.

Note that you are still free to have local installations along with a
global installation, and invoke them explicitly as desired.

Most examples in the following apply to a global installation.

@iftex
@bigskip@hrule@bigskip
@end iftex
@ifnottex
------------------------------------------------------------------------
@end ifnottex

@node Invocation
@subsection Invocation
@anchor{#invocation}
When PicoLisp is invoked from the command line, an arbitrary number of
arguments may follow the command name.

By default, each argument is the name of a file to be executed by the
interpreter. If, however, the argument's first character is a hyphen
'@code{-}', then the rest of that argument is taken as a Lisp function
call (without the surrounding parentheses), and a hyphen by itself as an
argument stops evaluation of the rest of the command line (it may be
processed later using the @code{argv} and @code{opt} functions). This
whole mechanism corresponds to calling @code{(load T)}.

A special case is if the last argument is a single '@code{+}'. This will
switch on debug mode (the @code{*Dbg} global variable) and discard the
'@code{+}'.

As a convention, PicoLisp source files have the extension "@code{.l}".

Note that the PicoLisp executable itself does not expect or accept any
command line flags or options (except the '@code{+}', see above). They
are reserved for application programs.

The simplest and shortest invocation of PicoLisp does nothing, and exits
immediately by calling @code{bye}:

@verbatim
$ picolisp -bye
$
@end verbatim

In interactive mode, the PicoLisp interpreter (see @code{load}) will
also exit when @code{Ctrl-D} is entered:

@verbatim
$ picolisp
: $                     # Typed Ctrl-D
@end verbatim

To start up the standard PicoLisp environment, several files should be
loaded. The most commonly used things are in "lib.l" and in a bunch of
other files, which are in turn loaded by "ext.l". Thus, a typical call
would be:

@verbatim
$ picolisp lib.l ext.l
@end verbatim

The recommended way, however, is to call the "pil" shell script, which
includes "lib.l" and "ext.l". Given that your current project is loaded
by some file "myProject.l" and your startup function is @code{main},
your invocation would look like:

@verbatim
$ pil myProject.l -main
@end verbatim

For interactive development it is recommended to enable debugging mode,
to get the vi-style line editor, single-stepping, tracing and other
debugging utilities.

@verbatim
$ pil myProject.l -main +
@end verbatim

This is - in a local installation - equivalent to

@verbatim
$ ./pil myProject.l -main +
@end verbatim

In any case, the directory part of the first file name supplied
(normally, the path to "lib.l" as called by 'pil') is remembered
internally as the @emph{PicoLisp Home Directory}. This path is later
automatically substituted for any leading "@code{@@}" character in file
name arguments to I/O functions (see @code{path}).

Instead of the default vi-style line editor, an emacs-style editor can
be used. It can be switched on permanently by calling the function
@code{(em)} (i.e. without arguments), or by passing @code{-em} on the
command line:

@verbatim
$ pil -em +
:
@end verbatim

A single call is enough, because the style will be remembered in a file
"~/.pil/editor", and used in all subsequent PicoLisp sessions.

To switch back to 'vi' style, call @code{(vi)}, use the @code{-vi}
command line option, or simply remove "~/.pil/editor".

@iftex
@bigskip@hrule@bigskip
@end iftex
@ifnottex
------------------------------------------------------------------------
@end ifnottex

@node Input/Output
@subsection Input/Output
@anchor{#inputoutput}
In Lisp, each internal data structure has a well-defined external
representation in human-readable format. All kinds of data can be
written to a file, and restored later to their original form by reading
that file.

For all input functions besides @code{wr}, @code{rd} and @code{echo} the
input is assumed to be valid UTF-8, consisting only of characters
allowed in picolisp symbol names.

In normal operation, the PicoLisp interpreter continually executes an
infinite "read-eval-print loop". It reads one expression at a time,
evaluates it, and prints the result to the console. Any input into the
system, like data structures and function definitions, is done in a
consistent way no matter whether it is entered at the console or read
from a file.

Comments can be embedded in the input stream with the hash @code{#}
character. Everything up to the end of that line will be ignored by the
reader.

@verbatim
: (* 1 2 3)  # This is a comment
-> 6
@end verbatim

A comment spanning several lines (a block comment) may be enclosed
between @code{#@{} and @code{@}#}. Block comments may be nested.

Here is the I/O syntax for the individual PicoLisp data types (numbers,
symbols and lists) and for read-macros:

@iftex
@bigskip@hrule@bigskip
@end iftex
@ifnottex
------------------------------------------------------------------------
@end ifnottex

@menu
* Numbers::
* Symbols::
* Lists::
* Read-Macros::
@end menu

@node Numbers
@subsubsection Numbers
@anchor{#numbers-1}
A number consists of an arbitrary number of digits ('@code{0}' through
'@code{9}'), optionally preceded by a sign character ('@code{+}' or
'@code{-}'). Legal number input is:

@verbatim
: 7
-> 7
: -12345678901245678901234567890
-> -12345678901245678901234567890
@end verbatim

Fixpoint numbers can be input by embedding a decimal point '@code{.}',
and setting the global variable @code{*Scl} appropriately:

@verbatim
: *Scl
-> 0

: 123.45
-> 123
: 456.78
-> 457

: (setq *Scl 3)
-> 3
: 123.45
-> 123450
: 456.78
-> 456780
@end verbatim

Thus, fixpoint input simply scales the number to an integer value
corresponding to the number of digits in @code{*Scl}.

Formatted output of scaled fixpoint values can be done with the
@code{format} and @code{round} functions:

@verbatim
: (format 1234567890 2)
-> "12345678.90"
: (format 1234567890 2 "." ",")
-> "12,345,678.90"
@end verbatim

@iftex
@bigskip@hrule@bigskip
@end iftex
@ifnottex
------------------------------------------------------------------------
@end ifnottex

@node Symbols
@subsubsection Symbols
@anchor{#symbols-1}
The reader is able to recognize the individual symbol types from their
syntactic form. A symbol name should - of course - not look like a legal
number (see above).

In general, symbol names are case-sensitive. @code{car} is not the same
as @code{CAR}.

@iftex
@bigskip@hrule@bigskip
@end iftex
@ifnottex
------------------------------------------------------------------------
@end ifnottex
NIL
Besides the standard form, @code{NIL} is also recognized as @code{()},
@code{[]} or @code{""}.

@verbatim
: NIL
-> NIL
: ()
-> NIL
: ""
-> NIL
@end verbatim

Output will always appear as @code{NIL}.

@iftex
@bigskip@hrule@bigskip
@end iftex
@ifnottex
------------------------------------------------------------------------
@end ifnottex
Internal Symbols
Internal symbol names can consist of any printable (non-whitespace)
character, except for the following meta characters:

@verbatim
   "  '  (  )  ,  [  ]  `  ~ { }
@end verbatim

It is possible, though, to include these special characters into symbol
names by escaping them with a backslash '@code{\}'.

The dot '@code{.}' has a dual nature. It is a meta character when
standing alone, denoting a @ref{#dotted,dotted pair}, but can otherwise
be used in symbol names.

As a rule, anything not recognized by the reader as another data type
will be returned as an internal symbol.

@iftex
@bigskip@hrule@bigskip
@end iftex
@ifnottex
------------------------------------------------------------------------
@end ifnottex
Transient Symbols
A transient symbol is anything surrounded by double quotes '@code{"}'.
With that, it looks like - and can be used as - a string constant in
other languages. However, it is a real symbol, and may be assigned a
value or a function definition, and properties.

Initially, a transient symbol's value is that symbol itself, so that it
does not need to be quoted for evaluation:

@verbatim
: "This is a string"
-> "This is a string"
@end verbatim

However, care must be taken when assigning a value to a transient
symbol. This may cause unexpected behavior:

@verbatim
: (setq "This is a string" 12345)
-> 12345
: "This is a string"
-> 12345
@end verbatim

The name of a transient symbol can contain any character except the
null-byte. Control characters can be written with a preceding hat
'@code{^}' character. A hat or a double quote character can be escaped
with a backslash '@code{\}', and a backslash itself has to be escaped
with another backslash.

@verbatim
: "We^Ird\\Str\"ing"
-> "We^Ird\\Str\"ing"
: (chop @)
-> ("W" "e" "^I" "r" "d" "\\" "S" "t" "r" "\"" "i" "n" "g")
@end verbatim

The combination of a backslash followed by 'n', 'r' or 't' is replaced
with newline ("^J"), return ("^M") or TAB ("^I"), respectively.

@verbatim
: "abc\tdef\r"
-> "abc^Idef^M"
@end verbatim

A decimal number between two backslashes can be used to specify any
unicode character directly.

@verbatim
: "√§√∂√º\8364\xyz"
-> "√§√∂√º‚Ç¨xyz"
@end verbatim

A backslash in a transient symbol name at the end of a line discards the
newline, and continues the name in the next line. In that case, all
leading spaces and tabs in that line are discarded, to allow proper
source code indentation.

@verbatim
: "abc\
   def"
-> "abcdef"
: "x \
   y \
   z"
-> "x y z"
@end verbatim

The index for transient symbols is cleared automatically before and
after @code{load}ing a source file, or it can be reset explicitly with
the @code{====} function. With that mechanism, it is possible to create
symbols with a local access scope, not accessible from other parts of
the program.

A special case of transient symbols are @emph{anonymous symbols}. These
are symbols without name (see @code{box}, @code{box?} or @code{new}).
They print as a dollar sign (@code{$}) followed by a decimal digit
string (actually their machine address).

@iftex
@bigskip@hrule@bigskip
@end iftex
@ifnottex
------------------------------------------------------------------------
@end ifnottex
External Symbols
External symbol names are surrounded by braces ('@code{@{}' and
'@code{@}}'). The characters of the symbol's name itself identify the
physical location of the external object. This is

@itemize
@item
in the 32-bit version: The number of the database file, and - separated
by a hyphen - the starting block in the database file. Both numbers are
encoded in base-64 notation (characters '@code{0}' through '@code{9}',
'@code{:}', '@code{;}', '@code{A}' through '@code{Z}' and '@code{a}'
through '@code{z}').
@item
in the 64-bit version: The number of the database file minus 1 in "hax"
notation (i.e. hexadecimal/alpha notation, where '@code{@@}' is zero,
'@code{A}' is 1 and '@code{O}' is 15 (from "alpha" to "omega")),
immediately followed (without a hyphen) the starting block in octal
('@code{0}' through '@code{7}').
@end itemize

In both cases, the database file (and possibly the hyphen) are omitted
for the first (default) file.

@iftex
@bigskip@hrule@bigskip
@end iftex
@ifnottex
------------------------------------------------------------------------
@end ifnottex

@node Lists
@subsubsection Lists
@anchor{#lists-1}
Lists are surrounded by parentheses ('@code{(}' and '@code{)}').

@code{(A)} is a list consisting of a single cell, with the symbol
@code{A} in its CAR, and @code{NIL} in its CDR.

@code{(A B C)} is a list consisting of three cells, with the symbols
@code{A}, @code{B} and @code{C} respectively in their CAR, and
@code{NIL} in the last cell's CDR.

@code{(A . B)} is a "dotted pair", a list consisting of a single cell,
with the symbol @code{A} in its CAR, and @code{B} in its CDR.

PicoLisp has built-in support for reading and printing simple circular
lists. If the dot in a dotted-pair notation is immediately followed by a
closing parenthesis, it indicates that the CDR of the last cell points
back to the beginning of that list.

@verbatim
: (let L '(a b c) (conc L L))
-> (a b c .)
: (cdr '(a b c .))
-> (b c a .)
: (cddddr '(a b c .))
-> (b c a .)
@end verbatim

A similar result can be achieved with the function @code{circ}. Such
lists must be used with care, because many functions won't terminate or
will crash when given such a list.

@iftex
@bigskip@hrule@bigskip
@end iftex
@ifnottex
------------------------------------------------------------------------
@end ifnottex

@node Read-Macros
@subsubsection Read-Macros
@anchor{#read-macros}
Read-macros in PicoLisp are special forms that are recognized by the
reader, and modify its behavior. Note that they take effect immediately
while @code{read}ing an expression, and are not seen by the @code{eval}
in the main loop.

The most prominent read-macro in Lisp is the single quote character
"@code{'}", which expands to a call of the @code{quote} function. Note
that the single quote character is also printed instead of the full
function name.

@verbatim
: '(a b c)
-> (a b c)
: '(quote . a)
-> 'a
: (cons 'quote 'a)   # (quote . a)
-> 'a
: (list 'quote 'a)   # (quote a)
-> '(a)
@end verbatim

A comma (@code{,}) will cause the reader to collect the following data
item into an @code{idx} tree in the global variable @code{*Uni}, and to
return a previously inserted equal item if present. This makes it
possible to create a unique list of references to data which do normally
not follow the rules of pointer equality. If the value of @code{*Uni} is
@code{T}, the comma read macro mechanism is disabled.

A single backquote character "@code{`}" will cause the reader to
evaluate the following expression, and return the result.

@verbatim
: '(a `(+ 1 2 3) z)
-> (a 6 z)
@end verbatim

A tilde character @code{~} inside a list will cause the reader to
evaluate the following expression, and (destructively) splice the result
into the list.

@verbatim
: '(a b c ~(list 'd 'e 'f) g h i)
-> (a b c d e f g h i)
@end verbatim

When a tilde character is used to separate two symbol names (without
surrounding whitespace), the first is taken as a namespace to look up
the second (64-bit version only).

@verbatim
: 'libA~foo  # Look up 'foo' in namespace 'libA'
-> libA~foo  # "foo" is not interned in the current namespace
@end verbatim

Reading @code{libA~foo} is equivalent to switching the current namespace
search order to @code{libA} only (with @code{symbols}), reading the
symbol @code{foo}, and then switching back to the original search order.

Brackets ('@code{[}' and '@code{]}') can be used as super parentheses. A
closing bracket will match the innermost opening bracket, or all
currently open parentheses.

@verbatim
: '(a (b (c (d]
-> (a (b (c (d))))
: '(a (b [c (d]))
-> (a (b (c (d))))
@end verbatim

Finally, reading the sequence '@code{@{@}}' will result in a new
anonymous symbol with value @code{NIL}, equivalent to a call to
@code{box} without arguments.

@verbatim
: '({} {} {})
-> ($134599965 $134599967 $134599969)
: (mapcar val @)
-> (NIL NIL NIL)
@end verbatim

@iftex
@bigskip@hrule@bigskip
@end iftex
@ifnottex
------------------------------------------------------------------------
@end ifnottex

@node Evaluation
@subsection Evaluation
@anchor{#evaluation}
PicoLisp tries to evaluate any expression encountered in the
read-eval-print loop. Basically, it does so by applying the following
three rules:

@itemize
@item
A number evaluates to itself.
@item
A symbol evaluates to its value (VAL).
@item
A list is evaluated as a function call, with the CAR as the function and
the CDR the arguments to that function. These arguments are in turn
evaluated according to these three rules.
@end itemize

@verbatim
: 1234
-> 1234        # Number evaluates to itself
: *Pid
-> 22972       # Symbol evaluates to its VAL
: (+ 1 2 3)
-> 6           # List is evaluated as a function call
@end verbatim

For the third rule, however, things get a bit more involved. First - as
a special case - if the CAR of the list is a number, the whole list is
returned as it is:

@verbatim
: (1 2 3 4 5 6)
-> (1 2 3 4 5 6)
@end verbatim

This is not really a function call, but just a convenience to avoid
having to quote simple data lists. The interpreter needs to check it
anyway, and returning the list (instead of throwing an error) is a lot
faster than calling the @code{quote} function.

Otherwise, if the CAR is a symbol or a list, PicoLisp tries to obtain an
executable function from that, by either using the symbol's value, or by
evaluating the list.

What is an executable function? Or, said in another way, what can be
applied to a list of arguments, to result in a function call? A legal
function in PicoLisp is

@table @asis
@item either

a @emph{number}. When a number is used as a function, it is simply taken
as a pointer to executable code that will be called with the list of
(unevaluated) arguments as its single parameter. It is up to that code
to evaluate the arguments, or not. Some functions do not evaluate their
arguments (e.g. @code{quote}) or evaluate only some of their arguments
(e.g. @code{setq}).
@item or

a @emph{lambda expression}. A lambda expression is a list, whose CAR is
either a symbol or a list of symbols, and whose CDR is a list of
expressions. Note: In contrast to other Lisp implementations, the symbol
LAMBDA itself does not exist in PicoLisp but is implied from context.
@end table

A few examples should help to understand the practical consequences of
these rules. In the most common case, the CAR will be a symbol defined
as a function, like the @code{*} in:

@verbatim
: (* 1 2 3)    # Call the function '*'
-> 6
@end verbatim

Inspecting the VAL of @code{*} gives

@verbatim
: *            # Get the VAL of the symbol '*'
-> 67318096
@end verbatim

The VAL of @code{*} is a number. In fact, it is the numeric
representation of a function pointer, i.e. a pointer to executable code.
This is the case for all built-in functions of PicoLisp.

Other functions in turn are written as Lisp expressions:

@verbatim
: (de foo (X Y)            # Define the function 'foo'
   (* (+ X Y) (+ X Y)) )
-> foo
: (foo 2 3)                # Call the function 'foo'
-> 25
: foo                      # Get the VAL of the symbol 'foo'
-> ((X Y) (* (+ X Y) (+ X Y)))
@end verbatim

The VAL of @code{foo} is a list. It is the list that was assigned to
@code{foo} with the @code{de} function. It would be perfectly legal to
use @code{setq} instead of @code{de}:

@verbatim
: (setq foo '((X Y) (* (+ X Y) (+ X Y))))
-> ((X Y) (* (+ X Y) (+ X Y)))
: (foo 2 3)
-> 25
@end verbatim

If the VAL of @code{foo} were another symbol, that symbol's VAL would be
used instead to search for an executable function.

As we said above, if the CAR of the evaluated expression is not a symbol
but a list, that list is evaluated to obtain an executable function.

@verbatim
: ((intern (pack "c" "a" "r")) (1 2 3))
-> 1
@end verbatim

Here, the @code{intern} function returns the symbol @code{car} whose VAL
is used then. It is also legal, though quite dangerous, to use the
code-pointer directly:

@verbatim
: *
-> 67318096
: ((* 2 33659048) 1 2 3)
-> 6
: ((quote . 67318096) 1 2 3)
-> 6
: ((quote . 1234) (1 2 3))
Segmentation fault
@end verbatim

When an executable function is defined in Lisp itself, we call it a
@emph{lambda expression}. A lambda expression always has a list of
executable expressions as its CDR. The CAR, however, must be a either a
list of symbols, or a single symbol, and it controls the evaluation of
the arguments to the executable function according to the following
rules:

@table @asis
@item When the CAR is a list of symbols

For each of these symbols an argument is evaluated, then the symbols are
bound simultaneously to the results. The body of the lambda expression
is executed, then the VAL's of the symbols are restored to their
original values. This is the most common case, a fixed number of
arguments is passed to the function.
@item Otherwise, when the CAR is the symbol @code{@@}

All arguments are evaluated and the results kept internally in a list.
The body of the lambda expression is executed, and the evaluated
arguments can be accessed sequentially with the @code{args},
@code{next}, @code{arg} and @code{rest} functions. This allows to define
functions with a variable number of evaluated arguments.
@item Otherwise, when the CAR is a single symbol

The symbol is bound to the whole unevaluated argument list. The body of
the lambda expression is executed, then the symbol is restored to its
original value. This allows to define functions with unevaluated
arguments. Any kind of interpretation and evaluation of the argument
list can be done inside the expression body.
@end table

In all cases, the return value is the result of the last expression in
the body.

@verbatim
: (de foo (X Y Z)                   # CAR is a list of symbols
   (list X Y Z) )                   # Return a list of all arguments
-> foo
: (foo (+ 1 2) (+ 3 4) (+ 5 6))
-> (3 7 11)                         # all arguments are evaluated
@end verbatim

@verbatim
: (de foo @                         # CAR is the symbol '@'
   (list (next) (next) (next)) )    # Return the first three arguments
-> foo
: (foo (+ 1 2) (+ 3 4) (+ 5 6))
-> (3 7 11)                         # all arguments are evaluated
@end verbatim

@verbatim
: (de foo X                         # CAR is a single symbol
   X )                              # Return the argument
-> foo
: (foo (+ 1 2) (+ 3 4) (+ 5 6))
-> ((+ 1 2) (+ 3 4) (+ 5 6))        # the whole unevaluated list is returned
@end verbatim

Note that these forms can also be combined. For example, to evaluate
only the first two arguments, bind the results to @code{X} and @code{Y},
and bind all other arguments (unevaluated) to @code{Z}:

@verbatim
: (de foo (X Y . Z)                 # CAR is a list with a dotted-pair tail
   (list X Y Z) )                   # Return a list of all arguments
-> foo
: (foo (+ 1 2) (+ 3 4) (+ 5 6))
-> (3 7 ((+ 5 6)))                  # Only the first two arguments are evaluated
@end verbatim

Or, a single argument followed by a variable number of arguments:

@verbatim
: (de foo (X . @)                   # CAR is a dotted-pair with '@'
   (println X)                      # print the first evaluated argument
   (while (args)                    # while there are more arguments
      (println (next)) ) )          # print the next one
-> foo
: (foo (+ 1 2) (+ 3 4) (+ 5 6))
3                                   # X
7                                   # next argument
11                                  # and the last argument
-> 11
@end verbatim

In general, if more than the expected number of arguments is supplied to
a function, these extra arguments will be ignored. Missing arguments
default to @code{NIL}.

@iftex
@bigskip@hrule@bigskip
@end iftex
@ifnottex
------------------------------------------------------------------------
@end ifnottex

@node Shared Libraries
@subsection Shared Libraries
@anchor{#shared-libraries}
Analogous to built-in functions (which are written in assembly (64-bit
version) or C (32-bit version) in the interpreter kernel), PicoLisp
functions may also be defined in shared object files (called "DLLs" on
some systems). The coding style, register usage, argument passing etc.
follow the same rules as for normal built-in functions.

Note that this has nothing to do with external (e.g. third-party)
library functions called with
@uref{https://software-lab.de/doc/refN.html#native,native}.

When the interpreter encounters a symbol supposed to be called as a
function, without a function definition, but with a name of the form
"@code{lib:sym}", then - instead of throwing an "undefined"-error - it
tries to locate a shared object file with the name @code{lib} and a
function @code{sym}, and stores a pointer to this code in the symbol's
value. From that point, this symbol @code{lib:sym} keeps that function
definition, and is undistinguishable from built-in functions. Future
calls to this function do not require another library search.

A consequence of this lookup mechanism, however, is the fact that such
symbols cannot be used directly in a function-passing context (i.e.
"@code{apply}" them) like

@verbatim
(apply + (1 2 3))
(mapcar inc (1 2 3))
@end verbatim

These calls work because @code{+} and @code{inc} already have a
(function) value at this point. Applying a shared library function like

@verbatim
(apply ext:Base64 (1 2 3))
@end verbatim

works @emph{only} if @code{ext:Base64} was either called before (and
thus automatically received a function definition), or was fetched
explicitly with @code{(getd 'ext:Base64)}.

Therefore, it is recommended to always apply such functions by passing
the symbol itself and not just the value:

@verbatim
(apply 'ext:Base64 (1 2 3))
@end verbatim

@iftex
@bigskip@hrule@bigskip
@end iftex
@ifnottex
------------------------------------------------------------------------
@end ifnottex

@node Coroutines
@subsection Coroutines
@anchor{#coroutines}
Coroutines are independent execution contexts. They may have multiple
entry and exit points, and preserve their environment between
invocations.

They are available only in the 64-bit version.

A coroutine is identified by a tag. This tag can be passed to other
functions, and (re)invoked as needed. In this regard coroutines are
similar to "continuations" in other languages.

When the tag goes out of scope while it is not actively running, the
coroutine will be garbage collected. In cases where this is desired,
using a @ref{#transient,transient} symbol for the tag is recommended.

A coroutine is created by calling @code{co}. Its @code{prg} body will be
executed, and unless @code{yield} is called at some point, the coroutine
will "fall off" at the end and disappear.

When @code{yield} is called, control is either transferred back to the
caller, or to some other - explicitly specified, and already running -
coroutine.

A coroutine is stopped and disposed when

@itemize
@item
execution falls off the end
@item
some other (co)routine calls @code{co} with that tag but without a
@code{prg} body
@item
a @code{throw} into another (co)routine environment is executed
@item
an error occurred, and @ref{#errors,error handling} was entered
@end itemize

Reentrant coroutines are not supported: A coroutine cannot resume itself
directly or indirectly.

Before using many coroutines, make sure you have sufficient stack space,
e.g. by calling

@verbatim
$ ulimit -s unlimited
@end verbatim

Without that, the stack limit in Linux is typically 8 MiB.

@iftex
@bigskip@hrule@bigskip
@end iftex
@ifnottex
------------------------------------------------------------------------
@end ifnottex

@node Interrupt
@subsection Interrupt
@anchor{#interrupt}
During the evaluation of an expression, the PicoLisp interpreter can be
interrupted at any time by hitting @code{Ctrl-C}. It will then enter the
breakpoint routine, as if @code{!} were called.

Hitting ENTER at that point will continue evaluation, while
@code{(quit)} will abort evaluation and return the interpreter to the
top level. See also @code{debug}, @code{e}, @code{^} and @code{*Dbg}

Other interrupts may be handled by @code{alarm}, @code{sigio},
@code{*Hup}, @code{*Sig[12]} and @code{*TStp[12]}.

@iftex
@bigskip@hrule@bigskip
@end iftex
@ifnottex
------------------------------------------------------------------------
@end ifnottex

@node Error Handling
@subsection Error Handling
@anchor{#error-handling}
When a runtime error occurs, execution is stopped and an error handler
is entered.

The error handler resets the I/O channels to the console, and displays
the location (if possible) and the reason of the error, followed by an
error message. That message is also stored in the global @code{*Msg},
and the location of the error in @code{^}. If the VAL of the global
@code{*Err} is non-@code{NIL} it is executed as a @code{prg} body. If
the standard input is from a terminal, a read-eval-print loop (with a
question mark "@code{?}" as prompt) is entered (the loop is exited when
an empty line is input). Then all pending @code{finally} expressions are
executed, all variable bindings restored, and all files closed. If the
standard input is not from a terminal, the interpreter terminates.
Otherwise it is reset to its top-level state.

@verbatim
: (de foo (A B) (badFoo A B))       # 'foo' calls an undefined symbol
-> foo
: (foo 3 4)                         # Call 'foo'
!? (badFoo A B)                     # Error handler entered
badFoo -- Undefined
? A                                 # Inspect 'A'
-> 3
? B                                 # Inspect 'B'
-> 4
?                                   # Empty line: Exit
:
@end verbatim

Errors can be caught with @code{catch}, if a list of substrings of
possible error messages is supplied for the first argument. In such a
case, the matching substring (or the whole error message if the
substring is @code{NIL}) is returned.

An arbitrary error can be thrown explicitly with @code{quit}.

@iftex
@bigskip@hrule@bigskip
@end iftex
@ifnottex
------------------------------------------------------------------------
@end ifnottex

@node @@ Result
@subsection @@ Result
@anchor{#result}
In certain situations, the result of the last evaluation is stored in
the VAL of the symbol @code{@@}. This can be very convenient, because it
often makes the assignment to temporary variables unnecessary.

This happens in two - only superficially similar - situations:

@table @asis
@item @code{load}

In read-eval loops, the last three results which were printed at the
console are available in @code{@@@@@@}, @code{@@@@} and @code{@@}, in
that order (i.e the latest result is in @code{@@}).

@verbatim
: (+ 1 2 3)
-> 6
: (/ 128 4)
-> 32
: (- @ @@)        # Subtract the last two results
-> 26
@end verbatim

@item Flow functions

Flow- and logic-functions store the result of their controlling
expression - respectively non-@code{NIL} results of their conditional
expression - in @code{@@}.

@verbatim
: (while (read) (println 'got: @))
abc            # User input
got: abc       # print result
123            # User input
got: 123       # print result
NIL
-> 123

: (setq L (1 2 3 4 5 1 2 3 4 5))
-> (1 2 3 4 5 1 2 3 4 5)
: (and (member 3 L) (member 3 (cdr @)) (set @ 999))
-> 999
: L
-> (1 2 3 4 5 1 2 999 4 5)
@end verbatim

Functions with controlling expressions are
@uref{https://software-lab.de/doc/refC.html#case,case},
@uref{https://software-lab.de/doc/refC.html#casq,casq},
@uref{https://software-lab.de/doc/refP.html#prog1,prog1},
@uref{https://software-lab.de/doc/refP.html#prog2,prog2}, and the bodies
of @code{*Run} tasks.

Functions with conditional expressions are
@uref{https://software-lab.de/doc/refA.html#and,and},
@uref{https://software-lab.de/doc/refC.html#cond,cond},
@uref{https://software-lab.de/doc/refD.html#do,do},
@uref{https://software-lab.de/doc/refF.html#for,for},
@uref{https://software-lab.de/doc/refI.html#if,if},
@uref{https://software-lab.de/doc/refI.html#if2,if2},
@uref{https://software-lab.de/doc/refI.html#ifn,ifn},
@uref{https://software-lab.de/doc/refL.html#loop,loop},
@uref{https://software-lab.de/doc/refN.html#nand,nand},
@uref{https://software-lab.de/doc/refN.html#nond,nond},
@uref{https://software-lab.de/doc/refN.html#nor,nor},
@uref{https://software-lab.de/doc/refN.html#not,not},
@uref{https://software-lab.de/doc/refO.html#or,or},
@uref{https://software-lab.de/doc/refS.html#state,state},
@uref{https://software-lab.de/doc/refU.html#unless,unless},
@uref{https://software-lab.de/doc/refU.html#until,until},
@uref{https://software-lab.de/doc/refW.html#when,when} and
@uref{https://software-lab.de/doc/refW.html#while,while}.

@end table

@code{@@} is generally local to functions and methods, its value is
automatically saved upon function entry and restored at exit.

@iftex
@bigskip@hrule@bigskip
@end iftex
@ifnottex
------------------------------------------------------------------------
@end ifnottex

@node Comparing
@subsection Comparing
@anchor{#comparing}
In PicoLisp, it is legal to compare data items of arbitrary type. Any
two items are either

@table @asis
@item Identical

They are the same memory object (pointer equality). For example, two
internal symbols with the same name are identical. In the 64-bit
version, also short numbers (up to 60 bits plus sign) are pointer-equal.
@item Equal

They are equal in every respect (structure equality), but need not to be
identical. Examples are numbers with the same value, transient symbols
with the same name or lists with equal elements.
@item Or they have a well-defined ordinal relationship

Numbers are comparable by their numeric value, strings by their name,
and lists recursively by their elements (if the CAR's are equal, their
CDR's are compared). For differing types, the following rule applies:
Numbers are less than symbols, and symbols are less than lists. As
special cases, @code{NIL} is always less than anything else, and
@code{T} is always greater than anything else.
@end table

To demonstrate this, @code{sort} a list of mixed data types:

@verbatim
: (sort '("abc" T (d e f) NIL 123 DEF))
-> (NIL 123 DEF "abc" (d e f) T)
@end verbatim

See also @code{max}, @code{min}, @code{rank}, @code{<}, @code{=},
@code{>} etc.

@iftex
@bigskip@hrule@bigskip
@end iftex
@ifnottex
------------------------------------------------------------------------
@end ifnottex

@node OO Concepts
@subsection OO Concepts
@anchor{#oo-concepts}
PicoLisp comes with built-in object oriented extensions. There seems to
be a common agreement upon three criteria for object orientation:

@table @asis
@item Encapsulation

Code and data are encapsulated into @emph{objects}, giving them both a
@emph{behavior} and a @emph{state}. Objects communicate by sending and
receiving @emph{messages}.
@item Inheritance

Objects are organized into @emph{classes}. The behavior of an object is
inherited from its class(es) and superclass(es).
@item Polymorphism

Objects of different classes may behave differently in response to the
same message. For that, classes may define different methods for each
message.
@end table

PicoLisp implements both objects and classes with symbols. Object-local
data are stored in the symbol's property list, while the code (methods)
and links to the superclasses are stored in the symbol's VAL
(encapsulation).

In fact, there is no formal difference between objects and classes
(except that objects usually are anonymous symbols containing mostly
local data, while classes are named internal symbols with an emphasis on
method definitions). At any time, a class may be assigned its own local
data (class variables), and any object can receive individual method
definitions in addition to (or overriding) those inherited from its
(super)classes.

PicoLisp supports multiple inheritance. The VAL of each object is a
(possibly empty) association list of message symbols and method bodies,
concatenated with a list of classes. When a message is sent to an
object, it is searched in the object's own method list, and then (with a
left-to-right depth-first search) in the tree of its classes and
superclasses. The first method found is executed and the search stops.
The search may be explicitly continued with the @code{extra} and
@code{super} functions.

Thus, which method is actually executed when a message is sent to an
object depends on the classes that the object is currently linked to
(polymorphism). As the method search is fully dynamic (late binding), an
object's type (i.e. its classes and method definitions) can be changed
even at runtime!

While a method body is being executed, the global variable @code{This}
is set to the current object, allowing the use of the short-cut property
functions @code{=:}, @code{:} and @code{::}.

@iftex
@bigskip@hrule@bigskip
@end iftex
@ifnottex
------------------------------------------------------------------------
@end ifnottex

@node Database
@subsection Database
@anchor{#database}
On the lowest level, a PicoLisp database is just a collection of
@ref{#external,external symbols}. They reside in a database file, and
are dynamically swapped in and out of memory. Only one database can be
open at a time (@code{pool}).

In addition, further external symbols can be specified to originate from
arbitrary sources via the @code{*Ext} mechanism.

Whenever an external symbol's value or property list is accessed, it
will be automatically fetched into memory, and can then be used like any
other symbol. Modifications will be written to disk only when
@code{commit} is called. Alternatively, all modifications since the last
call to @code{commit} can be discarded by calling @code{rollback}.

Note that a property with the key @code{NIL} is a @emph{volatile
property}, which is held only in memory and not written to disk on
@code{commit}, and discarded by @code{rollback}. Volatile properties can
be used by applications for any kind of temporary data.

@iftex
@bigskip@hrule@bigskip
@end iftex
@ifnottex
------------------------------------------------------------------------
@end ifnottex

@menu
* Transactions::
* Entities / Relations::
@end menu

@node Transactions
@subsubsection Transactions
@anchor{#transactions}
In the typical case there will be multiple processes operating on the
same database. These processes should be all children of the same parent
process, which takes care of synchronizing read/write operations and
heap contents. Then a database transaction is normally initiated by
calling @code{(dbSync)}, and closed by calling @code{(commit 'upd)}.
Short transactions, involving only a single DB operation, are available
in functions like @code{new!} and methods like @code{put!>} (by
convention with an exclamation mark), which implicitly call
@code{(dbSync)} and @code{(commit 'upd)} themselves.

A transaction proceeds through five phases:

@enumerate 
@item
@code{dbSync} waits to get a @code{lock} on the root object @code{*DB}.
Other processes continue reading and writing meanwhile.
@item
@code{dbSync} calls @code{sync} to synchronize with changes from other
processes. We hold the shared lock, but other processes may continue
reading.
@item
We make modifications to the internal state of external symbols with
@code{put>, set>, lose>} etc. We - and also other processes - can still
read the DB.
@item
We call @code{(commit 'upd)}. @code{commit} obtains an exclusive lock
(no more read operations by other processes), writes an optional
transaction log, and then all modified symbols. As @code{upd} is passed
to 'commit', other processes synchronize with these changes.
@item
Finally, all locks are released by 'commit'.
@end enumerate

@iftex
@bigskip@hrule@bigskip
@end iftex
@ifnottex
------------------------------------------------------------------------
@end ifnottex

@node Entities / Relations
@subsubsection Entities / Relations
@anchor{#entities-relations}
The symbols in a database can be used to store arbitrary information
structures. In typical use, some symbols represent nodes of search
trees, by holding keys, values, and links to subtrees in their VAL's.
Such a search tree in the database is called @emph{index}.

For the most part, other symbols in the database are objects derived
from the @code{+Entity} class.

Entities depend on objects of the @code{+relation} class hierarchy.
Relation-objects manage the property values of entities, they define the
application database model and are responsible for the integrity of
mutual object references and index trees.

Relations are stored as properties in the entity classes, their methods
are invoked as daemons whenever property values in an entity are
changed. When defining an @code{+Entity} class, relations are defined -
in addition to the method definitions of a normal class - with the
@code{rel} function. Predefined relation classes include

@itemize
@item
Scalar relations like
@table @asis
@item @code{+Symbol}

Symbolic data
@item @code{+String}

Strings (just a general case of symbols)
@item @code{+Number}

Integers and fixpoint numbers
@item @code{+Date}

Calendar date values, represented by a number
@item @code{+Time}

Time-of-the-day values, represented by a number
@item @code{+Blob}

"Binary large objects" stored in separate files
@item @code{+Bool}

@code{T} or @code{NIL}
@end table

@item
Object-to-object relations
@table @asis
@item @code{+Link}

A reference to some other entity
@item @code{+Hook}

A reference to an entity holding object-local index trees
@item @code{+Joint}

A bidirectional reference to some other entity
@end table

@item
Container prefix classes like
@table @asis
@item @code{+List}

A list of any of the other primitive or object relation types
@item @code{+Bag}

A list containing a mixture of any of the other types
@end table

@item
Index prefix classes
@table @asis
@item @code{+Ref}

An index with other primitives or entities as key
@item @code{+Key}

A unique index with other primitives or entities as key
@item @code{+Idx}

A full-text index, typically for strings
@item @code{+Fold}

A folded text index
@item @code{+IdxFold}

Folded substring index
@item @code{+Sn}

Tolerant index, using a modified Soundex-Algorithm
@end table

@item
And a catch-all class
@table @asis
@item @code{+Any}

Not specified, may be any of the above relations
@end table

@end itemize

@iftex
@bigskip@hrule@bigskip
@end iftex
@ifnottex
------------------------------------------------------------------------
@end ifnottex

@node Pilog PicoLisp Prolog
@subsection Pilog (PicoLisp Prolog)
@anchor{#pilog-picolisp-prolog}
A declarative language is built on top of PicoLisp, that has the
semantics of Prolog, but uses the syntax of Lisp.

For an explanation of Prolog's declarative programming style, an
introduction like "Programming in Prolog" by Clocksin/Mellish
(Springer-Verlag 1981) is recommended.

Facts and rules can be declared with the @code{be} function. For
example, a Prolog fact '@code{likes(john,mary).}' is written in Pilog
as:

@verbatim
(be likes (John Mary))
@end verbatim

and a rule '@code{likes(john,X) :- likes(X,wine), likes(X,food).}' is in
Pilog:

@verbatim
(be likes (John @X) (likes @X wine) (likes @X food))
@end verbatim

As in Prolog, the difference between facts and rules is that the latter
ones have conditions, and usually contain variables.

A variable in Pilog is any symbol starting with an at-mark character
("@code{@@}"), i.e. a @code{pat?} symbol. The symbol @code{@@} itself
can be used as an anonymous variable: It will match during unification,
but will not be bound to the matched values.

The @emph{cut} operator of Prolog (usually written as an exclamation
mark (@code{!})) is the symbol @code{T} in Pilog.

An interactive query can be done with the @code{?} function:

@verbatim
(? (likes John @X))
@end verbatim

This will print all solutions, waiting for user input after each line.
If a non-empty line (not just a ENTER key, but for example a dot
(@code{.}) followed by ENTER) is typed, it will terminate.

Pilog can be called from Lisp and vice versa:

@itemize
@item
The interface from Lisp is via the functions @code{goal} (prepare a
query from Lisp data) and @code{prove} (return an association list of
successful bindings), and the application level functions @code{pilog}
and @code{solve}.
@item
When the CAR of a Pilog clause is the symbol @code{^}, then the CDDR is
executed as a Lisp @code{prg} body and the result unified with the CADR.
@item
Within such a Lisp expression in a Pilog clause, the current bindings of
Pilog variables can be accessed with the @code{->} function.
@end itemize

@iftex
@bigskip@hrule@bigskip
@end iftex
@ifnottex
------------------------------------------------------------------------
@end ifnottex

@node Naming Conventions
@subsection Naming Conventions
@anchor{#naming-conventions}
It was necessary to introduce - and adhere to - a set of conventions for
PicoLisp symbol names. Because all (internal) symbols have a global
scope, and each symbol can only have either a value or function
definition, it would otherwise be very easy to introduce name conflicts.
Besides this, source code readability is increased when the scope of a
symbol is indicated by its name.

These conventions are not hard-coded into the language, but should be so
into the head of the programmer. Here are the most commonly used ones:

@itemize
@item
Global variables start with an asterisk "@code{*}"
@item
Global constants may be written all-uppercase
@item
Functions and other global symbols start with a lower case letter
@item
Locally bound symbols start with an upper case letter
@item
Local functions start with an underscore "@code{_}"
@item
Classes start with a plus-sign "@code{+}", where the first letter
@itemize
@item
is in lower case for abstract classes
@item
and in upper case for normal classes
@end itemize

@item
Methods end with a right arrow "@code{>}"
@item
Class variables may be indicated by an upper case letter
@end itemize

For example, a local variable could easily overshadow a function
definition:

@verbatim
: (de max-speed (car)
   (.. (get car 'speeds) ..) )
-> max-speed
@end verbatim

Inside the body of @code{max-speed} (and all other functions called
during that execution) the kernel function @code{car} is redefined to
some other value, and will surely crash if something like
@code{(car Lst)} is executed. Instead, it is safe to write:

@verbatim
: (de max-speed (Car)            # 'Car' with upper case first letter
   (.. (get Car 'speeds) ..) )
-> max-speed
@end verbatim

Note that there are also some strict naming rules (as opposed to the
voluntary conventions) that are required by the corresponding kernel
functionalities, like:

@itemize
@item
Transient symbols are enclosed in double quotes (see
@ref{#transient-io,Transient Symbols})
@item
External symbols are enclosed in braces (see @ref{#external-io,External
Symbols})
@item
Pattern-Wildcards start with an at-mark "@code{@@}" (see
@uref{https://software-lab.de/doc/refM.html#match,match} and
@uref{https://software-lab.de/doc/refF.html#fill,fill})
@item
Symbols referring to a shared library contain a colon "@code{lib:sym}"
@end itemize

With that, the last of the above conventions (local functions start with
an underscore) is not really necessary, because true local scope can be
enforced with transient symbols.

The symbols @code{T} and @code{NIL} are global constants, so care should
be taken not to bind them to some other value by mistake:

@verbatim
(de foo (R S T)
   ...
@end verbatim

However, @code{lint} will issue a warning in such a case.

@iftex
@bigskip@hrule@bigskip
@end iftex
@ifnottex
------------------------------------------------------------------------
@end ifnottex

@node Breaking Traditions
@subsection Breaking Traditions
@anchor{#breaking-traditions}
PicoLisp does not try very hard to be compatible with traditional Lisp
systems. If you are used to some other Lisp dialects, you may notice the
following differences:

@table @asis
@item Case Sensitivity

PicoLisp distinguishes between upper case and lower case characters in
symbol names. Thus, @code{CAR} and @code{car} are different symbols,
which was not the case in traditional Lisp systems.
@item @code{QUOTE}

In traditional Lisp, the @code{QUOTE} function returns its @emph{first}
unevaluated argument. In PicoLisp, on the other hand, @code{quote}
returns @emph{all} (unevaluated) argument(s).
@item @code{LAMBDA}

The @code{LAMBDA} function, in some way at the heart of traditional
Lisp, is completely missing (and @code{quote} is used instead).
@item @code{PROG}

The @code{PROG} function of traditional Lisp, with its GOTO and ENTER
functionality, is also missing. PicoLisp's @code{prog} function is just
a simple sequencer (as @code{PROGN} in some Lisps).
@item Function/Value

In PicoLisp, a symbol cannot have a value @emph{and} a function
definition at the same time. Though this is a disadvantage at first
sight, it allows a completely uniform handling of functional data.
@end table

@iftex
@bigskip@hrule@bigskip
@end iftex
@ifnottex
------------------------------------------------------------------------
@end ifnottex

@node Function Reference
@section Function Reference
@anchor{#function-reference}
This section provides a reference manual for the kernel functions, and
some extensions. See the thematically grouped list of indexes below.

Though PicoLisp is a dynamically typed language (resolved at runtime, as
opposed to statically (compile-time) typed languages), many functions
can only accept and/or return a certain set of data types. For each
function, the expected argument types and return values are described
with the following abbreviations:

The primary data types:

@itemize
@item
@code{num} - Number
@item
@code{sym} - Symbol
@item
@code{lst} - List
@end itemize

Other (derived) data types

@itemize
@item
@code{any} - Anything: Any data type
@item
@code{flg} - Flag: Boolean value (@code{NIL} or non-@code{NIL})
@item
@code{cnt} - A count or a small number
@item
@code{dat} - Date: Days, starting first of March of the year 0 A.D.
@item
@code{tim} - Time: Seconds since midnight
@item
@code{obj} - Object/Class: A symbol with methods and/or classes
@item
@code{var} - Variable: Either a symbol or a cons pair
@item
@code{exe} - Executable: An executable expression (@code{eval})
@item
@code{prg} - Prog-Body: A list of executable expressions (@code{run})
@item
@code{fun} - Function: Either a number (code-pointer), a symbol
(message) or a list (lambda)
@item
@code{msg} - Message: A symbol sent to an object (to invoke a method)
@item
@code{cls} - Class: A symbol defined as an object's class
@item
@code{typ} - Type: A list of @code{cls} symbols
@item
@code{pat} - Pattern: A symbol whose name starts with an at-mark
"@code{@@}"
@item
@code{pid} - Process ID: A number, the ID of a Unix process
@item
@code{fd} - File descriptor: The number of an open file
@item
@code{tree} - Database index tree specification
@item
@code{hook} - Database hook object
@end itemize

Arguments evaluated by the function (depending on the context) are
quoted (prefixed with the single quote character "@code{'}").

@uref{https://software-lab.de/doc/refA.html,A}
@uref{https://software-lab.de/doc/refB.html,B}
@uref{https://software-lab.de/doc/refC.html,C}
@uref{https://software-lab.de/doc/refD.html,D}
@uref{https://software-lab.de/doc/refE.html,E}
@uref{https://software-lab.de/doc/refF.html,F}
@uref{https://software-lab.de/doc/refG.html,G}
@uref{https://software-lab.de/doc/refH.html,H}
@uref{https://software-lab.de/doc/refI.html,I}
@uref{https://software-lab.de/doc/refJ.html,J}
@uref{https://software-lab.de/doc/refK.html,K}
@uref{https://software-lab.de/doc/refL.html,L}
@uref{https://software-lab.de/doc/refM.html,M}
@uref{https://software-lab.de/doc/refN.html,N}
@uref{https://software-lab.de/doc/refO.html,O}
@uref{https://software-lab.de/doc/refP.html,P}
@uref{https://software-lab.de/doc/refQ.html,Q}
@uref{https://software-lab.de/doc/refR.html,R}
@uref{https://software-lab.de/doc/refS.html,S}
@uref{https://software-lab.de/doc/refT.html,T}
@uref{https://software-lab.de/doc/refU.html,U}
@uref{https://software-lab.de/doc/refV.html,V}
@uref{https://software-lab.de/doc/refW.html,W}
@uref{https://software-lab.de/doc/refX.html,X}
@uref{https://software-lab.de/doc/refY.html,Y}
@uref{https://software-lab.de/doc/refZ.html,Z}
@uref{https://software-lab.de/doc/ref_.html,Other}

@table @asis
@item Symbol Functions

@code{    new    sym    str    char    name    nsp    sp?    pat?    fun?    all    symbols    private    local    export    import    intern    extern    ====    qsym    loc    box?    str?    ext?    touch    zap    length    size    format    chop    pack    glue    pad    align    center    text    wrap    pre?    sub?    low?    upp?    lowc    uppc    fold    val    getd    set    setq    def    de    dm    recur    undef    redef    daemon    patch    swap    xchg    on    off    onOff    zero    one    default    expr    subr    let    let?    use    accu    push    push1    push1q    pop    ++    cut    del    queue    fifo    idx    lup    cache    locale    dirname    basename}
@item Property Access

@code{    put    get    prop    ;    =:    :    ::    putl    getl    wipe    meta}
@item Predicates

@code{    atom    pair    circ?    lst?    num?    sym?    flg?    sp?    pat?    fun?    box?    str?    ext?    bool    not    ==    n==    =    <>    =0    =1    =T    n0    nT    <    <=    >    >=    match    full}
@item Arithmetics

@code{    +    -    *    /    %    */    **    inc    dec    >>    lt0    le0    ge0    gt0    abs    bit?    &    |    x|    sqrt    seed    hash    rand    max    min    length    size    accu    format    pad    money    round    bin    oct    hex    hax    fmt64}
@item List Processing

@code{    car    cdr    caar    cadr    cdar    cddr    caaar    caadr    cadar    caddr    cdaar    cdadr    cddar    cdddr    caaaar    caaadr    caadar    caaddr    cadaar    cadadr    caddar    cadddr    cdaaar    cdaadr    cdadar    cdaddr    cddaar    cddadr    cdddar    cddddr    nth    con    cons    conc    circ    rot    list    need    range    full    make    made    chain    link    yoke    copy    mix    append    delete    delq    replace    insert    remove    place    strip    split    reverse    flip    trim    clip    head    tail    stem    fin    last    member    memq    mmeq    sect    diff    index    offset    prior    assoc    rassoc    asoq    flood    rank    sort    uniq    group    length    size    bytes    val    set    xchg    push    push1    push1q    pop    ++    cut    queue    fifo    idx    balance    depth    get    fill    apply}
@item Control Flow

@code{    load    args    next    arg    rest    pass    quote    as    lit    eval    run    macro    curry    def    de    dm    recur    recurse    undef    box    new    type    isa    method    meth    send    try    super    extra    with    bind    job    let    let?    use    and    or    nand    nor    xor    bool    not    nil    t    prog    prog1    prog2    if    if2    ifn    when    unless    cond    nond    case    casq    state    while    until    loop    do    at    for    catch    throw    finally    co    yield    !    e    $    call    tick    ipid    opid    kill    quit    task    fork    detach    pipe    later    timeout    tasks    abort    bye}
@item Mapping

@code{    apply    pass    maps    map    mapc    maplist    mapcar    mapcon    mapcan    filter    extract    seek    find    pick    fully    cnt    sum    maxi    mini    fish    by}
@item Input/Output

@code{    path    in    out    fd    err    ctl    ipid    opid    pipe    any    sym    str    load    hear    tell    key    poll    peek    char    skip    eol    eof    from    till    line    format    scl    read    print    println    printsp    prin    prinl    msg    space    beep    tab    flush    rewind    ext    rd    pr    wr    wait    sync    echo    info    file    dir    lines    open    close    port    listen    accept    host    connect    udp    script    once    rc    acquire    release    tmp    pretty    pp    show    view    here    prEval    mail}
@item Object Orientation

@code{    *Class    class    dm    rel    var    var:    new    type    isa    method    meth    send    try    object    extend    super    extra    with    This    can    dep}
@item Database

@code{    pool    pool2    journal    id    blk    seq    lieu    lock    commit    rollback    mark    free    dbck    dbs    dbs+    db:    tree    db    aux    collect    genKey    genStrKey    useKey    +relation    +Any    +Bag    +Bool    +Number    +Date    +Time    +Symbol    +String    +Link    +Joint    +Blob    +Hook    +Hook2    +index    +Key    +Ref    +Ref2    +Idx    +Sn    +Fold    +IdxFold    +Aux    +UB    +Dep    +List    +Need    +Mis    +Alt    +Swap    +Entity    blob    dbSync    new!    set!    put!    inc!    blob!    upd    rel    request    request!    obj    create    fmt64    root    fetch    store    count    leaf    minKey    maxKey    init    step    scan    iter    ubIter    prune    zapTree    chkTree    db/3    db/4    db/5    val/3    lst/3    map/3    isa/2    same/3    bool/3    range/3    head/3    fold/3    part/3    tolr/3    select/3    remote/2    revolve/2}
@item Pilog

@code{    prove    ->    unify    be    clause    repeat    asserta    assertz    retract    rules    goal    fail    pilog    solve    query    ?    repeat/0    fail/0    true/0    not/1    call/1    or/2    nil/1    equal/2    different/2    append/3    member/2    delete/3    permute/2    uniq/2    asserta/1    assertz/1    retract/1    clause/2    show/1    for/2    for/3    for/4    db/3    db/4    db/5    val/3    lst/3    map/3    isa/2    same/3    bool/3    range/3    head/3    fold/3    part/3    tolr/3    select/3    remote/2}
@item Debugging

@code{    pretty    pp    show    loc    *Dbg    help    docs    doc    more    less    what    who    can    dep    debug    d    unbug    u    vi    em    ld    trace    untrace    traceAll    proc    hd    bench    bt    edit    lint    lintAll    select    update}
@item System Functions

@code{    cmd    argv    opt    version    gc    raw    alarm    sigio    kids    protect    heap    stack    adr    byte    env    trail    up    pil    sys    date    time    tzo    usec    stamp    dat$    $dat    datSym    datStr    strDat    expDat    day    week    ultimo    tim$    $tim    telStr    expTel    locale    allowed    allow    pwd    cd    chdir    ctty    info    dir    dirname    basename    errno    native    struct    lisp    exec    call    tick    kill    quit    task    fork    forked    pipe    timeout    mail    assert    test    bye}
@item Globals

@code{    NIL    pico    *CPU    *OS    *DB    T    *Solo    *PPid    *Pid    @@    @@@@    @@@@@@    This    *Prompt    *Dbg    *Zap    *Scl    *Class    *Dbs    *Run    *Hup    *Sig1    *Sig2    *TStp1    *TStp2    ^    *Err    *Msg    *Uni    *Led    *Adr    *Allow    *Fork    *Bye}
@end table

@iftex
@bigskip@hrule@bigskip
@end iftex
@ifnottex
------------------------------------------------------------------------
@end ifnottex

@node Download
@section Download
@anchor{#download}
The @code{PicoLisp} system can be downloaded from the
@uref{http://software-lab.de/down.html,PicoLisp Download} page.
