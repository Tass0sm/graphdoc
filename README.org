#+title: Graphdoc (Working Title)

If I were to copy pandoc:

I now have a type to shoot for. A reader nested inside of a PandocIO. Although,
in order to compose all of those operations, I would have to be constantly
binding and returning to manipulate things. Instead, I want one monadic type
from which I can get the innermost value. I can get this with a transformer,
because that takes the monad I'm interested in and augments it with the another
monad, producing just one monadic type. There we go. So now I have my goal and I
know how to get there, I just need to work out the details.
<2022-03-06 Sun>

Ok I think I am successfully using a transformer in my example code. I just lift
a pandocmonad action into my monad. Currently my monad is just a PandocMonad
transformed by ReaderT. Although I can just reimplement ReaderT with some other
stuff and then I can have all the functionality I want for Graphdoc Actions.
<2022-03-07 Mon>

The concern is with the intermediate representation of links. The type of an
intermediate link would be a link with a reference to just some node in the
tree. Although the trees aren't exactly indexed. So maybe the tree would be of
indicies and there would then be a map between indicies and pandocs?

That's one approach. I need to look around to see if there's a better one.

* Definitions
#+begin_src haskell
type GraphSource = [(FilePath, Text)]
data Graphdoc = Graphdoc Pandoc.Meta (Tree Pandoc)
type GraphdocIO a = ReaderT [(String, Int)] PandocIO a

-- Keeps track of the node tree for which conversion is taking place.
class GraphdocMonad m where
  convertLink :: String -> m String
#+end_src

* Reading
#+begin_src haskell
getGraphSource :: FilePath -> IO GraphSource
fixLinks :: Pandoc -> GraphdocIO Pandoc
fixLinks = do
  -- for every link
  -- if its a relative path
  -- find the node its referencing in the tree
  -- Somehow store a thunked link to the correct node? Or put in some intermediate data type representing the link and destination.

textToCorrectPandoc :: Text -> GraphdocIO Pandoc
textToCorrectPandoc t = do
  pandoc <- lift $ readMarkdown def t
  fixLinks pandoc

readBook :: GraphReaderOptions
         -> GraphSource
         -> GraphdocIO Graphdoc
readBook = do
  -- parse the summary file? :: Text -> GraphdocIO (Tree Text)
  let textTree :: Tree Text
  -- get a pandoc for each bit of text
  -- correct each link based on the tree.
  pandocTree <- traverse textToCorrectPandoc textTree
  -- return the resulting Graphdoc
  return $ graphdocFromPandocTree pandocTree
    where graphdocFromPandocTree :: Tree Pandoc -> Graphdoc
#+end_src

* Writing
#+begin_src haskell
readMarkdown :: (PandocMonad m, ToSources a)
             => ReaderOptions
             -> a
             -> m Pandoc

writeRST :: PandocMonad m
         => WriterOptions
         -> Pandoc
         -> m Text

writeBook :: GraphdocMonad m
          => GraphWriterOptions
          -> Graphdoc
          -> m GraphSource

putGraphSource :: FilePath -> GraphSource -> IO ()

main :: IO ()
main = do
  sources <- getGraphSource "./input"
  result <- runIO $ do
    doc <- readBook def sources
    writeBook def doc
  rst <- handleError result
  putGraphSource "./output" rst
#+end_src

Documentation lacks uniformity and portability. However, documentation usually
has a common structure: bits of markup text content linked together in a few
typical ways (previous, up, next, links, etc.).

There are already nice tools for converting between markup languages
([[https://pandoc.org/][Pandoc]]). This project will try to be the analog for common /structures/ of
markup text.

* Example:
#+begin_quote
#+title: page1.org

See more info [ [file:./page2.org][here] ]
#+end_quote

#+begin_quote
#+title: page2.org

See more info [ [file:./page2.org][here] ]
#+end_quote

* Design
The structure of documentation bodies can be thought of as a directed, labeled
graph, where each node contains the markup content and some metadata. The labels
describe the kind of connection.

The process of translating from a body of documentation into this intermediate
representation will be called analysis. For now, I will assume that a body of
documentation is always contained in a directory.

The process of transforming this intermediate representation for different
markup formats and node linking constructs will be called conversion.

The process of writing this intermediate representation back to a body of
documentation in the real world will be called output.

** Analysis

Analysis requires making a graph. There are several ways to do this in Haskell,
and I have chosen to use this [[https://hackage.haskell.org/package/algebraic-graphs][algebraic graphs library]]. I think it is cool.

Generally, one needs a set of vertices and edges to make a graph. We described
the vertices and edges above, so we just need to collect them from the source
files somehow. This is implemented differently for each format, although there
are some common patterns between them.

I'll go through the example of analyzing a body of HTML documentation inspired
by the [[http://www.lispworks.com/documentation/HyperSpec/Front/][Common Lisp Hyperspec]].

*** HTML Example

Each file contains the source for one vertex, so getting every vertex is mostly
accomplished by finding every file.

#+begin_src haskell
  getFilesRecursively :: FilePath -> IO [FilePath]
#+end_src

I'll assume for now that unimportant files can be filtered out based on file
path alone.

#+begin_src haskell
  isSourceFile :: FilePath -> Bool

  getSourceFiles :: FilePath -> IO [FilePath]
  getSourceFiles topdir = do
    allFiles <- getFilesRecursively topdir
    filter isSourceFile allFiles
#+end_src

Now we just need to make vertices (=DocNodes=) from these paths.

#+begin_src haskell
  getMetadata :: FilePath -> Meta

  getVertices :: FilePath -> IO [DocNode]
  getVertices topdir = do
    files <- getSourceFiles topdir
    ...
    let sources = map File files
#+end_src



Here's the beginning of chap-0a.html from the hyperspec

    #+begin_src html
<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">
<!-- Common Lisp HyperSpec (TM), version 3.0 generated by kmp on Thu, 2-May-1996 10:21am EDT -->
<HTML>
<HEAD>
<TITLE>CLHS: Credits</TITLE>
<META HTTP-EQUIV="Author" CONTENT="Kent M. Pitman">
<META HTTP-EQUIV="Organization" CONTENT="The Harlequin Group Limited">
<LINK REL=TOP HREF="../FrontMatter/index.html">
<LINK REL=COPYRIGHT HREF="../FrontMatter/About-HyperSpec.html#Legal">
<LINK REL=DISCLAIMER HREF="../FrontMatter/About-HyperSpec.html#Disclaimer">
<LINK REL=PREV HREF="../FrontMatter/Chapter-Index.html">
<LINK REL=UP HREF="../FrontMatter/Chapter-Index.html">
<LINK REL=NEXT HREF="chap-1.html">
</HEAD>
...
    #+end_src




** TODO Conversion
** TODO Output
* Motivation
Local documentation resources are more complete, editable, quickly searchable
(Example: ~C-h S~ in emacs), and in /your/ possession permanently.
