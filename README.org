#+title: Graphdoc (Working Title)

Documentation lacks uniformity and portability. However, documentation usually
has a common structure: bits of markup text content linked together in a few
typical ways (previous, up, next, links, etc.).

There are already nice tools for converting between markup languages
([[https://pandoc.org/][Pandoc]]). This project will try to be the analog for common /structures/ of
markup text.

* Design

  The structure of documentation bodies can be thought of as a directed, labeled
  graph, where each node contains the markup content and some metadata. The labels
  describe the kind of connection.

  The process of translating from a body of documentation into this intermediate
  representation will be called analysis. For now, I will assume that a body of
  documentation is always contained in a directory.

  The process of transforming this intermediate representation for different
  markup formats and node linking constructs will be called conversion.

  The process of writing this intermediate representation back to a body of
  documentation in the real world will be called output.

** Analysis

   Analysis requires making a graph. There are several ways to do this in Haskell,
   and I have chosen to use this [[https://hackage.haskell.org/package/algebraic-graphs][algebraic graphs library]]. I think it is cool.

   Generally, one needs a set of vertices and edges to make a graph. We described
   the vertices and edges above, so we just need to collect them from the source
   files somehow. This is implemented differently for each format, although there
   are some common patterns between them.

   I'll go through the example of analyzing a body of HTML documentation inspired
   by the [[http://www.lispworks.com/documentation/HyperSpec/Front/][Common Lisp Hyperspec]].

*** HTML Example

    Each file contains the source for one vertex, so getting every vertex is mostly
    accomplished by finding every file. 

    #+begin_src haskell
      getFilesRecursively :: FilePath -> IO [FilePath]
    #+end_src

    I'll assume for now that unimportant files can be filtered out based on file
    path alone.

    #+begin_src haskell
      isSourceFile :: FilePath -> Bool

      getSourceFiles :: FilePath -> IO [FilePath]
      getSourceFiles topdir = do
        allFiles <- getFilesRecursively topdir
        filter isSourceFile allFiles
    #+end_src

    Now we just need to make vertices (=DocNodes=) from these paths.

    #+begin_src haskell
      getMetadata :: FilePath -> Meta

      getVertices :: FilePath -> IO [DocNode]
      getVertices topdir = do
        files <- getSourceFiles topdir
        ...
        let sources = map File files
    #+end_src



    Here's the beginning of chap-0a.html from the hyperspec

    #+begin_src html
<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">
<!-- Common Lisp HyperSpec (TM), version 3.0 generated by kmp on Thu, 2-May-1996 10:21am EDT -->
<HTML>
<HEAD>
<TITLE>CLHS: Credits</TITLE>
<META HTTP-EQUIV="Author" CONTENT="Kent M. Pitman">
<META HTTP-EQUIV="Organization" CONTENT="The Harlequin Group Limited">
<LINK REL=TOP HREF="../FrontMatter/index.html">
<LINK REL=COPYRIGHT HREF="../FrontMatter/About-HyperSpec.html#Legal">
<LINK REL=DISCLAIMER HREF="../FrontMatter/About-HyperSpec.html#Disclaimer">
<LINK REL=PREV HREF="../FrontMatter/Chapter-Index.html">
<LINK REL=UP HREF="../FrontMatter/Chapter-Index.html">
<LINK REL=NEXT HREF="chap-1.html">
</HEAD>
...
    #+end_src




** TODO Conversion
** TODO Output
* Motivation

  Local documentation resources are more complete, editable, quickly searchable
  (Example: ~C-h S~ in emacs), and in /your/ possession permanently.
